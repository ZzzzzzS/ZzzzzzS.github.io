<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZZS</title>
  
  <subtitle>ZzzzzzS Home</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zzshub.cn/"/>
  <updated>2018-03-26T15:45:37.492Z</updated>
  <id>http://blog.zzshub.cn/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kinetis KV58 FTM模块食用指南</title>
    <link href="http://blog.zzshub.cn/2018/02/07/FTM/"/>
    <id>http://blog.zzshub.cn/2018/02/07/FTM/</id>
    <published>2018-02-07T06:12:32.000Z</published>
    <updated>2018-03-26T15:45:37.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NXP-Kinetis系列-KV58微控制器FTM模块食用指南"><a href="#NXP-Kinetis系列-KV58微控制器FTM模块食用指南" class="headerlink" title="NXP Kinetis系列 KV58微控制器FTM模块食用指南"></a>NXP Kinetis系列 KV58微控制器FTM模块食用指南</h1><blockquote><p>本文主要介绍利用FTM模块输出pwm波和利用FTM模块进行正交解码</p></blockquote><h1 id="FTM模块简介"><a href="#FTM模块简介" class="headerlink" title="FTM模块简介"></a>FTM模块简介</h1><p>FTM模块是一个多功能定时器模块,主要功能有,PWM输出、输入捕捉、输出比较、定时中断、脉冲加减计数、脉冲周期脉宽测量.在KV58中,共有FTM0,FTM1,FTM2,FTM3四个独立的FTM模块.其中FTM0和FTM3有8个通道,可用于电机或舵机的PWM输出,但不具备正交解码功能,也就是对旋转编码器输入的正反向计数功能.而FTM1和FTM2则具备正交解码功能,但是FTM1和FTM2各只有两个通道.FTM模块的时间基准来自一个16位的计数器,该计数器的值可读取,即可作为无符号数对待,也可作为有符号数的补码对待.</p><h1 id="FTM模块与TPM差异"><a href="#FTM模块与TPM差异" class="headerlink" title="FTM模块与TPM差异"></a>FTM模块与TPM差异</h1><p>熟悉恩智浦 Kinetis MCU 的朋友会发现,Kinetis 各个系列都有某种联系或者可以称为一脉相承吧！举个 L 系列的 TPM 与 K 系列的 FTM 例子吧.根据参考手册的叙述,FTM 模块是 TPM 模块改进而来的一种定时器模块,即飞思卡尔在它的 8 位单片机 HCS08 系列上应用多年的定时器模块. FTM 模块在扩展了许多功能,为 TPM 提供了低功耗和向后兼容的特性.这些增强的的功能有：有符号型计数器,硬件增加死区,故障控制输入,增强触发功能,初始化和极性控制.</p><h1 id="FTM模块特性"><a href="#FTM模块特性" class="headerlink" title="FTM模块特性"></a>FTM模块特性</h1><p>挑重点来说大概就是</p><ul><li>PWM输出</li><li>PWM死区补偿</li><li>输入计数</li><li>正交解码</li><li>兼容TPM模块</li></ul><p>等等.以下是官方的解释:</p><blockquote><h3 id="44-2-2-Features"><a href="#44-2-2-Features" class="headerlink" title="44.2.2 Features"></a>44.2.2 Features</h3><p>The FTM features include:</p><ul><li>FTM source clock is selectable. </li><li>The source clock can be the system clock, the fixed frequency clock, or an external clock </li><li>Fixed frequency clock is an additional clock input to allow the selection of an on chip clock source other than the system clock </li><li>Selecting external clock connects FTM clock to a chip level input pin therefore allowing to synchronize the FTM counter with an off chip clock source </li><li>Prescaler divide-by 1, 2, 4, 8, 16, 32, 64, or 128 </li><li>16-bit counter </li><li>It can be a free-running counter or a counter with initial and final value </li><li>The counting can be up or up-down </li><li>Each channel can be configured for input capture, output compare, or edge-aligned PWM mode </li><li>In Input Capture mode: </li><li>The capture can occur on rising edges, falling edges or both edges<br>*An input filter can be selected for some channels </li><li>In Output Compare mode the output signal can be set, cleared, or toggled on match </li><li>All channels can be configured for center-aligned PWM mode</li><li>Each pair of channels can be combined to generate a PWM signal with independent control of both edges of PWM signal </li><li>The FTM channels can operate as pairs with equal outputs, pairs with complementary outputs, or independent channels with independent outputs </li><li>The deadtime insertion is available for each complementary pair </li><li>Generation of match triggers </li><li>Initialization trigger </li><li>Software control of PWM outputs </li><li>Up to 4 fault inputs for global fault control </li><li>The polarity of each channel is configurable </li><li>The generation of an interrupt per channel </li><li>The generation of an interrupt when the counter overflows </li><li>The generation of an interrupt when the fault condition is detected </li><li>Synchronized loading of write buffered FTM registers &gt;* Write protection for critical registers </li><li>Backwards compatible with TPM </li><li>Testing of input captures for a stuck at zero and one conditions </li><li>Dual edge capture for pulse and period width measurement </li><li>Quadrature decoder with input filters, relative position counting, and interrupt on position count or capture of position count on external event</li></ul></blockquote><h1 id="FTM模块构造"><a href="#FTM模块构造" class="headerlink" title="FTM模块构造"></a>FTM模块构造</h1><p><strong>FTM模块简图</strong><br><img src="https://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%89%E5%9B%BE.png" alt=""></p><p>由图可以看出,FTM模块的核心是一个16位计数器,所有通道共用唯一一个计数器.传入FTM模块的时钟(可以是内部时钟也可以是外部脉冲)经预分频器分频后传入FTM的16位计数器,再连接至各通道.所以一个FTM模块所有通道输出频率是相同的,并且只能选择一个时钟源,也就是说一个FTM模块不能同时做到正交解码和PWM输出.另外各相邻通道组成一个通道对,由一个控制器来控制.此外还可以发现所有中断共享一个中断号,FTM中断也是先中断再判断中断类型.</p><h1 id="FTM寄存器"><a href="#FTM寄存器" class="headerlink" title="FTM寄存器"></a>FTM寄存器</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> SC;                                <span class="comment">/**&lt; Status And Control, offset: 0x0 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CNT;                               <span class="comment">/**&lt; Counter, offset: 0x4 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> MOD;                               <span class="comment">/**&lt; Modulo, offset: 0x8 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span>                                         <span class="comment">/* offset: 0xC, array step: 0x8 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> CnSC;                              <span class="comment">/**&lt; Channel (n) Status And Control, array offset: 0xC, array step: 0x8 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> CnV;                               <span class="comment">/**&lt; Channel (n) Value, array offset: 0x10, array step: 0x8 */</span></span><br><span class="line">  &#125; CONTROLS[<span class="number">8</span>];</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CNTIN;                             <span class="comment">/**&lt; Counter Initial Value, offset: 0x4C */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> STATUS;                            <span class="comment">/**&lt; Capture And Compare Status, offset: 0x50 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> MODE;                              <span class="comment">/**&lt; Features Mode Selection, offset: 0x54 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> SYNC;                              <span class="comment">/**&lt; Synchronization, offset: 0x58 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> OUTINIT;                           <span class="comment">/**&lt; Initial State For Channels Output, offset: 0x5C */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> OUTMASK;                           <span class="comment">/**&lt; Output Mask, offset: 0x60 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> COMBINE;                           <span class="comment">/**&lt; Function For Linked Channels, offset: 0x64 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> DEADTIME;                          <span class="comment">/**&lt; Deadtime Insertion Control, offset: 0x68 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> EXTTRIG;                           <span class="comment">/**&lt; FTM External Trigger, offset: 0x6C */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> POL;                               <span class="comment">/**&lt; Channels Polarity, offset: 0x70 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> FMS;                               <span class="comment">/**&lt; Fault Mode Status, offset: 0x74 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> FILTER;                            <span class="comment">/**&lt; Input Capture Filter Control, offset: 0x78 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> FLTCTRL;                           <span class="comment">/**&lt; Fault Control, offset: 0x7C */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> QDCTRL;                            <span class="comment">/**&lt; Quadrature Decoder Control And Status, offset: 0x80 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CONF;                              <span class="comment">/**&lt; Configuration, offset: 0x84 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> FLTPOL;                            <span class="comment">/**&lt; FTM Fault Input Polarity, offset: 0x88 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> SYNCONF;                           <span class="comment">/**&lt; Synchronization Configuration, offset: 0x8C */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> INVCTRL;                           <span class="comment">/**&lt; FTM Inverting Control, offset: 0x90 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> SWOCTRL;                           <span class="comment">/**&lt; FTM Software Output Control, offset: 0x94 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> PWMLOAD;                           <span class="comment">/**&lt; FTM PWM Load, offset: 0x98 */</span></span><br><span class="line">&#125; FTM_Type;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是FTM1和FTM2的<code>CONTROLS[8]</code>寄存器的后6位是没有的.</strong></p><h1 id="PWM产生"><a href="#PWM产生" class="headerlink" title="PWM产生"></a>PWM产生</h1><h2 id="PWM几种模式"><a href="#PWM几种模式" class="headerlink" title="PWM几种模式"></a>PWM几种模式</h2><p><img src="https://zzshubimage-1253829354.cosbj.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%892%E5%9B%BE.png" alt=""></p><p><img src="https://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%893%E5%9B%BE.png" alt=""></p><h2 id="PWM寄存器实例"><a href="#PWM寄存器实例" class="headerlink" title="PWM寄存器实例"></a>PWM寄存器实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ftm_pwm_init</span><span class="params">(FTM_Type* ftmn, <span class="keyword">uint8_t</span> ch, <span class="keyword">uint32_t</span> freq, <span class="keyword">uint32_t</span> duty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> clk_hz ;</span><br><span class="line">  <span class="keyword">uint16_t</span> mod;</span><br><span class="line">  <span class="keyword">uint8_t</span>  ps;</span><br><span class="line">  <span class="keyword">uint16_t</span> cv;</span><br><span class="line">  <span class="keyword">if</span>(ftmn==FTM0)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM0_MASK; <span class="comment">//打开模块时钟</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM1)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM1_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM2)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM2_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM3)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM3_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  clk_hz = CLOCK_GetBusClkFreq();     <span class="comment">// bus频率</span></span><br><span class="line">  mod = (clk_hz &gt;&gt; <span class="number">16</span> ) / freq ;      <span class="comment">// 临时用 mod 缓存一下</span></span><br><span class="line">  ps = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((mod &gt;&gt; ps) &gt;= <span class="number">1</span>)             <span class="comment">// 等 (mod &gt;&gt; ps) &lt; 1 才退出 while 循环 ，即求 PS 的最小值</span></span><br><span class="line">  &#123;</span><br><span class="line">      ps++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(ps &lt;= <span class="number">0x07</span>);                 <span class="comment">// 断言， PS 最大为 0x07 ，超过此值，则 PWM频率设置过低，或 Bus 频率过高</span></span><br><span class="line">  mod = (clk_hz &gt;&gt; ps) / freq;        <span class="comment">// 求 MOD 的值</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(ftmn==FTM0)</span><br><span class="line">  &#123;</span><br><span class="line">    cv = (duty * (mod - <span class="number">0</span> + <span class="number">1</span>)) / FTM0_PRECISON;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM1)</span><br><span class="line">  &#123;</span><br><span class="line">    cv = (duty * (mod - <span class="number">0</span> + <span class="number">1</span>)) / FTM1_PRECISON;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM2)</span><br><span class="line">  &#123;</span><br><span class="line">    cv = (duty * (mod - <span class="number">0</span> + <span class="number">1</span>)) / FTM2_PRECISON;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM3)</span><br><span class="line">  &#123;</span><br><span class="line">    cv = (duty * (mod - <span class="number">0</span> + <span class="number">1</span>)) / FTM3_PRECISON;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;SC |= FTM_SC_PS(ps);  <span class="comment">//设置预分频系数</span></span><br><span class="line">  </span><br><span class="line">  FTM0-&gt;MOD = mod;            <span class="comment">//设置计数上限</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;CONTROLS[ch].CnSC &amp;=~FTM_CnSC_ELSA_MASK;</span><br><span class="line">  ftmn-&gt;CONTROLS[ch].CnSC |= ( FTM_CnSC_MSB_MASK | FTM_CnSC_ELSB_MASK | FTM_CnSC_DMA_MASK); <span class="comment">//选择模式为边沿对齐PWM,具体见上图(配置完这一步PWM波已经开始输出)</span></span><br><span class="line">  ftmn-&gt;CONTROLS[ch].CnV = cv; <span class="comment">//通道占空比寄存器,设置占空比</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;CNTIN = <span class="number">0</span>; <span class="comment">//设置计数下限为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="正交解码"><a href="#正交解码" class="headerlink" title="正交解码"></a>正交解码</h1><p>FTM模块正交解码分为两种模式,分别是AB向模式和正交模式,平时使用较多的是正交模式.</p><p><strong>AB向模式:</strong><br><img src="https://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%89%E5%9B%BE4.png" alt=""></p><p><strong>正交模式:</strong><br><img src="https://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%89%E5%9B%BE5.png" alt=""></p><p>此外,输入通道还有硬件滤波功能,可以减小干扰.正交解码后的脉冲计数值存在CNT寄存器中,读取该寄存器不会自动清除寄存器的值.周期读取该寄存器值并且清空配合编码器就可以计算出转动速度.</p><h2 id="正交解码实例"><a href="#正交解码实例" class="headerlink" title="正交解码实例"></a>正交解码实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ftm_quad_init</span><span class="params">(FTM_Type* ftmn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(ftmn==FTM0)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM0_MASK; <span class="comment">//打开模块时钟</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM1)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM1_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM2)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM2_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM3)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM3_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;MODE |= FTM_MODE_WPDIS_MASK; <span class="comment">//关闭写保护</span></span><br><span class="line">  ftmn-&gt;MODE |= FTM_MODE_FTMEN_MASK; <span class="comment">//使能FTM功能,不然就只能使用TPM的功能</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;QDCTRL |= FTM_QDCTRL_QUADMODE_MASK; <span class="comment">//选择正交解码模式</span></span><br><span class="line">   </span><br><span class="line">  ftmn-&gt;CNTIN = <span class="number">0</span>; <span class="comment">//设置计数下限为0</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;MOD = FTM_MOD_MOD_MASK; <span class="comment">//设置计数上限为最大值(free running模式)</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;QDCTRL |= FTM_QDCTRL_QUADEN_MASK; <span class="comment">//使能正交解码</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;CNT = <span class="number">0</span>; <span class="comment">//清除计数器中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NXP-Kinetis系列-KV58微控制器FTM模块食用指南&quot;&gt;&lt;a href=&quot;#NXP-Kinetis系列-KV58微控制器FTM模块食用指南&quot; class=&quot;headerlink&quot; title=&quot;NXP Kinetis系列 KV58微控制器FTM模块食用指
      
    
    </summary>
    
    
      <category term="ARM" scheme="http://blog.zzshub.cn/tags/ARM/"/>
    
      <category term="kinetis" scheme="http://blog.zzshub.cn/tags/kinetis/"/>
    
      <category term="register" scheme="http://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>kinetis KV58 ADC模块食用指南</title>
    <link href="http://blog.zzshub.cn/2018/02/05/kinetisadc/"/>
    <id>http://blog.zzshub.cn/2018/02/05/kinetisadc/</id>
    <published>2018-02-05T06:12:32.000Z</published>
    <updated>2018-03-26T15:45:37.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目前暂时未实现硬件dma触发,目前使用中断软件触发dma搬运,有待进一步改进.</p></blockquote><h1 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Init board hardware. */</span></span><br><span class="line">  BOARD_InitBootPins();</span><br><span class="line">  BOARD_InitBootClocks();</span><br><span class="line">  BOARD_InitDebugConsole();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  SIM-&gt;SCGC6 |= SIM_SCGC6_ADC0_MASK;</span><br><span class="line">  SIM-&gt;SCGC6 |= SIM_SCGC6_DMAMUX_MASK;</span><br><span class="line">  SIM-&gt;SCGC7 |= SIM_SCGC7_DMA_MASK; </span><br><span class="line">  </span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_SOURCE(kDmaRequestMux0Group1ADC0);</span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_ENBL_MASK;</span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;EEI |= DMA_EEI_EEI0_MASK;<span class="comment">//允许错误中断</span></span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SADDR=(<span class="keyword">uint32_t</span>)&amp;ADC0-&gt;R[<span class="number">0</span>]; <span class="comment">//设置源地址</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SOFF =<span class="number">0</span>; <span class="comment">//偏移量设置成1,每传输一个字节偏移一个字节</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].ATTR =<span class="number">0</span>; <span class="comment">//每次传输8bit</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].NBYTES_MLNO=<span class="number">1</span>; <span class="comment">//附循环一次</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SLAST=<span class="number">0</span>; <span class="comment">//传输结束后地址不偏移</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DADDR=(<span class="keyword">uint32_t</span>)&amp;result;<span class="comment">//设置目标地址</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DOFF=<span class="number">0</span>; <span class="comment">//偏移量设置成1,每传输一个字节偏移一个字节</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CITER_ELINKNO = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">1</span>); <span class="comment">//主循环次数</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DLAST_SGA=<span class="number">0</span>; <span class="comment">//传输结束后不处理</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CSR |= (DMA_CSR_INTMAJOR_MASK); <span class="comment">//主循环后触发中断</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].BITER_ELINKNO = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">1</span>); <span class="comment">//与CITER值相同</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CSR &amp;= ~DMA_CSR_DREQ_MASK;</span><br><span class="line">  </span><br><span class="line">  NVIC_EnableIRQ(DMA0_DMA16_IRQn); <span class="comment">//允许中断</span></span><br><span class="line">  <span class="comment">//NVIC_EnableIRQ(ADC0_IRQn);</span></span><br><span class="line">  DMA0-&gt;ERQ |= DMA_EARS_EDREQ_0_MASK; <span class="comment">//允许DMA传输</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ADC0-&gt;CFG1 &amp;=~ADC_CFG1_ADLPC_MASK;</span><br><span class="line">  ADC0-&gt;CFG1 |= ADC_CFG1_ADIV(<span class="number">0</span>);</span><br><span class="line">  ADC0-&gt;CFG1 |= ADC_CFG1_ADLSMP_MASK;</span><br><span class="line">  ADC0-&gt;CFG1 |= ADC_CFG1_MODE(<span class="number">0</span>);</span><br><span class="line">  ADC0-&gt;CFG1 |= ADC_CFG1_ADICLK(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  ADC0-&gt;CFG2 |= ADC_CFG2_ADLSTS(<span class="number">0</span>);</span><br><span class="line">  ADC0-&gt;CFG2 |= ADC_CFG2_ADHSC_MASK;</span><br><span class="line">  ADC0-&gt;CFG2 &amp;=~ADC_CFG2_ADACKEN_MASK;</span><br><span class="line">  ADC0-&gt;CFG2 |= ADC_CFG2_MUXSEL(<span class="number">0</span>);</span><br><span class="line">  ADC0-&gt;SC2 |= ADC_SC2_DMAEN_MASK;</span><br><span class="line">  </span><br><span class="line">  ADC0-&gt;SC1[<span class="number">0</span>]  = ADC_SC1_ADCH(<span class="number">0x0</span>);</span><br><span class="line">  <span class="comment">//ADC0-&gt;SC1[0] |= ADC_SC1_AIEN_MASK;</span></span><br><span class="line">  ADC0-&gt;SC1[<span class="number">0</span>] &amp;= ~ADC_SC1_DIFF_MASK;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//while((ADC0-&gt;SC1[0] &amp; ADC_SC1_COCO_MASK) != ADC_SC1_COCO_MASK);</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//result= (uint16_t)ADC0-&gt;R[0];</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(;;) &#123; <span class="comment">/* Infinite loop to avoid leaving the main function */</span></span><br><span class="line">    __asm(<span class="string">"NOP"</span>); <span class="comment">/* something to use as a breakpoint stop while looping */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA0_DMA16_IRQHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">gpio_pin_config_t</span> test;</span><br><span class="line">  test.outputLogic=<span class="number">0</span>;</span><br><span class="line">  test.pinDirection=kGPIO_DigitalOutput;</span><br><span class="line">  GPIO_PinInit(GPIOB,<span class="number">17</span>,&amp;test);</span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;INT |= DMA_INT_INT0_MASK;<span class="comment">//清中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC0_IRQHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CSR |=DMA_CSR_START_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;目前暂时未实现硬件dma触发,目前使用中断软件触发dma搬运,有待进一步改进.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;程序代码&quot;&gt;&lt;a href=&quot;#程序代码&quot; class=&quot;headerlink&quot; title=&quot;程序代码&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="ARM" scheme="http://blog.zzshub.cn/tags/ARM/"/>
    
      <category term="kinetis" scheme="http://blog.zzshub.cn/tags/kinetis/"/>
    
      <category term="register" scheme="http://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>kinetis KV58 HSADC模块食用指南</title>
    <link href="http://blog.zzshub.cn/2018/02/04/HSADC/"/>
    <id>http://blog.zzshub.cn/2018/02/04/HSADC/</id>
    <published>2018-02-04T06:12:32.000Z</published>
    <updated>2018-03-26T15:45:37.514Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间不多,今天这个模块就简单说以下吧.</p></blockquote><h1 id="HSADC模块简单介绍"><a href="#HSADC模块简单介绍" class="headerlink" title="HSADC模块简单介绍"></a>HSADC模块简单介绍</h1><p>kv58有adc模块,也有个人感觉功能更强大的HSADC模块.kv58拥有两个12bit的hsadc模块,最高采集速度可以到5mhz,可以采集140khz~80mhz的信号.有AB通道可以同时采集,也就是说kv58可以做到4通道同时采集.另外还有支持通道乱序扫描可以做到一次触发扫描全部16个通道,相比于adc模块需要不断触发和ping-pong采集来说,hsadc的确做得更加出色.另外,hsadc模块所有通道都支持差分输入,相比于adc只有4个通道(kv58只有两个通道)支持差分输入,配置更加灵活.此外,还有过零中断,超限中断,各种错误中断等等,也可以实现adc的比较功能.</p><h1 id="HSADC模块结构简图"><a href="#HSADC模块结构简图" class="headerlink" title="HSADC模块结构简图"></a>HSADC模块结构简图</h1><p><img src="https://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/HSADC/%E8%8D%89%E5%9B%BE.png" alt=""></p><p><img src="https://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/HSADC/%E8%8D%89%E5%9B%BE2.png" alt=""></p><p>可以看出,整个结构相对于adc来说更加简洁.值得注意的是8~17通道的复用情况,需要配置相关寄存器实现复用.</p><h1 id="HSADC软件触发中断-查询-示例"><a href="#HSADC软件触发中断-查询-示例" class="headerlink" title="HSADC软件触发中断(查询)示例"></a>HSADC软件触发中断(查询)示例</h1><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is template for main module created by MCUXpresso Project Generator. Enjoy!</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"board.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pin_mux.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clock_config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief Application entry point.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Init board hardware. */</span></span><br><span class="line">  BOARD_InitBootPins();   <span class="comment">//设置管脚复用功能</span></span><br><span class="line">  BOARD_InitBootClocks(); </span><br><span class="line">  BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add your code here */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create RTOS task */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  SIM-&gt;SCGC5 |= SIM_SCGC5_HSADC0_MASK;  <span class="comment">//打开时钟</span></span><br><span class="line">  NVIC_EnableIRQ(HSADC0_CCA_IRQn);<span class="comment">//运行中断</span></span><br><span class="line">  <span class="comment">//HSADC0-&gt;PWR&amp;=~HSADC_PWR_PDA_MASK;</span></span><br><span class="line">  HSADC0-&gt;PWR=<span class="number">0</span>;<span class="comment">//PWR寄存器全0,AB通道上电,关闭延迟上电功能</span></span><br><span class="line">  HSADC0-&gt;CTRL1&amp;=~HSADC_CTRL1_SMODE_MASK;<span class="comment">//清寄存器</span></span><br><span class="line">  HSADC0-&gt;CTRL1|= HSADC_CTRL1_SMODE(<span class="number">4</span>);<span class="comment">//设置为默认模式</span></span><br><span class="line">  HSADC0-&gt;CTRL1|= HSADC_CTRL1_DMAENA_MASK;<span class="comment">//允许DMA</span></span><br><span class="line">  HSADC0-&gt;CTRL1|= HSADC_CTRL1_EOSIEA_MASK;  <span class="comment">//允许扫描完成中断发生</span></span><br><span class="line">  HSADC0-&gt;CTRL1&amp;=~HSADC_CTRL1_STOPA_MASK;<span class="comment">//关闭停止模式,打开通道</span></span><br><span class="line">  HSADC0-&gt;CTRL2|= HSADC_CTRL2_DIVA(<span class="number">2</span>);<span class="comment">//设置分频,HSRUN模式下频率不能高于80Mhz</span></span><br><span class="line">  </span><br><span class="line">  HSADC0-&gt;SDIS = <span class="number">0xFFFE</span>;<span class="comment">//设置扫描的组,只扫描一组</span></span><br><span class="line">  </span><br><span class="line">  HSADC0-&gt;CTRL3 |= HSADC_CTRL3_ADCRES(<span class="number">3</span>);<span class="comment">//设置精度为12bit</span></span><br><span class="line">  HSADC0-&gt;CTRL3 |= HSADC_CTRL3_DMASRC_MASK; <span class="comment">//DMA触发源</span></span><br><span class="line">  </span><br><span class="line">  HSADC0-&gt;SCINTEN |= <span class="number">1</span>;<span class="comment">//允许中断发生</span></span><br><span class="line">  </span><br><span class="line">  HSADC0-&gt;CTRL1 |= HSADC_CTRL1_STARTA_MASK; <span class="comment">//软件触发扫描</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//查询方式</span></span><br><span class="line">  <span class="comment">//while((HSADC0-&gt;RDY &amp; HSADC_RDY_RDY(0))!= HSADC_RDY_RDY(0));</span></span><br><span class="line">  <span class="comment">//result=HSADC0-&gt;RSLT[0];</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123; <span class="comment">/* Infinite loop to avoid leaving the main function */</span></span><br><span class="line">    <span class="comment">/* something to use as a breakpoint stop while looping */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HSADC0_CCA_IRQHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//中断方式</span></span><br><span class="line">  <span class="keyword">gpio_pin_config_t</span> test; <span class="comment">//开一个灯证明进入了中断</span></span><br><span class="line">  test.outputLogic=<span class="number">0</span>;</span><br><span class="line">  test.pinDirection=kGPIO_DigitalOutput;</span><br><span class="line">  GPIO_PinInit(GPIOB,<span class="number">17</span>,&amp;test);</span><br><span class="line">  result=HSADC0-&gt;RSLT[<span class="number">0</span>];</span><br><span class="line">  HSADC0-&gt;STAT |= HSADC_STAT_EOSIA_MASK ; <span class="comment">//清中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管脚分配"><a href="#管脚分配" class="headerlink" title="管脚分配"></a>管脚分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BOARD_InitPins</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  CLOCK_EnableClock(kCLOCK_PortB);                           <span class="comment">/* Port B Clock Gate Control: Clock enabled */</span></span><br><span class="line">  CLOCK_EnableClock(kCLOCK_PortE);                           <span class="comment">/* Port E Clock Gate Control: Clock enabled */</span></span><br><span class="line"></span><br><span class="line">  PORT_SetPinMux(PORTB, PIN17_IDX, kPORT_MuxAsGpio);         <span class="comment">/* PORTB17 (pin 63) is configured as PTB17 */</span></span><br><span class="line">  PORT_SetPinMux(PORTE, PIN16_IDX, kPORT_PinDisabledOrAnalog); <span class="comment">/* PORTE16 (pin 10) is configured as HSADC0A_CH0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;时间不多,今天这个模块就简单说以下吧.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;HSADC模块简单介绍&quot;&gt;&lt;a href=&quot;#HSADC模块简单介绍&quot; class=&quot;headerlink&quot; title=&quot;HSADC模块简单介绍&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="ARM" scheme="http://blog.zzshub.cn/tags/ARM/"/>
    
      <category term="kinetis" scheme="http://blog.zzshub.cn/tags/kinetis/"/>
    
      <category term="register" scheme="http://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>kinetis KV58 DMA模块食用指南</title>
    <link href="http://blog.zzshub.cn/2018/01/30/DMAregister/"/>
    <id>http://blog.zzshub.cn/2018/01/30/DMAregister/</id>
    <published>2018-01-30T06:12:32.000Z</published>
    <updated>2018-03-26T15:45:37.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NXP-Kinetis系列-KV58微控制器DMA模块食用指南"><a href="#NXP-Kinetis系列-KV58微控制器DMA模块食用指南" class="headerlink" title="NXP Kinetis系列 KV58微控制器DMA模块食用指南"></a>NXP Kinetis系列 KV58微控制器DMA模块食用指南</h1><blockquote><p>本文主要以KV58为例介绍kinetis系列微控制器的DMA模块的寄存器以及配置方法.</p></blockquote><h1 id="DMA是什么"><a href="#DMA是什么" class="headerlink" title="DMA是什么"></a>DMA是什么</h1><p> DMA全称直接内存访问(Direct Memory Access).是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通,而不需要依赖于 CPU 的大量中断负载.工作过程中不需要CPU干预,也不需要像中断处理方式那样需要保留现场,恢复现场之类的麻烦事,简单理解为一条直接连通外设与RAM的硬件通道,所以DMA技术可以提高系统运行效率（即CPU可以干其他的事去,算是一种简单的并行模式吧）.关于更多DMA的说明这里就不再多说,可以参考参考百度百科的说明<a href="https://baike.baidu.com/item/DMA/2385376?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/DMA/2385376?fr=aladdin</a></p><h1 id="Kinetis的DMA"><a href="#Kinetis的DMA" class="headerlink" title="Kinetis的DMA"></a>Kinetis的DMA</h1><p>对于kinetis来说,DMA主要分为两大模块</p><ul><li><strong>DMAMUX</strong>    直接内存访问多路复用器(Direct Memory Access Multiplexer)</li><li><strong>eDMA</strong> 直接内存访问控制器(Enhanced Direct Memory Access)</li></ul><p>DMAMUX实质上是一个矩阵开关,负责将DMA的触发源映射到对应的DMA通道中.而eDMA才是真正搬运数据的模块,可以看到,kinetis的DMA前多了个<strong>e</strong>,代表Enhanced增强型.从这里也可以看出kinetis系列DMA的强大和灵活了.eDMA模块下又主要分为了两大部分: TCD传输控制器(Transfer Control Descriptor)用于控制每个通道的传输情况以及DMA引擎(eDMA engine)用于控制整个DMA引擎的状态,如下图所示 (<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf" target="_blank" rel="noopener">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 486</a>):</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89%E5%9B%BE.png" alt=""></p><p>DMA是如何搬运数据的可以用一下流程图来描述:</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/6374029876143.jpg" alt=""></p><p>如图所示,DMA触发源先经过DMAMUX将源分配到不同的DMA通道上,不同的DMA通道根据TCD寄存器的配置来将数据从源地址搬运到目标地址.那么这样来看,配置寄存器主要就分为以下几个步骤:</p><ul><li>打开有关的时钟(DMAMUX,eDMA,其他用到的模块如SPI的时钟)</li><li>配置DMAMUX触发源</li><li>配置eDMA引擎相关寄存器</li><li>配置TCD传输相关寄存器</li><li>打开相关外设的DMA使能</li><li>打开DMA中断等,开始DMA传输</li></ul><h1 id="DMAMUX模块"><a href="#DMAMUX模块" class="headerlink" title="DMAMUX模块"></a>DMAMUX模块</h1><p>前面说到DMAMUX是配置触发源到DMA通道,KV58微控制器有64个触发源,32个DMA通道.64个触发源如下(摘自CMSIS MKV58F24.h):</p><h2 id="DMAMUX触发源"><a href="#DMAMUX触发源" class="headerlink" title="DMAMUX触发源"></a>DMAMUX触发源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _dma_request_source</span><br><span class="line">&#123;</span><br><span class="line">    kDmaRequestMux0Disable          = <span class="number">0</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; DMAMUX TriggerDisabled. */</span></span><br><span class="line">    kDmaRequestMux0Reserved1        = <span class="number">1</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; Reserved1 */</span></span><br><span class="line">    kDmaRequestMux0UART0Rx          = <span class="number">2</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; UART0 Receive. */</span></span><br><span class="line">    kDmaRequestMux0UART0Tx          = <span class="number">3</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; UART0 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0UART1Rx          = <span class="number">4</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; UART1 Receive. */</span></span><br><span class="line">    kDmaRequestMux0UART1Tx          = <span class="number">5</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; UART1 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0PWM0WR0          = <span class="number">6</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; PWM0 Write Request 0. */</span></span><br><span class="line">    kDmaRequestMux0PWM0WR1          = <span class="number">7</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; PWM0 Write Request 1. */</span></span><br><span class="line">    kDmaRequestMux0PWM0WR2          = <span class="number">8</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; PWM0 Write Request 2. */</span></span><br><span class="line">    kDmaRequestMux0PWM0WR3          = <span class="number">9</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; PWM0 Write Request 3. */</span></span><br><span class="line">    kDmaRequestMux0PWM0CP0          = <span class="number">10</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PWM0 Capture 0. */</span></span><br><span class="line">    kDmaRequestMux0PWM0CP1          = <span class="number">11</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PWM0 Capture 1. */</span></span><br><span class="line">    kDmaRequestMux0PWM0CP2          = <span class="number">12</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PWM0 Capture 2. */</span></span><br><span class="line">    kDmaRequestMux0PWM0CP3          = <span class="number">13</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PWM0 Capture 3. */</span></span><br><span class="line">    kDmaRequestMux0CAN0             = <span class="number">14</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CAN0. */</span></span><br><span class="line">    kDmaRequestMux0CAN1             = <span class="number">15</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CAN1. */</span></span><br><span class="line">    kDmaRequestMux0SPI0Rx           = <span class="number">16</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; SPI0 Receive. */</span></span><br><span class="line">    kDmaRequestMux0SPI0Tx           = <span class="number">17</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; SPI0 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0XBARAOUT0        = <span class="number">18</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; XBARA Output 0. */</span></span><br><span class="line">    kDmaRequestMux0XBARAOUT1        = <span class="number">19</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; XBARA Output 1. */</span></span><br><span class="line">    kDmaRequestMux0XBARAOUT2        = <span class="number">20</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; XBARA Output 2. */</span></span><br><span class="line">    kDmaRequestMux0XBARAOUT3        = <span class="number">21</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; XBARA Output 3. */</span></span><br><span class="line">    kDmaRequestMux0I2C0             = <span class="number">22</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; I2C0. */</span></span><br><span class="line">    kDmaRequestMux0Reserved23       = <span class="number">23</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved23 */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel0     = <span class="number">24</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C0V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel1     = <span class="number">25</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C1V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel2     = <span class="number">26</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C2V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel3     = <span class="number">27</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C3V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel4     = <span class="number">28</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C4V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel5     = <span class="number">29</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C5V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel6     = <span class="number">30</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C6V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel7     = <span class="number">31</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C7V. */</span></span><br><span class="line">    kDmaRequestMux0FTM1Channel0     = <span class="number">32</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM1 C0V. */</span></span><br><span class="line">    kDmaRequestMux0FTM1Channel1     = <span class="number">33</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM1 C1V. */</span></span><br><span class="line">    kDmaRequestMux0CMP3             = <span class="number">34</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CMP3. */</span></span><br><span class="line">    kDmaRequestMux0Reserved35       = <span class="number">35</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved35 */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel0     = <span class="number">36</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C0V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel1     = <span class="number">37</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C1V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel2     = <span class="number">38</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C2V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel3     = <span class="number">39</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C3V. */</span></span><br><span class="line">    kDmaRequestMux0HSADC0A          = <span class="number">40</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; HSADC0. */</span></span><br><span class="line">    kDmaRequestMux0HSADC0B          = <span class="number">41</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; HSADC0. */</span></span><br><span class="line">    kDmaRequestMux0CMP0             = <span class="number">42</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CMP0. */</span></span><br><span class="line">    kDmaRequestMux0CMP1             = <span class="number">43</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CMP1. */</span></span><br><span class="line">    kDmaRequestMux0CMP2             = <span class="number">44</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CMP2. */</span></span><br><span class="line">    kDmaRequestMux0DAC0             = <span class="number">45</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DAC0. */</span></span><br><span class="line">    kDmaRequestMux0Reserved46       = <span class="number">46</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved46 */</span></span><br><span class="line">    kDmaRequestMux0PDB1             = <span class="number">47</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PDB1. */</span></span><br><span class="line">    kDmaRequestMux0PDB0             = <span class="number">48</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PDB0. */</span></span><br><span class="line">    kDmaRequestMux0PortA            = <span class="number">49</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTA. */</span></span><br><span class="line">    kDmaRequestMux0PortB            = <span class="number">50</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTB. */</span></span><br><span class="line">    kDmaRequestMux0PortC            = <span class="number">51</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTC. */</span></span><br><span class="line">    kDmaRequestMux0PortD            = <span class="number">52</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTD. */</span></span><br><span class="line">    kDmaRequestMux0PortE            = <span class="number">53</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTE. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel4     = <span class="number">54</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C4V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel5     = <span class="number">55</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C5V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel6     = <span class="number">56</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C6V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel7     = <span class="number">57</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C7V. */</span></span><br><span class="line">    kDmaRequestMux0Reserved58       = <span class="number">58</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved58 */</span></span><br><span class="line">    kDmaRequestMux0Reserved59       = <span class="number">59</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved59 */</span></span><br><span class="line">    kDmaRequestMux0AlwaysOn60       = <span class="number">60</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0AlwaysOn61       = <span class="number">61</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0AlwaysOn62       = <span class="number">62</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0AlwaysOn63       = <span class="number">63</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0Group1Disable    = <span class="number">0</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; DMAMUX TriggerDisabled. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved1  = <span class="number">1</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; Reserved1 */</span></span><br><span class="line">    kDmaRequestMux0Group1UART2Rx    = <span class="number">2</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; UART2 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART2Tx    = <span class="number">3</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; UART2 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART3Rx    = <span class="number">4</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; UART3 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART3Tx    = <span class="number">5</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; UART3 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1WR0    = <span class="number">6</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; PWM1 Write Request 0. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1WR1    = <span class="number">7</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; PWM1 Write Request 1. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1WR2    = <span class="number">8</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; PWM1 Write Request 2. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1WR3    = <span class="number">9</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; PWM1 Write Request 3. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1CP0    = <span class="number">10</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; PWM1 Capture 0. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1CP1    = <span class="number">11</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; PWM1 Capture 1. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1CP2    = <span class="number">12</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; PWM1 Capture 2. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1CP3    = <span class="number">13</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; PWM1 Capture 3. */</span></span><br><span class="line">    kDmaRequestMux0Group1CAN2       = <span class="number">14</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; CAN2. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved15 = <span class="number">15</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved15 */</span></span><br><span class="line">    kDmaRequestMux0Group1SPI1Rx     = <span class="number">16</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; SPI1 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1SPI1Tx     = <span class="number">17</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; SPI1 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved18 = <span class="number">18</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved18 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved19 = <span class="number">19</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved19 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved20 = <span class="number">20</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved20 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved21 = <span class="number">21</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved21 */</span></span><br><span class="line">    kDmaRequestMux0Group1I2C1       = <span class="number">22</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; I2C1. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved23 = <span class="number">23</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved23 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved24 = <span class="number">24</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved24 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved25 = <span class="number">25</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved25 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved26 = <span class="number">26</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved26 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved27 = <span class="number">27</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved27 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved28 = <span class="number">28</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved28 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved29 = <span class="number">29</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved29 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved30 = <span class="number">30</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved30 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved31 = <span class="number">31</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved31 */</span></span><br><span class="line">    kDmaRequestMux0Group1FTM2Channel0 = <span class="number">32</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; FTM2 C0V. */</span></span><br><span class="line">    kDmaRequestMux0Group1FTM2Channel1 = <span class="number">33</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; FTM2 C1V. */</span></span><br><span class="line">    kDmaRequestMux0Group1SPI2Rx     = <span class="number">34</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; SPI2 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1SPI2Tx     = <span class="number">35</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; SPI2 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1IEEE1588Timer0 = <span class="number">36</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; ENET IEEE 1588 timer 0. */</span></span><br><span class="line">    kDmaRequestMux0Group1IEEE1588Timer1 = <span class="number">37</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; ENET IEEE 1588 timer 1. */</span></span><br><span class="line">    kDmaRequestMux0Group1IEEE1588Timer2 = <span class="number">38</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; ENET IEEE 1588 timer 2. */</span></span><br><span class="line">    kDmaRequestMux0Group1IEEE1588Timer3 = <span class="number">39</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; ENET IEEE 1588 timer 3. */</span></span><br><span class="line">    kDmaRequestMux0Group1HSADC1A    = <span class="number">40</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; HSADC1. */</span></span><br><span class="line">    kDmaRequestMux0Group1HSADC1B    = <span class="number">41</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; HSADC1. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved42 = <span class="number">42</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved42 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved43 = <span class="number">43</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved43 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved44 = <span class="number">44</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved44 */</span></span><br><span class="line">    kDmaRequestMux0Group1ADC0       = <span class="number">45</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; ADC0. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved46 = <span class="number">46</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved46 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved47 = <span class="number">47</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved47 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved48 = <span class="number">48</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved48 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved49 = <span class="number">49</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved49 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved50 = <span class="number">50</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved50 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved51 = <span class="number">51</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved51 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved52 = <span class="number">52</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved52 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved53 = <span class="number">53</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved53 */</span></span><br><span class="line">    kDmaRequestMux0Group1UART4Rx    = <span class="number">54</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; UART4 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART4Tx    = <span class="number">55</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; UART4 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART5Rx    = <span class="number">56</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; UART5 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART5Tx    = <span class="number">57</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; UART5 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved58 = <span class="number">58</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved58 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved59 = <span class="number">59</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved59 */</span></span><br><span class="line">    kDmaRequestMux0Group1AlwaysOn60 = <span class="number">60</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0Group1AlwaysOn61 = <span class="number">61</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0Group1AlwaysOn62 = <span class="number">62</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0Group1AlwaysOn63 = <span class="number">63</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">&#125; <span class="keyword">dma_request_source_t</span>;</span><br></pre></td></tr></table></figure><p>我们可以看到,触发源已经涵盖了大部分外设,需要注意的是60~63号触发源,这几个是常开触发源,主要可以用于需要一直触发快速搬运的地方或者是从内存搬运到内存的情况,官方解释如下((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf" target="_blank" rel="noopener">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 480</a>)):</p><blockquote><h2 id="25-5-3-Always-enabled-DMA-sources"><a href="#25-5-3-Always-enabled-DMA-sources" class="headerlink" title="25.5.3 Always-enabled DMA sources"></a>25.5.3 Always-enabled DMA sources</h2><p>In addition to the peripherals that can be used as DMA sources, there are four additional DMA sources that are always enabled. Unlike the peripheral DMA sources, where the peripheral controls the flow of data during DMA transfers, the sources that are always enabled provide no such “throttling” of the data transfers. These sources are most useful in the following cases:</p><ul><li>Performing DMA transfers to/from GPIO—Moving data from/to one or more GPIO pins, either unthrottled (that is, as fast as possible), or periodically (using the DMA triggering capability). </li><li>Performing DMA transfers from memory to memory—Moving data from memory to memory, typically as fast as possible, sometimes with software activation.</li><li>Performing DMA transfers from memory to the external bus, or vice-versa—Similar to memory to memory transfers, this is typically done as quickly as possible.</li><li>Any DMA transfer that requires software activation—Any DMA transfer that should be explicitly started by software.</li></ul></blockquote><h2 id="DMAMUX寄存器"><a href="#DMAMUX寄存器" class="headerlink" title="DMAMUX寄存器"></a>DMAMUX寄存器</h2><p>寄存器定义在MKV58F24.h中定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   -- DMAMUX Peripheral Access Layer</span></span><br><span class="line"><span class="comment">   ---------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup DMAMUX_Peripheral_Access_Layer DMAMUX Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** DMAMUX - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> CHCFG[<span class="number">32</span>];                          <span class="comment">/**&lt; Channel Configuration register, array offset: 0x0, array step: 0x1 */</span></span><br><span class="line">&#125; DMAMUX_Type;</span><br></pre></td></tr></table></figure><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%892%E5%9B%BE.png" alt=""></p><p>((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf" target="_blank" rel="noopener">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 477</a>))</p><p>可以看到非常的简单,每一个8位寄存器对应着每一个DMA通道.<br>ENBL用于开启相应的复用开关,SOURCE对应着前面枚举的64个DMA触发源.有点特殊的是TRIG,这个可以使用PIT定时器周期性触发DMA,不过只有前4个DMA通道支持该功能,关于详细的部分可以在PIT定时器的相关章节找到.</p><h2 id="DMAMUX配置顺序"><a href="#DMAMUX配置顺序" class="headerlink" title="DMAMUX配置顺序"></a>DMAMUX配置顺序</h2><ul><li>清空寄存器</li><li>选择相关的复用通道配置需要的触发源</li><li>选择是否需要周期触发功能</li><li>打开该复用通道</li></ul><p>以下是官方的解释((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf" target="_blank" rel="noopener">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 481</a>)):</p><blockquote><ul><li>Determine with which DMA channel the source will be associated. Note that only the first 4 DMA channels have periodic triggering capability.</li><li>Clear the CHCFG[ENBL] and CHCFG[TRIG] fields of the DMA channel.</li><li>Ensure that the DMA channel is properly configured in the DMA. The DMA channel may be enabled at this point. </li><li>Configure the corresponding timer. </li><li>Select the source to be routed to the DMA channel. Write to the corresponding CHCFG register, ensuring that the CHCFG[ENBL] and CHCFG[TRIG] fields are set. </li></ul></blockquote><h2 id="DMAMUX配置实例"><a href="#DMAMUX配置实例" class="headerlink" title="DMAMUX配置实例"></a>DMAMUX配置实例</h2><p>以下是一个DMAMUX配置的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SIM-&gt;SCGC6 |= SIM_SCGC6_DMAMUX_MASK; <span class="comment">//打开DMAMUX时钟</span></span><br><span class="line">DMAMUX-&gt;CHCFG[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//清空寄存器通道0</span></span><br><span class="line">DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_SOURCE(kDmaRequestMux0AlwaysOn63);<span class="comment">//配置63号源到通道0</span></span><br><span class="line">DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_ENBL_MASK;<span class="comment">//使能通道</span></span><br></pre></td></tr></table></figure><h1 id="eDMA模块"><a href="#eDMA模块" class="headerlink" title="eDMA模块"></a>eDMA模块</h1><p>接下来才是重头戏,eDMA模块.</p><h2 id="eDMA-特性"><a href="#eDMA-特性" class="headerlink" title="eDMA 特性"></a>eDMA 特性</h2><p>下面介绍下Kinetis的eDMA的一些特性，有点多，就挑重点和特色的来说了：</p><ul><li>16个独立可配置的DMA通道，其中前四个通道可配置成周期性触发(需要用到PIT模块).</li><li>52个外设触发slots(这个我担心翻译不好误人子弟了就直接用该单词替代了,用过Qt的人都这是个槽的概念,大家权当触发源来理解吧),10个直通slots,每一个slot可以通过软件编程路由到16个DMA通道中的任意一个(这个通过配置DMAMUX_CONFIGn得到).</li><li>独立可编程的源地址、目标地址和传输宽度(8bit,16bit,32bit,另外支持16byte的缓存),支持外设到RAM,RAM到外设,RAM到RAM之间的传输.<br>*　每一个通道都有一个11个寄存器的TCD（Tranfer control descripter），注意这11个寄存器（包括16位和32位宽度的寄存器）才是我们编写驱动的重点对象．</li><li>固定的优先级模式和时间轮询（round-robin）优先级模式（注意：如果不通过软件设置优先级的话，系统默认为每个通道的优先级等于它的通道号，即0通道的优先级为0，且优先级号越小，其优先级越低）</li><li>每个通道包括了三个中断标志，即DMA半传输完成标志、DMA传输完成标志和DMA传输出错标志，3个标志逻辑或成一个中断请求（所以如果都使能了，那可以通过查询相关标志寄存器来判断当前的中断类型）.</li><li>可软件中断取消DMA传输（通过配置DMA_CR_CX位）.</li></ul><p>以下是官方的解释((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf" target="_blank" rel="noopener">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 487</a>)):</p><blockquote><h2 id="26-1-3-Features"><a href="#26-1-3-Features" class="headerlink" title="26.1.3 Features"></a>26.1.3 Features</h2><p>The eDMA is a highly programmable data-transfer engine optimized to minimize any required intervention from the host processor. It is intended for use in applications where the data size to be transferred is statically known and not defined within the transferred data itself. The eDMA module features:</p><ul><li>All data movement via dual-address transfers: read from source, write to destination</li><li>Programmable source and destination addresses and transfer size<br>*Support for enhanced addressing modes</li><li>32-channel implementation that performs complex data transfers with minimal intervention from a host processor<br>*　Internal data buffer, used as temporary storage to support 16- and 32-byte transfers </li><li>Connections to the crossbar switch for bus mastering the data movement </li><li>Transfer control descriptor (TCD) organized to support two-deep, nested transfer operations </li><li>32-byte TCD stored in local memory for each channel </li><li>An inner data transfer loop defined by a minor byte transfer count<br>*An outer data transfer loop defined by a major iteration count </li><li>Channel activation via one of three methods: </li><li>Explicit software initiation </li><li>Initiation via a channel-to-channel linking mechanism for continuous transfers </li><li>Peripheral-paced hardware requests, one per channel </li><li>Fixed-priority and round-robin channel arbitration </li><li>Channel completion reported via programmable interrupt requests </li><li>One interrupt per channel, which can be asserted at completion of major iteration count </li><li>Programmable error terminations per channel and logically summed together to form one error interrupt to the interrupt controller </li><li>Programmable support for scatter/gather DMA processing </li><li>Support for complex data structures  </li></ul></blockquote><blockquote><p>In the discussion of this module, n is used to reference the channel number.</p></blockquote><h2 id="eDMA-channel分组"><a href="#eDMA-channel分组" class="headerlink" title="eDMA channel分组:"></a>eDMA channel分组:</h2><p>KV58中DMA通道分为两组</p><ul><li>group0 0~15通道</li><li>group1 16~31通道<br>不同通道需要设置成不同的权值,这是非常容易忽略的地方.</li></ul><h2 id="主循环和附循环"><a href="#主循环和附循环" class="headerlink" title="主循环和附循环"></a>主循环和附循环</h2><p>数据的传送分为主循环 （ major loop ） 和副循环 （ minor loop ）. 如何理解这两个概念呢。 我们不妨假设用软件来实现有规律的顺序数据传送，使用 C 语言来实现的话，可以用 for 循 环。好比用两层嵌套的 for 循环来实现。如使用 DMA 做同样的工作，过程是相同的，外层 的循环又称主循环，即 major loop 。内层循环称为副循环，即 minor loop 。 major loop 循环 一次，可能需要 minor loop 循环多次。每个 minor loop 循环都需要 DMA 源发来请求或者通 过软件请求。 每个 minor loop 传送完毕， 对应的 DMA 通道就进入空闲模式， 等待下一次 DMA 请求。当所有 DMA 传送完毕，即置 DONE 标志，并且可以通过设置选择传送完毕是否触发 中断。</p><h2 id="eDMA寄存器介绍"><a href="#eDMA寄存器介绍" class="headerlink" title="eDMA寄存器介绍"></a>eDMA寄存器介绍</h2><p>以下是eDMA模块寄存器表(摘自MKV58F24.h):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   -- DMA Peripheral Access Layer</span></span><br><span class="line"><span class="comment">   ---------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup DMA_Peripheral_Access_Layer DMA Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** DMA - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CR;                                <span class="comment">/**&lt; Control Register, offset: 0x0 */</span></span><br><span class="line">  __I  <span class="keyword">uint32_t</span> ES;                                <span class="comment">/**&lt; Error Status Register, offset: 0x4 */</span></span><br><span class="line">       <span class="keyword">uint8_t</span> RESERVED_0[<span class="number">4</span>];</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> ERQ;                               <span class="comment">/**&lt; Enable Request Register, offset: 0xC */</span></span><br><span class="line">       <span class="keyword">uint8_t</span> RESERVED_1[<span class="number">4</span>];</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> EEI;                               <span class="comment">/**&lt; Enable Error Interrupt Register, offset: 0x14 */</span></span><br><span class="line">  __O  <span class="keyword">uint8_t</span> CEEI;                               <span class="comment">/**&lt; Clear Enable Error Interrupt Register, offset: 0x18 */</span></span><br><span class="line">  __O  <span class="keyword">uint8_t</span> SEEI;                               <span class="comment">/**&lt; Set Enable Error Interrupt Register, offset: 0x19 */</span></span><br><span class="line">  __O  <span class="keyword">uint8_t</span> CERQ;                               <span class="comment">/**&lt; Clear Enable Request Register, offset: 0x1A */</span></span><br><span class="line">  __O  <span class="keyword">uint8_t</span> SERQ;                               <span class="comment">/**&lt; Set Enable Request Register, offset: 0x1B */</span></span><br><span class="line">  __O  <span class="keyword">uint8_t</span> CDNE;                               <span class="comment">/**&lt; Clear DONE Status Bit Register, offset: 0x1C */</span></span><br><span class="line">  __O  <span class="keyword">uint8_t</span> SSRT;                               <span class="comment">/**&lt; Set START Bit Register, offset: 0x1D */</span></span><br><span class="line">  __O  <span class="keyword">uint8_t</span> CERR;                               <span class="comment">/**&lt; Clear Error Register, offset: 0x1E */</span></span><br><span class="line">  __O  <span class="keyword">uint8_t</span> CINT;                               <span class="comment">/**&lt; Clear Interrupt Request Register, offset: 0x1F */</span></span><br><span class="line">       <span class="keyword">uint8_t</span> RESERVED_2[<span class="number">4</span>];</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> INT;                               <span class="comment">/**&lt; Interrupt Request Register, offset: 0x24 */</span></span><br><span class="line">       <span class="keyword">uint8_t</span> RESERVED_3[<span class="number">4</span>];</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> ERR;                               <span class="comment">/**&lt; Error Register, offset: 0x2C */</span></span><br><span class="line">       <span class="keyword">uint8_t</span> RESERVED_4[<span class="number">4</span>];</span><br><span class="line">  __I  <span class="keyword">uint32_t</span> HRS;                               <span class="comment">/**&lt; Hardware Request Status Register, offset: 0x34 */</span></span><br><span class="line">       <span class="keyword">uint8_t</span> RESERVED_5[<span class="number">12</span>];</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> EARS;                              <span class="comment">/**&lt; Enable Asynchronous Request in Stop Register, offset: 0x44 */</span></span><br><span class="line">       <span class="keyword">uint8_t</span> RESERVED_6[<span class="number">184</span>];</span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI3;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x100 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI2;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x101 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI1;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x102 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI0;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x103 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI7;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x104 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI6;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x105 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI5;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x106 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI4;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x107 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI11;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x108 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI10;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x109 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI9;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10A */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI8;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10B */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI15;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10C */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI14;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10D */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI13;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10E */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI12;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10F */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI19;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x110 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI18;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x111 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI17;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x112 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI16;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x113 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI23;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x114 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI22;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x115 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI21;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x116 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI20;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x117 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI27;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x118 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI26;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x119 */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI25;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11A */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI24;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11B */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI31;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11C */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI30;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11D */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI29;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11E */</span></span><br><span class="line">  __IO <span class="keyword">uint8_t</span> DCHPRI28;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11F */</span></span><br><span class="line">       <span class="keyword">uint8_t</span> RESERVED_7[<span class="number">3808</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span>                                         <span class="comment">/* offset: 0x1000, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> SADDR;                             <span class="comment">/**&lt; TCD Source Address, array offset: 0x1000, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="keyword">uint16_t</span> SOFF;                              <span class="comment">/**&lt; TCD Signed Source Address Offset, array offset: 0x1004, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="keyword">uint16_t</span> ATTR;                              <span class="comment">/**&lt; TCD Transfer Attributes, array offset: 0x1006, array step: 0x20 */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;                                          <span class="comment">/* offset: 0x1008, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="keyword">uint32_t</span> NBYTES_MLNO;                       <span class="comment">/**&lt; TCD Minor Byte Count (Minor Loop Mapping Disabled), array offset: 0x1008, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="keyword">uint32_t</span> NBYTES_MLOFFNO;                    <span class="comment">/**&lt; TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled), array offset: 0x1008, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="keyword">uint32_t</span> NBYTES_MLOFFYES;                   <span class="comment">/**&lt; TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled), array offset: 0x1008, array step: 0x20 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    __IO <span class="keyword">uint32_t</span> SLAST;                             <span class="comment">/**&lt; TCD Last Source Address Adjustment, array offset: 0x100C, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> DADDR;                             <span class="comment">/**&lt; TCD Destination Address, array offset: 0x1010, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="keyword">uint16_t</span> DOFF;                              <span class="comment">/**&lt; TCD Signed Destination Address Offset, array offset: 0x1014, array step: 0x20 */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;                                          <span class="comment">/* offset: 0x1016, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="keyword">uint16_t</span> CITER_ELINKNO;                     <span class="comment">/**&lt; TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled), array offset: 0x1016, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="keyword">uint16_t</span> CITER_ELINKYES;                    <span class="comment">/**&lt; TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled), array offset: 0x1016, array step: 0x20 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    __IO <span class="keyword">uint32_t</span> DLAST_SGA;                         <span class="comment">/**&lt; TCD Last Destination Address Adjustment/Scatter Gather Address, array offset: 0x1018, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="keyword">uint16_t</span> CSR;                               <span class="comment">/**&lt; TCD Control and Status, array offset: 0x101C, array step: 0x20 */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;                                          <span class="comment">/* offset: 0x101E, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="keyword">uint16_t</span> BITER_ELINKNO;                     <span class="comment">/**&lt; TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled), array offset: 0x101E, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="keyword">uint16_t</span> BITER_ELINKYES;                    <span class="comment">/**&lt; TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled), array offset: 0x101E, array step: 0x20 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; TCD[<span class="number">32</span>];</span><br><span class="line">&#125; DMA_Type;</span><br></pre></td></tr></table></figure></p><h3 id="首先介绍非常重要的TCD传输控制块寄存器"><a href="#首先介绍非常重要的TCD传输控制块寄存器" class="headerlink" title="首先介绍非常重要的TCD传输控制块寄存器"></a>首先介绍非常重要的TCD传输控制块寄存器</h3><p>以下是TCD控制块的寄存器分布((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf" target="_blank" rel="noopener">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 489</a>)):</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89%E5%9B%BE2.png" alt=""></p><h4 id="TCD-Source-Address-DMA-TCDn-SADDR"><a href="#TCD-Source-Address-DMA-TCDn-SADDR" class="headerlink" title="TCD Source Address (DMA_TCDn_SADDR)"></a>TCD Source Address (DMA_TCDn_SADDR)</h4><p>存放需要搬运的数据的源地址</p><h4 id="TCD-Signed-Source-Address-Offset-DMA-TCDn-SOFF"><a href="#TCD-Signed-Source-Address-Offset-DMA-TCDn-SOFF" class="headerlink" title="TCD Signed Source Address Offset (DMA_TCDn_SOFF)"></a>TCD Signed Source Address Offset (DMA_TCDn_SOFF)</h4><p>源地址传输一个数据之后的偏移量<br>(Sign-extended offset applied to the current source address to form the next-state value as each source read is completed.)</p><h4 id="TCD-Transfer-Attributes-DMA-TCDn-ATTR"><a href="#TCD-Transfer-Attributes-DMA-TCDn-ATTR" class="headerlink" title="TCD Transfer Attributes (DMA_TCDn_ATTR)"></a>TCD Transfer Attributes (DMA_TCDn_ATTR)</h4><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%8922%E5%9B%BE.png" alt=""></p><p>主要说其中的SSIZE和DSIZE,分别表示每一次传输的源数据宽度和目的数据宽度<br>其中000表示8bit, 001表示16bit, 010表示32bit.</p><h4 id="TCD-Minor-Byte-Count-Minor-Loop-Mapping-Disabled-DMA-TCDn-NBYTES-MLNO"><a href="#TCD-Minor-Byte-Count-Minor-Loop-Mapping-Disabled-DMA-TCDn-NBYTES-MLNO" class="headerlink" title="TCD Minor Byte Count (Minor Loop Mapping Disabled) (DMA_TCDn_NBYTES_MLNO)"></a>TCD Minor Byte Count (Minor Loop Mapping Disabled) (DMA_TCDn_NBYTES_MLNO)</h4><p>仅介绍这一种情况,即附循环映射被禁止的情况,寄存器的值表示一次附循环搬移的数据大小,如果为0则表示搬运4GB.</p><h4 id="TCD-Last-Source-Address-Adjustment-DMA-TCDn-SLAST"><a href="#TCD-Last-Source-Address-Adjustment-DMA-TCDn-SLAST" class="headerlink" title="TCD Last Source Address Adjustment (DMA_TCDn_SLAST)"></a>TCD Last Source Address Adjustment (DMA_TCDn_SLAST)</h4><p>该寄存器控制当主循环结束后源地址的偏移情况,寄存器值可为正或负,0表示不偏移.</p><h4 id="TCD-Destination-Address-DMA-TCDn-DADDR"><a href="#TCD-Destination-Address-DMA-TCDn-DADDR" class="headerlink" title="TCD Destination Address (DMA_TCDn_DADDR)"></a>TCD Destination Address (DMA_TCDn_DADDR)</h4><p>储存目标地址</p><h4 id="TCD-Signed-Destination-Address-Offset-DMA-TCDn-DOFF"><a href="#TCD-Signed-Destination-Address-Offset-DMA-TCDn-DOFF" class="headerlink" title="TCD Signed Destination Address Offset (DMA_TCDn_DOFF)"></a>TCD Signed Destination Address Offset (DMA_TCDn_DOFF)</h4><p>目标地址传输一个数据之后的偏移量</p><h4 id="TCD-Current-Minor-Loop-Link-Major-Loop-Count-Channel-Linking-Disabled-DMA-TCDn-CITER-ELINKNO"><a href="#TCD-Current-Minor-Loop-Link-Major-Loop-Count-Channel-Linking-Disabled-DMA-TCDn-CITER-ELINKNO" class="headerlink" title="TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (DMA_TCDn_CITER_ELINKNO)"></a>TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (DMA_TCDn_CITER_ELINKNO)</h4><p>仅介绍这一种情况,也就是通道之间的联系被禁止的情况.该寄存器用于表示主循环的次数.</p><h4 id="TCD-Beginning-Minor-Loop-Link-Major-Loop-Count-Channel-Linking-Disabled-DMA-TCDn-BITER-ELINKNO"><a href="#TCD-Beginning-Minor-Loop-Link-Major-Loop-Count-Channel-Linking-Disabled-DMA-TCDn-BITER-ELINKNO" class="headerlink" title="TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (DMA_TCDn_BITER_ELINKNO)"></a>TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (DMA_TCDn_BITER_ELINKNO)</h4><p>仅介绍这一种情况,该寄存器应与<code>CITER</code>寄存器配置成相同的值</p><h4 id="TCD-Last-Destination-Address-Adjustment-Scatter-Gather-Address-DMA-TCDn-DLASTSGA"><a href="#TCD-Last-Destination-Address-Adjustment-Scatter-Gather-Address-DMA-TCDn-DLASTSGA" class="headerlink" title="TCD Last Destination Address Adjustment/Scatter Gather Address (DMA_TCDn_DLASTSGA)"></a>TCD Last Destination Address Adjustment/Scatter Gather Address (DMA_TCDn_DLASTSGA)</h4><p>该寄存器控制当主循环结束后目标地址的偏移情况,寄存器值可为正或负,0表示不偏移.</p><h4 id="TCD-Control-and-Status-DMA-TCDn-CSR"><a href="#TCD-Control-and-Status-DMA-TCDn-CSR" class="headerlink" title="TCD Control and Status (DMA_TCDn_CSR)"></a>TCD Control and Status (DMA_TCDn_CSR)</h4><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89%E5%9B%BE4.png" alt=""></p><p>INTMAJOR: 允许中断<br>START:软件触发传输</p><h2 id="eDMA引擎寄存器"><a href="#eDMA引擎寄存器" class="headerlink" title="eDMA引擎寄存器"></a>eDMA引擎寄存器</h2><h4 id="Control-Register-DMA-CR"><a href="#Control-Register-DMA-CR" class="headerlink" title="Control Register (DMA_CR)"></a>Control Register (DMA_CR)</h4><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89111%E5%9B%BE.png" alt=""></p><p>最需要注意的就是<code>GRP1PRI</code>和<code>GRP0PRI</code>需要设置成不同的权值</p><h4 id="Error-Status-Register-DMA-ES"><a href="#Error-Status-Register-DMA-ES" class="headerlink" title="Error Status Register (DMA_ES)"></a>Error Status Register (DMA_ES)</h4><p>各种错误标志位寄存器</p><h4 id="Enable-Request-Register-DMA-ERQ"><a href="#Enable-Request-Register-DMA-ERQ" class="headerlink" title="Enable Request Register (DMA_ERQ)"></a>Enable Request Register (DMA_ERQ)</h4><p>允许传输寄存器</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%891234%E5%9B%BE.png" alt=""></p><h4 id="Channel-n-Priority-Register-DMA-DCHPRIn"><a href="#Channel-n-Priority-Register-DMA-DCHPRIn" class="headerlink" title="Channel n Priority Register (DMA_DCHPRIn)"></a>Channel n Priority Register (DMA_DCHPRIn)</h4><p>优先级分组寄存器,0是最低优先级.</p><h1 id="DMA模块初始化过程"><a href="#DMA模块初始化过程" class="headerlink" title="DMA模块初始化过程"></a>DMA模块初始化过程</h1><ul><li>配置CR寄存器</li><li>配置通道优先级</li><li>配置TCD传输控制块</li><li>使能传输控制</li><li>配置外设允许DMA触发或者配置软件触发</li></ul><p>以下是官方解释((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf" target="_blank" rel="noopener">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 575</a>)):</p><blockquote><h3 id="To-initialize-the-eDMA"><a href="#To-initialize-the-eDMA" class="headerlink" title="To initialize the eDMA:"></a>To initialize the eDMA:</h3><ul><li>Write to the CR if a configuration other than the default is desired. </li><li>Write the channel priority levels to the DCHPRIn registers if a configuration other than the default is desired. </li><li>Enable error interrupts in the EEI register if so desired.</li><li>Write the 32-byte TCD for each channel that may request service.</li><li>Enable any hardware service requests via the ERQ register.</li><li>Request channel service via.</li></ul></blockquote><h1 id="DMA从内存到内存传输实例"><a href="#DMA从内存到内存传输实例" class="headerlink" title="DMA从内存到内存传输实例"></a>DMA从内存到内存传输实例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Init board hardware. */</span></span><br><span class="line">  BOARD_InitBootPins();</span><br><span class="line">  BOARD_InitBootClocks();</span><br><span class="line">  BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">  SIM-&gt;SCGC7 |= SIM_SCGC7_DMA_MASK;   <span class="comment">//打开DMA时钟</span></span><br><span class="line">  SIM-&gt;SCGC6 |= SIM_SCGC6_DMAMUX_MASK;<span class="comment">//打开DMAMUX时钟</span></span><br><span class="line"></span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//清寄存器</span></span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_SOURCE(kDmaRequestMux0AlwaysOn63);<span class="comment">//配置通道0的源为63号源</span></span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_ENBL_MASK;/使能通道</span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;CR=<span class="number">0</span>;<span class="comment">//清寄存器</span></span><br><span class="line">  DMA0-&gt;CR |= DMA_CR_GRP0PRI_MASK;<span class="comment">//设置group0的优先级为1</span></span><br><span class="line">  DMA0-&gt;EEI |= DMA_EEI_EEI0_MASK;<span class="comment">//允许错误中断</span></span><br><span class="line">  DMA0-&gt;INT |= DMA_INT_INT0_MASK;<span class="comment">//清中断标志位</span></span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SADDR=(<span class="keyword">uint32_t</span>)sendtext; <span class="comment">//设置源地址</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SOFF=<span class="number">1</span>; <span class="comment">//偏移量设置成1,每传输一个字节偏移一个字节</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].ATTR =<span class="number">0</span>; <span class="comment">//每次传输8bit</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].NBYTES_MLNO=<span class="number">1</span>; <span class="comment">//附循环一次</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SLAST=<span class="number">0</span>; <span class="comment">//传输结束后地址不偏移</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DADDR=(<span class="keyword">uint32_t</span>)receivetext;<span class="comment">//设置目标地址</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DOFF=<span class="number">1</span>; /偏移量设置成<span class="number">1</span>,每传输一个字节偏移一个字节</span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CITER_ELINKNO = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">sizeof</span>(sendtext)<span class="number">-1</span>); <span class="comment">//主循环次数</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DLAST_SGA=<span class="number">0</span>; <span class="comment">//传输结束后不处理</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CSR |= (DMA_CSR_INTMAJOR_MASK); <span class="comment">//主循环后触发中断</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].BITER_ELINKNO = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">sizeof</span>(sendtext)<span class="number">-1</span>); <span class="comment">//与CITER值相同</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  NVIC_EnableIRQ(DMA0_DMA16_IRQn); <span class="comment">//允许中断</span></span><br><span class="line">  DMA0-&gt;ERQ |= DMA_EARS_EDREQ_0_MASK; <span class="comment">//允许DMA传输</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际效果:</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89456%E5%9B%BE.png" alt=""></p><p>传输前receivetext为空</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%8912344%E5%9B%BE.png" alt=""></p><p>传输后receivetext值和sendtext相同</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NXP-Kinetis系列-KV58微控制器DMA模块食用指南&quot;&gt;&lt;a href=&quot;#NXP-Kinetis系列-KV58微控制器DMA模块食用指南&quot; class=&quot;headerlink&quot; title=&quot;NXP Kinetis系列 KV58微控制器DMA模块食用指
      
    
    </summary>
    
    
      <category term="ARM" scheme="http://blog.zzshub.cn/tags/ARM/"/>
    
      <category term="kinetis" scheme="http://blog.zzshub.cn/tags/kinetis/"/>
    
      <category term="register" scheme="http://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>ARM寄存器食用感受</title>
    <link href="http://blog.zzshub.cn/2018/01/22/KinetisRegistar/"/>
    <id>http://blog.zzshub.cn/2018/01/22/KinetisRegistar/</id>
    <published>2018-01-22T15:41:34.000Z</published>
    <updated>2018-03-26T15:45:37.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARM寄存器食用感受"><a href="#ARM寄存器食用感受" class="headerlink" title="ARM寄存器食用感受"></a>ARM寄存器食用感受</h1><blockquote><p>最近研究NXP新推出的<strong>kinetis KV58</strong>微控制器,用的是NXP官方推出的MCUXpresso的SDK,研究后发现并没有想象的好用,故决定还是手撸寄存器好了.</p></blockquote><h1 id="MKV58F24-h"><a href="#MKV58F24-h" class="headerlink" title="MKV58F24.h"></a>MKV58F24.h</h1><p>首先需要关注这个头文件,该头文件中包含了KV58微控制器所有寄存器地址,是最重要的头文件.下面以<strong>GPIO</strong>为例,介绍一下撸寄存器的方法.操作每个模块主要可以分为3部分.</p><ul><li>地址定义</li><li>寄存器结构体定义</li><li>操作掩码宏定义</li></ul><p>此外,手册中还定义了其他内容,如中断向量表,DMA触发源表,编译器设置,版本信息等等.</p><h2 id="地址定义"><a href="#地址定义" class="headerlink" title="地址定义"></a>地址定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @&#125;</span></span><br><span class="line"><span class="comment"> */</span> <span class="comment">/* end of group GPIO_Register_Masks */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO - Peripheral instance base addresses */</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOA base address */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA_BASE                               (0x400FF000u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOA base pointer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA                                    ((GPIO_Type *)GPIOA_BASE)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOB base address */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB_BASE                               (0x400FF040u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOB base pointer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB                                    ((GPIO_Type *)GPIOB_BASE)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOC base address */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOC_BASE                               (0x400FF080u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOC base pointer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOC                                    ((GPIO_Type *)GPIOC_BASE)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOD base address */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOD_BASE                               (0x400FF0C0u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOD base pointer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOD                                    ((GPIO_Type *)GPIOD_BASE)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOE base address */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOE_BASE                               (0x400FF100u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOE base pointer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOE                                    ((GPIO_Type *)GPIOE_BASE)</span></span><br><span class="line"><span class="comment">/** Array initializer of GPIO peripheral base addresses */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_BASE_ADDRS                          &#123; GPIOA_BASE, GPIOB_BASE, GPIOC_BASE, GPIOD_BASE, GPIOE_BASE &#125;</span></span><br><span class="line"><span class="comment">/** Array initializer of GPIO peripheral base pointers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_BASE_PTRS                           &#123; GPIOA, GPIOB, GPIOC, GPIOD, GPIOE &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @&#125;</span></span><br><span class="line"><span class="comment"> */</span> <span class="comment">/* end of group GPIO_Peripheral_Access_Layer */</span></span><br></pre></td></tr></table></figure><p> 可以看出,文件中定义了各gpio寄存器的首地址<code>GPIOx_BASE</code>,定义了指向首地址的指针<code>GPIOx</code>.使用宏定义的方式可以显著减少代码量,采用首地址加偏移量的方式就可以访问各个寄存器了.</p><hr><h2 id="寄存器结构体"><a href="#寄存器结构体" class="headerlink" title="寄存器结构体"></a>寄存器结构体</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup GPIO_Peripheral_Access_Layer GPIO Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** GPIO - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> PDOR;                              <span class="comment">/**&lt; Port Data Output Register, offset: 0x0 */</span></span><br><span class="line">  __O  <span class="keyword">uint32_t</span> PSOR;                              <span class="comment">/**&lt; Port Set Output Register, offset: 0x4 */</span></span><br><span class="line">  __O  <span class="keyword">uint32_t</span> PCOR;                              <span class="comment">/**&lt; Port Clear Output Register, offset: 0x8 */</span></span><br><span class="line">  __O  <span class="keyword">uint32_t</span> PTOR;                              <span class="comment">/**&lt; Port Toggle Output Register, offset: 0xC */</span></span><br><span class="line">  __I  <span class="keyword">uint32_t</span> PDIR;                              <span class="comment">/**&lt; Port Data Input Register, offset: 0x10 */</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> PDDR;                              <span class="comment">/**&lt; Port Data Direction Register, offset: 0x14 */</span></span><br><span class="line">&#125; GPIO_Type;</span><br></pre></td></tr></table></figure><p>这就是gpio类型的结构体,gpio类型的指针可以访问寄存器,以首地址加偏移量的方式就可以访问整个寄存器中任意位置.值得注意的是其中的<code>__IO</code>和<code>__o</code>,它们意义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IO definitions (access restrictions to peripheral registers) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   __I     volatile             <span class="comment">/*!&lt; defines 'read only' permissions                 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   __I     volatile const       <span class="comment">/*!&lt; defines 'read only' permissions                 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     __O     volatile             <span class="comment">/*!&lt; defines 'write only' permissions                */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     __IO    volatile             <span class="comment">/*!&lt; defines 'read / write' permissions              */</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="操作掩码宏定义"><a href="#操作掩码宏定义" class="headerlink" title="操作掩码宏定义"></a>操作掩码宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">* ----------------------------------------------------------------------------</span><br><span class="line">   -- GPIO Register Masks</span><br><span class="line">   ---------------------------------------------------------------------------- */</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup GPIO_Register_Masks GPIO Register Masks</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PDOR - Port Data Output Register */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PDOR_PDO_MASK                       (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PDOR_PDO_SHIFT                      (0U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PDOR_PDO(x)                         (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PDOR_PDO_SHIFT)) &amp; GPIO_PDOR_PDO_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PSOR - Port Set Output Register */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PSOR_PTSO_MASK                      (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PSOR_PTSO_SHIFT                     (0U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PSOR_PTSO(x)                        (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PSOR_PTSO_SHIFT)) &amp; GPIO_PSOR_PTSO_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PCOR - Port Clear Output Register */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PCOR_PTCO_MASK                      (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PCOR_PTCO_SHIFT                     (0U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PCOR_PTCO(x)                        (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PCOR_PTCO_SHIFT)) &amp; GPIO_PCOR_PTCO_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PTOR - Port Toggle Output Register */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PTOR_PTTO_MASK                      (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PTOR_PTTO_SHIFT                     (0U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PTOR_PTTO(x)                        (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PTOR_PTTO_SHIFT)) &amp; GPIO_PTOR_PTTO_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PDIR - Port Data Input Register */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PDIR_PDI_MASK                       (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PDIR_PDI_SHIFT                      (0U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PDIR_PDI(x)                         (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PDIR_PDI_SHIFT)) &amp; GPIO_PDIR_PDI_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PDDR - Port Data Direction Register */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PDDR_PDD_MASK                       (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PDDR_PDD_SHIFT                      (0U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PDDR_PDD(x)                         (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PDDR_PDD_SHIFT)) &amp; GPIO_PDDR_PDD_MASK)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @&#125;</span></span><br><span class="line"><span class="comment"> */</span> <span class="comment">/* end of group GPIO_Register_Masks */</span></span><br></pre></td></tr></table></figure><p> 这部分主要定义了各种掩码和偏移量,方便操作寄存器,减少代码书写量.</p><h1 id="MASK-SHIFT-X-是什么"><a href="#MASK-SHIFT-X-是什么" class="headerlink" title="MASK SHIFT (X)是什么"></a>MASK SHIFT (X)是什么</h1><p> 开始看寄存器最不理解的就是掩码宏定义这一部分,不过各种掩码操作熟练以后确实能够很高效的操作寄存器.</p><h2 id="MASK"><a href="#MASK" class="headerlink" title="MASK"></a>MASK</h2><p> mask本意为遮挡,观察后发现掩码用于给某一寄存器赋1或0.<br> 比如将SPI当中的MTFE寄存器赋值1,只需要:<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPI_MCR_REG(SPIN[spin]) = ( <span class="number">0</span> | SPI_MCR_HALT_MASK);        <span class="comment">//停止SPI传输</span></span><br></pre></td></tr></table></figure></p><p>如果需要将寄存器赋值0,只需要:</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPI_MCR_REG(SPIN[spin]) = ( <span class="number">0</span> &amp; ~SPI_MCR_HALT_MASK);        <span class="comment">//开始SPI传输</span></span><br></pre></td></tr></table></figure><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p> 注意shift当中的值都是用十进制表示的,在这里,shift表示偏移量,就是寄存器相对首地址偏移的位置.</p><h2 id="x"><a href="#x" class="headerlink" title="(x)"></a>(x)</h2><p> 配合shift和mask,操作寄存器就变得简单了,这里(x)的意思就是将这个位置0或1,写法如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//置1</span></span><br><span class="line"> SPI_MCR_REG(SPIN[spin]) =  (<span class="number">0</span>|  SPI_MCR_PCSIS(pcs));</span><br><span class="line"></span><br><span class="line"><span class="comment">//置0</span></span><br><span class="line"> SPI_MCR_REG(SPIN[spin]) =  (<span class="number">0</span> &amp;  ~SPI_MCR_PCSIS(pcs));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    SPI_PCS0 = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    SPI_PCS1 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    SPI_PCS2 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    SPI_PCS3 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    SPI_PCS4 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    SPI_PCS5 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">&#125; SPI_PCSn_e;</span><br></pre></td></tr></table></figure></p><h1 id="KV5x-Sub-Family-Reference-Manual"><a href="#KV5x-Sub-Family-Reference-Manual" class="headerlink" title="KV5x Sub-Family Reference Manual"></a>KV5x Sub-Family Reference Manual</h1><p><a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf" target="_blank" rel="noopener">https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf</a></p><h1 id="KV5x-Data-Sheet"><a href="#KV5x-Data-Sheet" class="headerlink" title="KV5x Data Sheet"></a>KV5x Data Sheet</h1><p><a href="https://www.nxp.com/docs/en/data-sheet/KV5XP144M240.pdf" target="_blank" rel="noopener">https://www.nxp.com/docs/en/data-sheet/KV5XP144M240.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ARM寄存器食用感受&quot;&gt;&lt;a href=&quot;#ARM寄存器食用感受&quot; class=&quot;headerlink&quot; title=&quot;ARM寄存器食用感受&quot;&gt;&lt;/a&gt;ARM寄存器食用感受&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近研究NXP新推出的&lt;strong&gt;kineti
      
    
    </summary>
    
    
      <category term="ARM" scheme="http://blog.zzshub.cn/tags/ARM/"/>
    
      <category term="kinetis" scheme="http://blog.zzshub.cn/tags/kinetis/"/>
    
      <category term="register" scheme="http://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙接收端帮助文档</title>
    <link href="http://blog.zzshub.cn/2017/11/28/%E6%96%B0%E7%94%9F%E6%9D%AF%E6%99%BA%E8%83%BD%E8%BD%A6%E8%B5%9B%E8%93%9D%E7%89%99%E6%8E%A5%E6%94%B6%E7%AB%AF/"/>
    <id>http://blog.zzshub.cn/2017/11/28/新生杯智能车赛蓝牙接收端/</id>
    <published>2017-11-28T15:48:00.000Z</published>
    <updated>2018-03-26T15:45:37.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新生杯智能车大赛蓝牙接收端帮助文档"><a href="#新生杯智能车大赛蓝牙接收端帮助文档" class="headerlink" title="新生杯智能车大赛蓝牙接收端帮助文档"></a>新生杯智能车大赛蓝牙接收端帮助文档</h1><hr><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p>这个蓝牙接收端于蓝牙上位机配套使用,使用当蓝牙上位机发出指令后,接收程序能够分析上位机发送的信号,并且执行相关的函数</p></blockquote><h1 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h1><p>串口接收数据-&gt;将数据加入数据缓冲区-&gt;在while中一直判断缓冲区中的数据-&gt;如果有相关的指令-&gt;执行相关数据处理函数</p><h1 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h1><p>使用蓝牙接收端程序需要手动在工程中添加<code>SerialPortImformation.c</code> 和 <code>SerialPortImformation.h</code> 之后再<code>include &quot;SerialPortImformation.h&quot;</code><br>另外,因为需要使用串口,所以也需要添加串口USART相关的头文件</p><h1 id="关于-SerialPortImformation-h"><a href="#关于-SerialPortImformation-h" class="headerlink" title="关于 SerialPortImformation.h"></a>关于 SerialPortImformation.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> GoSpeed;</span><br><span class="line"><span class="keyword">int</span> GoSpeedOld;</span><br><span class="line"><span class="keyword">int</span> TurnSpeed;</span><br><span class="line"><span class="keyword">int</span> TurnSpeedOld;</span><br><span class="line"><span class="keyword">uint8_t</span> OtherInfo;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> serialPortQueueBuffer[BUFFERSIZE+<span class="number">5</span>];</span><br><span class="line">&#125; serialPortInfo;</span><br></pre></td></tr></table></figure><p>这个结构体用于判断上位机发送过来的数据,serialPortQueueBuffer是一个用来暂时储存发来的数据的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFERSIZE 20</span></span><br></pre></td></tr></table></figure><p>这个用来调节数据缓冲区的大小,一般不需要修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSerialPortDate</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> data,serialPortInfo *<span class="keyword">this</span>)</span></span></span><br></pre></td></tr></table></figure><p>将数据添加进缓冲区,第一个参数是需要添加的数据,第二个参数是需要添加到的结构体的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serialPortexec(serialPortInfo *serialPortInfo)</span><br></pre></td></tr></table></figure><p>这个是判断信息的函数,参数是serialPortInfo结构体的地址</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>任何外设使用以前都需要初始化,串口也一样.所以使用之前一定要初始化串口,串口如何初始化我就不再赘述了,不熟悉的同学可以查看我们之前的例程和教程.或者看我新写的这个例程也可以.<br>另一部分就是这个判断串口指令的初始化,这个由于不是外设,只需要创建一个全局变量就好了</p><p><code>serialPortInfo blueToothInfo;</code></p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>以前已经讲过,串口接收到数据之后就会进入串口中断函数.我们这时只需要将串口接收到的数据传输给蓝牙判断的结构体中就好了,以下是串口中断的部分代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">uint8_t</span> ucTemp;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USARTx,USART_IT_RXNE)!=RESET)</span><br><span class="line">&#123;</span><br><span class="line">ucTemp = USART_ReceiveData(USARTx);</span><br><span class="line">addSerialPortDate(ucTemp,&amp;blueToothInfo);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这一句<code>addSerialPortDate(ucTemp,&amp;blueToothInfo);</code>就是将接收到的数据传输给蓝牙结构体的</p><p>使用的另一个部分就是判断接收到的数据,这个只需要使用<code>serialPortexec(serialPortInfo *serialPortInfo);</code>函数即可.由于需要一直判断,所以需要在while里面一直执行这个函数,以下是部分代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">serialPortexec(&amp;blueToothInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个部分就是执行操作了,因为大家对上位机上不同的按键执行的操作不同,所以就需要大家自己编写函数了.比如想让功能键1被按下时执行的任务,那么只需要写一个函数名为<code>void function1ButtonClickedEvent()</code>,那么当功能键一被按下时就会执行这个函数里面的内容.同理,当上位机上面速度设定发生改变的时候就会执行<code>speedchangeEvent(int xSpeed,int ySpeed)</code>这个函数里面的内容.以下是一些函数</p><table><thead><tr><th>事件</th><th>执行的函数</th><th>备注</th></tr></thead><tbody><tr><td>功能键1被按下</td><td>function1ButtonClickedEvent(void)</td><td></td></tr><tr><td>功能键2被按下</td><td>function2ButtonClickedEvent(void)</td><td></td></tr><tr><td>功能键3被按下</td><td>function3ButtonClickedEvent(void)</td><td></td></tr><tr><td>功能键4被按下</td><td>function4ButtonClickedEvent(void)</td><td></td></tr><tr><td>停车键被按下</td><td>stopButtonClickedEvent(void)</td><td></td></tr><tr><td>设定速度发生改变</td><td>speedchangeEvent(int xSpeed,int ySpeed)</td><td>传进来的参数xSpeed和ySpeed就是改变之后的速度</td></tr></tbody></table><p>有兴趣想知道这个是怎么实现的可以看我的另一篇文章<a href="/2017/11/28/ARMweak/index.html">ARMWeak指令</a></p><h1 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h1><ul><li>例程144行的函数<code>int fputc(int ch, FILE *f)</code>不要删去,否则printf函数将无法使用</li><li>关于”执行的函数”如果不写的话也没有关系,就会执行我默认的函数,不过这样就无法实现你们想要的功能了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;新生杯智能车大赛蓝牙接收端帮助文档&quot;&gt;&lt;a href=&quot;#新生杯智能车大赛蓝牙接收端帮助文档&quot; class=&quot;headerlink&quot; title=&quot;新生杯智能车大赛蓝牙接收端帮助文档&quot;&gt;&lt;/a&gt;新生杯智能车大赛蓝牙接收端帮助文档&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="ARM" scheme="http://blog.zzshub.cn/tags/ARM/"/>
    
      <category term="718创新实验室" scheme="http://blog.zzshub.cn/tags/718%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
      <category term="STM32" scheme="http://blog.zzshub.cn/tags/STM32/"/>
    
      <category term="蓝牙" scheme="http://blog.zzshub.cn/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>ARM weak指令巧用</title>
    <link href="http://blog.zzshub.cn/2017/11/28/ARMweak/"/>
    <id>http://blog.zzshub.cn/2017/11/28/ARMweak/</id>
    <published>2017-11-28T15:38:00.000Z</published>
    <updated>2018-03-26T15:45:37.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用weak指令实现只声明不定义函数直接调用不出错"><a href="#利用weak指令实现只声明不定义函数直接调用不出错" class="headerlink" title="利用weak指令实现只声明不定义函数直接调用不出错"></a>利用weak指令实现只声明不定义函数直接调用不出错</h1><blockquote><p>近来为新生编写一个蓝牙助手的下位机,采用了类似于面向事件的编程方法吧,蓝牙消息来了就会触发事件函数,把那些复杂的判断都封装起来了,也是方便使用吧.<br>但是有一个问题,事件函数是他们自己写,自己定义,我只是预先声明了,也调用了,但是没有定义.这样很明显是编译过不了的,而C语言又没有类似于C++虚函数一样的东西.利用ARM有的编译指令weak可以实现这个功能.</p></blockquote><p>我的想法是如果使用者没有自己写事件函数,那么就执行我的报错函数,用串口输出报错信息,如果他们写了事件函数,那么就执行他们的事件函数.</p><p>而weak指令的定义为: <strong>__weak函数用于定义变量或者函数，常见于定义函数，在MDK ARM链接时优先链接定义为非weak的函数或变量，如果找不到则再链接weak函数。</strong> 正好符合我的要求.</p><p>以下是代码: </p><p>这是报错函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">function1ButtonClickedEvent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"function1ButtonClicked\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"if you see this, it means you DO NOT add your own function\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"for more information,please look at http:///zzshub.cn//\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是用户需要写的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1ButtonClickedEvent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是函数的调用(部分)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">'1'</span>)</span><br><span class="line">&#123;</span><br><span class="line">function1ButtonClickedEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">'2'</span>)</span><br><span class="line">&#123;</span><br><span class="line">function2ButtonClickedEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">'3'</span>)</span><br><span class="line">&#123;</span><br><span class="line">function3ButtonClickedEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">'4'</span>)</span><br><span class="line">&#123;</span><br><span class="line">function4ButtonClickedEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">'S'</span>)</span><br><span class="line">&#123;</span><br><span class="line">stopButtonClickedEvent();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><hr><p>EOF</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用weak指令实现只声明不定义函数直接调用不出错&quot;&gt;&lt;a href=&quot;#利用weak指令实现只声明不定义函数直接调用不出错&quot; class=&quot;headerlink&quot; title=&quot;利用weak指令实现只声明不定义函数直接调用不出错&quot;&gt;&lt;/a&gt;利用weak指令实现只
      
    
    </summary>
    
    
      <category term="ARM" scheme="http://blog.zzshub.cn/tags/ARM/"/>
    
      <category term="STM32" scheme="http://blog.zzshub.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>openwrt简单玩一玩</title>
    <link href="http://blog.zzshub.cn/2017/11/28/openwrt/"/>
    <id>http://blog.zzshub.cn/2017/11/28/openwrt/</id>
    <published>2017-11-28T05:31:50.000Z</published>
    <updated>2018-03-26T15:45:37.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>紧接着上一次试玩hiwifiOS系统,最后发现实在是不过瘾,限制太多,尤其是软件安装方面的限制,然后资料又少,受不了了,就还是刷成了正宗的OpenWrt系统.</p></blockquote><h1 id="OpenWrt版本简介"><a href="#OpenWrt版本简介" class="headerlink" title="OpenWrt版本简介"></a>OpenWrt版本简介</h1><p>刷OpenWrt之前先简单说明一下OpenWrt的版本问题吧.<strong>OpenWrt</strong>到目前为止已经有了很多个版本,目前最新的是<strong>15.05 Chaos Calmer</strong> 版本,也就是很多人口中说的CC版.另外,常见的还有<strong>Barrier Breaker 14.07</strong>也就是BB版,还有更古老一点的<strong>Attitude Adjustment 12.09</strong>也就是AA版,这些就是系统版本的区别,就跟windows7和Windows8这样的区别类似.另外,OpenWrt作为嵌入式操作系统,支持众多处理器,不同处理器架构也有不同版本.而为了在安装的时候就把常见的驱动安装进去,每个安装包都附带了驱动,所以导致不同的处理器有不同的版本.比如我这个就是使用的mt7620处理器的15.05 CC版本.而之前的hiwifiOS则是使用mt7620处理器的14.04BB版上修改而成的.<br>除此之外,还有很多论坛上常说的<strong>openwrt PandoraBox</strong>就是一个有人做出来的为中国用户优化过的版本,没用过那个,就不多说了.</p><blockquote><p>关于hiwifi如何刷OpenWrt,这个网上资料已经很多了,就不多说了,可以看看这个资料 <a href="http://www.jianshu.com/p/196a43b79c24" target="_blank" rel="noopener">http://www.jianshu.com/p/196a43b79c24</a></p></blockquote><h1 id="OpenWrt从外部设备启动"><a href="#OpenWrt从外部设备启动" class="headerlink" title="OpenWrt从外部设备启动"></a>OpenWrt从外部设备启动</h1><blockquote><p>主要参考这篇博客 <a href="https://www.cnblogs.com/double-win/p/3841801.html" target="_blank" rel="noopener">https://www.cnblogs.com/double-win/p/3841801.html</a></p></blockquote><p>整个前面的操作和博客里面讲的一样,不过由于我这个版本里面已经集成了那些驱动,就没有再下载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/root        　　　　　　 #在/tmp目录下创建一个临时目录，用于放置系统镜像</span><br><span class="line">mount /dev/sda1 /mnt　　　　　　　　#将/dev/sda1 挂载到/mnt目录下</span><br><span class="line">mount -o bind / /tmp/root　　　　　#将根目录&quot;/&quot;制作镜像，并将其挂载到“/tmp/root”下</span><br><span class="line">cp /tmp/root/* /mnt -a　　　　　　　#将/tmp/root/ 目录下的所有内容复制到/mnt下，相当于将/mnt/root下的所有内容复制到/dev/sda1下</span><br><span class="line">umount /tmp/root    　　　　　　　　#解除挂载 /tmp/root</span><br></pre></td></tr></table></figure></p><p>到这一步开始就和博客上面说的不一样了.按照博客的说法,始终无法启动,或者好不容易勉强启动起来了,就到处出问题,网络驱动工作不正常等等.<br><br>之后仔细研究了一下,发现按照之前的做法,我是直接将sd卡设置成为openwrt的根目录点,其实这样是错误的.OpenWrt采用了一种叫做<strong>Overlay</strong>透明挂载的技术.大概意思就是先把磁盘中的一个恢复分区挂载到根目录下,然后使用透明挂载技术将我们认为的根目录挂载到根目录的位置,再将之前的恢复分区挂载到/rom目录下,这样就是overlay透明挂载.这样做有很大的好处,按下出厂设置键之后就直接删掉当前的根目录,就会露出恢复分区的目录,这样就可以很容易的实现系统出厂设置.而恢复分区是使用的只读文件系统,无法更改,所以出厂设置也一定能够恢复回来.</p><blockquote><p>有关openwrt的挂载可以看看这个 <a href="https://www.leiphone.com/news/201406/diy-a-smart-router-topic-openwrt.html" target="_blank" rel="noopener">https://www.leiphone.com/news/201406/diy-a-smart-router-topic-openwrt.html</a></p></blockquote><p>了解到这个透明挂载技术之后思路就清楚了.之前的挂载少了透明挂载这一层,就出问题了.设置一下就好.好在luci也给我们提供了图形化的设置工具,不需要命令行.接下来看图!</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/%E8%8D%89%E5%9B%BE.png" alt=""></p><p>选择到<strong>系统-&gt;挂载点</strong>这一栏就会看到这样的画面,可以看到此时overlay那一层是14.29GB,大约是sd卡的大小.<strong>这就是设置成功的标志之一</strong></p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/%E8%8D%89%E5%9B%BE2.png" alt=""></p><p>选择下面的添加挂载点,就会进入上面的界面,之后添加sd卡的位置.<strong>然后关键的一步</strong>:<strong>设置挂载点为外部overlay而不是根目录</strong>保存后重启一下路由器.好了,就设置好了.</p><p>其实看上去很简单的一步,自己研究的过程却复杂,不过成功之后也有一点小小的激动.就是这样小激动和漫长钻研过程中不断学习吧</p><h1 id="OpenWrt控制串口"><a href="#OpenWrt控制串口" class="headerlink" title="OpenWrt控制串口"></a>OpenWrt控制串口</h1><blockquote><p>熟悉嵌入式方面的人都知道串口是一个非常重要的设备。所以我也是最先研究这个串口设备，只要串口通信设置好了，那么利用串口和其他微控制器通信，再加上OpenWrt的远程通信的能力，那么就可以做到远程控制一大票东西了。废话不多说，直接开始串口的调试！</p></blockquote><h2 id="焊接串口"><a href="#焊接串口" class="headerlink" title="焊接串口"></a>焊接串口</h2><p>上次的拆机发现hiwifi 1S中是留有串口的焊盘的，只不过没有焊接而已(说实话一直觉得hiwifi挺良心的)。卸下烦人的三角形螺丝，拔出主板，焊接串口线，上电，测试正常，完成！</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/04F747091AEF90654CD185EBF962CB9D.png" alt=""></p><p>可以看到，中间有四个焊接的排针。</p><h2 id="串口配置"><a href="#串口配置" class="headerlink" title="串口配置"></a>串口配置</h2><p>在linux上，一切都是文件，串口等外部设备也是一样的。读和写串口在linux上其实就是读和写一个文件。和读写普通文件唯一有点区别的就是需要配置一下串口的波特率。</p><p>第一步首先安装串口的驱动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opkg update  //更新软件列表</span><br><span class="line">opkg install coreutils-stty //安装stty</span><br></pre></td></tr></table></figure></p><p>安装完成之后设置波特率<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty -F /dev/ttyS0 raw speed 115200  //设置ttyS0串口的波特率为115200</span><br></pre></td></tr></table></figure></p><p>其中，<code>/dev/ttyS0</code>就是串口设备的名字，这个可以在开机的时候查看启动的信息查看到。 <br>其实，这句话也可以不需要，因为串口开机默认是使用115200波特率的。</p><h2 id="串口读写"><a href="#串口读写" class="headerlink" title="串口读写"></a>串口读写</h2><p>其实串口读写非常简单，就是前面所说的文件的读写</p><h4 id="写串口："><a href="#写串口：" class="headerlink" title="写串口："></a>写串口：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello&quot; &gt; /dev/ttyS0  //向串口输出字符&quot;hello&quot;</span><br></pre></td></tr></table></figure><h4 id="读串口："><a href="#读串口：" class="headerlink" title="读串口："></a>读串口：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/ttyS0  //读取串口</span><br></pre></td></tr></table></figure><h2 id="利用C语言程序实现串口读写"><a href="#利用C语言程序实现串口读写" class="headerlink" title="利用C语言程序实现串口读写"></a>利用C语言程序实现串口读写</h2><p>对于读写文件来说，分为几个步骤：</p><ul><li>打开文件</li><li>获取文件编号(感觉类似于文件指针)</li><li>读文件或者写文件</li></ul><p>对于打开文件使用open函数<br><code>int open( const char * pathname, int flags);</code></p><p>读文件使用read函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);  </span><br><span class="line"><span class="comment">//返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0</span></span><br></pre></td></tr></table></figure><p>写文件使用write函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">// 返回：若成功则返回写入的字节数，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:待写入数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要写入的字节数</span></span><br></pre></td></tr></table></figure><h4 id="最后，以下是整个测试程序"><a href="#最后，以下是整个测试程序" class="headerlink" title="最后，以下是整个测试程序"></a>最后，以下是整个测试程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> receivebuff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">int</span> file=open(<span class="string">"/dev/ttyS0"</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(file==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Open Failed"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line">flag=read(file,&amp;receivebuff,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(flag!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">write(file,&amp;receivebuff,flag);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/psb.png" alt=""></p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/psb.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;紧接着上一次试玩hiwifiOS系统,最后发现实在是不过瘾,限制太多,尤其是软件安装方面的限制,然后资料又少,受不了了,就还是刷成了正宗的OpenWrt系统.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;OpenWrt版本简介&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="mips" scheme="http://blog.zzshub.cn/tags/mips/"/>
    
      <category term="Linux" scheme="http://blog.zzshub.cn/tags/Linux/"/>
    
      <category term="OpenWrt" scheme="http://blog.zzshub.cn/tags/OpenWrt/"/>
    
  </entry>
  
  <entry>
    <title>hiwifi的正确打开方式</title>
    <link href="http://blog.zzshub.cn/2017/11/21/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://blog.zzshub.cn/2017/11/21/hiwifi的正确打开方式/</id>
    <published>2017-11-21T15:41:34.000Z</published>
    <updated>2018-03-26T15:45:37.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hiwifi-OS的正确打开方式"><a href="#hiwifi-OS的正确打开方式" class="headerlink" title="hiwifi OS的正确打开方式"></a>hiwifi OS的正确打开方式</h1><hr><blockquote><p>近来频繁需要下载大文件,可是无奈,校园网速度感人.想着能不能把我的路由器改造成一个下载器来下载呢.于是,就开始了我的折腾之路<br>其实这个路由器高中就买了,当时作为家里的主力路由器,一直想折腾,不过也常常搞得网络不稳定,被家里人”投诉”了几次之后,也没有继续研究了.直到后来换了100M宽带,这个只有802.11n协议的路由器带不动了,退休下来,我才有机会仔细的研究一下</p></blockquote><h1 id="hiwifi是什么"><a href="#hiwifi是什么" class="headerlink" title="hiwifi是什么"></a>hiwifi是什么</h1><p>以下是<a href="https://baike.baidu.com/item/HiWiFi/8633008?fr=aladdin" target="_blank" rel="noopener">百度百科</a>的介绍:</p><blockquote><p>HiWiFi是北京极科极客科技有限公司推出的一款基于国外开源代码OpenWrt的无线路由系列，全称是“极路由 HiWiFi”，简称“小极”“HiWiFi”。</p></blockquote><p>我手上的这块是hiWiFi 1S-HC5661,极路由官方的第二款产品.采用联发科的MT7620A处理器,这个处理器基于mips架构,560MHz主频,不过正是因为是mips架构的原因,应用程序非常少,交叉编译环境搭建也没那么顺利(相比Qt安卓的交叉编译环境还是要好弄很多).128M的ddr2内存,16M闪存,外置16GB SD卡.<br>软件方面,我目前使用的hiWiFi OS系统,不过看情况吧,可能以后还是要刷成原版OpenWrt.hiWiFi系统是一个基于OpenWrt深度定制而成的系统,而OpenWrt又是一个非常常见的嵌入式Linux系统,类似于小米的MiUI和安卓原生系统以及Linux之间的关系.</p><h1 id="硬件-USB-hiWiFi-1s拆机"><a href="#硬件-USB-hiWiFi-1s拆机" class="headerlink" title="硬件+=USB  hiWiFi 1s拆机"></a>硬件+=USB  hiWiFi 1s拆机</h1><p>不得不说,hiwifi 1s的外观设计的真是好看,全金属机身,阳极氧化工艺外壳.暗黑色的喷漆外壳上银色的化学侵蚀logo,配上亮色的倒切角工艺.与早些年间只是白色塑料外壳的路由器形成鲜明对比,简单的放在桌面上,也是不错的装饰品吧.另外,使用通用的5V2A-MicroUSB接口,也不用担心供电的问题.<br> 不过,这些都不是今天讨论的重点.其实很久以来就想拆开这个小家伙一探究竟了,只可以一直没有去到专用的三角螺丝刀,这个想法也一直搁置了下来.终于,忍不住了,没有专用螺丝刀,那就大力出奇迹吧.</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/14193441483612.jpg" alt=""></p><p>一直都有所了解,hiwifi 1S是留有USB接口的,只不过没有印出来,拆开之后发现果不其然,只见USB焊盘,不见USB接口.另外,还发现了留有串口接口应该刷机变砖之后可以用这个刷回来,和没有焊接的802.11ac模块焊盘.不得不说,成品的电路板确实比自己设计的要成熟,各种滤波电容保护,还有各种拓展.<br>正题开始,改造USB!</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/0e655ca7d933c8951f7a5601d21373f082020001.jpg" alt=""></p><p>通过观察PCB板上面的走线可以发现,USB的D+和D-其实是连接上了的,只不过USB的VCC和GND没有连接上,那么把电供上就可以使用了.短接如图红圈位置即可.什么?滤波电容?不存在的.根据我的猜测,红圈左边的6脚芯片应该是电源管理芯片,控制USB的供电,当然我也是不会添加的.哼,就不加,三极管都别想让我加.焊接好USB母口之后就是暴力的过程–在外壳上打一个洞,把USB口露出来.</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/IMG_2096.JPG" alt=""></p><p>无奈手工不行,在机械专业的同学的远程指导下还是搞得这么丑.其实网上还有其他的不打洞,用线引出USB线的方法.有用百兆以太网剩下的4根线的,有用天线的缝隙的等等.不过我深知,线没过几天就会被我扯断,没有采用这个方法.</p><p>好,到这里,硬件改造就完成了,上电!工作正常,U盘挂载正常,连接正常.其实一路上也没有那么顺利,刚焊接好的时候路由器一上电就一直复位,把我吓坏了,以为又双叒叕短路了.重新焊接,无果,后来才发现是供电不足,没有使用5V2A的电源导致的.果断换电源,完成!</p><h1 id="正式进入新世界–root-amp-ssh"><a href="#正式进入新世界–root-amp-ssh" class="headerlink" title="正式进入新世界–root&amp;ssh"></a>正式进入新世界–root&amp;ssh</h1><p>相信了解过Linux或者玩过安卓的人都知道root权限吧.hiWiFi上面获取root权限非常简单,去后台直接获取就好了.不过注意了,保修可就失去了,hiWiFi保修三年还是很良心的啦.<br>获取之后就配置ssh,注意官方给的端口号是1022,不过也有可能就是默认的22,这个时候官方已经默认帮你安装了ssh的server了,直接连接就好.Windows10 1709版本的话可以试试微软最新推出的Ubuntu On Windows(这玩意在后面会仔细讲一下),用这个连接ssh挺方便的,不然的话下载Putty也可以.</p><blockquote><p>在Ubuntu On Windows输入 ssh -p 1022 <a href="mailto:root@192.168.199.1" target="_blank" rel="noopener">root@192.168.199.1</a></p></blockquote><p>输入密码(就是后台管理密码)后出现以下界面就算是权限获取成功而且ssh服务已经打开了</p><p> <img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE.png" alt=""></p><p> 哎,不愧是改的openwrt,连登陆界面都这么像.</p><p> 另外文件传输的话可以使用WinSCP,连接登录就好了,注意文件协议需要选择SCP.当然,也可以安装vsftp,用ftp传输文件也是可以的.</p><p> <img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE2.png" alt=""></p><h1 id="个人网盘-远程下载器"><a href="#个人网盘-远程下载器" class="headerlink" title="个人网盘+远程下载器"></a>个人网盘+远程下载器</h1><p> 说到底,最开始研究这个路由器的初衷就是当个下载器用嘛.在以前,路由器上面有个迅雷的插件,可以利用迅雷的服务下载,无奈,迅雷关闭了这个服务.不过还好,Linux上不是还有个叫wget的命令行下载工具吗,利用它不就好了.直接cd到需要下载的目录下,wget+网址名就好了.不过等等,我的16G的SD卡呢? 执行命令 <code>fdisk -l</code> 读取出SD卡了,只不过没有自动挂载 <code>mount /dev/mmcblk0 /mnt</code>好的这下就把名称为mmcblk0的SD卡挂到根目录下的mnt文件夹上了,下载吧!不过很遗憾,路由器上的wget被阉割过了,支持的下载协议很少.凑合着下载吧,以后再找个好的.<br>不过停一下,我退出了ssh怎么下载就暂停了?再连接上,执行<code>top</code>,果然wget被杀进程了,保持后台下载,怎么办,linux上面有一个叫做<code>nohup</code>的命令,可是路由器上面没有啊.仔细寻找资料,发现只需要在命令的最后面加一个&amp;就好了,非常方便,再次退出,果然下载还在继续.<br><br> 下载之后怎么把东西移动到电脑上呢?一个很直接的办法,把SD卡拆下来插到电脑上就好了,不过放弃吧,文件系统不支持呢.路由器上使用的是ext4文件系统,这种文件无法被windows识别. 在局域网内部,可以采用smb协议传输文件,smb协议是微软推出的一种在局域网内部传输文件的协议,因为是在局域网内部,也不能加密传输.hiWiFi默认也是开启了smb服务的,在此电脑输入smb://192.168.199.1即可.好了,到目前为止,可以在局域网下访问的下载器就做好了.<br><br> 文不对题啊,说好的远程呢?一步一步来,先看看学校的网络大环境,今年学校大修改,增加了1000M出口带宽(鼓掌!)之后,校网由以前的静态IP,客户端认证+MAC地址绑定变成了,动态IP+MAC地址绑定或者802.1x认证,同时无线校园网全校覆盖(衷心的感谢学校网络中心的努力,并同时希望网路中心能尽快修好实验室的网).这样看来,我只需要把路由器的MAC地址注册到我的名下,路由器就可以联网了.路由器设置成无线中继模式,连接到学校的wifi就好了.不过动态ip也带来了问题,我的ip一直在变啊,最开始以为变化的不是很快,然而我想错了,几乎半天就要变一次ip.看来有必要上ddns服务了,ddns服务是什么,首先了解dns服务,就是一个能够把域名解析成ip地址的玩意,那么ddns是什么,ddns可不是ddos,差一个字母,可完全不是一个东西,Dynamic DNS,动态dns,能够解析一直在变动的ip地址,也就是说我开启了ddns,不管IP地址怎么变化,我访问我的域名,总能获取到正确的ip地址.hiWiFi的ddns也是一个插件的事,利用不知道是谁提供的ddns服务(感谢那个不知道名字的陌生人,谢谢),分配给我了一个域名<code>zzscloud.jios.org.</code>什么玩意,这个域名好丑.免费的果然还是不靠谱,我可是由.cn的域名的男人,才不要你这玩意,做CNAME跳转吧.CNAME跳转就是由一个域名跳转到另一个域名的服务.以下是在腾讯云上做CNAME跳转</p><p> <img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE3.png" alt=""></p><p> 好了,ip变化的问题就解决了,以为就可以远程访问了?错,看之前访问的192.x.x.x,这都是路由器的内网ip啊,可是远程只有路由器的公网ip,也就是学校分配的IP地址,这样做个端口映射即可,将学校的ip映射成内网的ip就可访问了.看这里:</p><p> <img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE4.png" alt=""></p><p> 图形就是好,不过到后面就慢慢是命令了</p><p> 涉及到远程连接,不能加密的smb服务就不是那么安全了,换到更安全,更普遍使用的ftp服务势在必行.hiwifi上面安装ftp同样也非常简单,安装vsftpd插件即可.</p><p> 好了,这么一来,远程访问的问题终于弄好了,现在可以全校范围内访问路由器了.同学叫你分享文件,终于有了一种快(装)速(逼)的方式了哈哈.另外,远程ssh连接,远程管理路由器后台,甚至以后的远程挂摄像头,都需要这个作为基础.</p><ul><li><a href="http://hiwifi.zzshub.cn/" target="_blank" rel="noopener">http://hiwifi.zzshub.cn/</a></li><li><a href="ftp://hiwifi.zzshub.cn/" target="_blank" rel="noopener">ftp://hiwifi.zzshub.cn/</a></li></ul><p>这是我的远程连接的地址,我怎么可能会把密码说出来呢.</p><p> 可是出校门了还能访问吗,因为学校分配的ip相对来说也是内网ip.实现全球能访问两个办法.1.让学校给我做端口映射,不可能.2.那就只好我自己做内网穿透咯.不过目前还没这方面的需要,以前做过效果也不是很好,留给以后去折腾吧.</p><h1 id="插件-插件-插件"><a href="#插件-插件-插件" class="headerlink" title="插件,插件,插件!"></a>插件,插件,插件!</h1><p> hiwifi最初主打的功能就是智能路由器,能安装各种插件,比如番茄助手啥的.hiWiFi安装插件的方式可谓是简单的非常,复杂的也有点复杂.最简单的,直接去官方网页版插件市场安装就好了,不过插件数量很少限制也比较多,这部分跳过.<br>另一种安装方式当然就是用包管理器了.</p><blockquote><p><a href="https://openwrt.io/docs/opkg/" target="_blank" rel="noopener">https://openwrt.io/docs/opkg/</a> 这部分主要参考的这篇文档提供的内容</p></blockquote><p> hiwifiOS基于openwrt,而在openwrt上面有一个很好用的包管理器叫<code>opkg</code>类似于Ubuntu上面的<code>apt-get</code></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>opkg install [软件名]</td><td>安装软件</td></tr><tr><td>opkg update</td><td>更新软件源</td></tr><tr><td>opkg list</td><td>查看可以安装的软件</td></tr><tr><td>opkg list-installed</td><td>查看已安装的软件</td></tr><tr><td>opkg remove [软件名]</td><td>卸载软件</td></tr></tbody></table><p> 另外还有<code>opkg -help</code>可以查看命令帮助,帮助写得比较详细了.</p><p> 用ssh连接 <code>ssh -p 1022 root@hiwifi.zzshub.cn</code><br> 然后执行<code>opkg list</code>查看可以安装的软件.不过很遗憾,能够安装的很少.不科学啊,openwrt上软件可是很多的.全都怪hiwifi的软件源把插件都屏蔽掉了,那么我们换个openwrt的源不就好了.<br>查阅资料发现,opkg源文件存放在<code>/etc/opkg.conf</code>中,cd 到这个地方,打开vi编辑器<code>vi opkg.conf</code>如图所示添加几个源就好了</p><p> <img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE45.png" alt=""></p><p> 顺便提一嘴,这个版本的vi真是好用,可以识别方向键和退格键等,不用频繁的进出编辑模式了,舒服.</p><p> 更新软件源<code>opkg update</code>再用<code>opkg list</code>发现可以安装的软件确实变多了好多.那么,慢慢下载这些插件吧.</p><h1 id="自己动手-编写代码–hiwifiOS交叉编译环境的搭建"><a href="#自己动手-编写代码–hiwifiOS交叉编译环境的搭建" class="headerlink" title="自己动手,编写代码–hiwifiOS交叉编译环境的搭建"></a>自己动手,编写代码–hiwifiOS交叉编译环境的搭建</h1><p>根据网上主流的做法,配置OpenWrt需要在Linux环境下进行.不过我想直接在Windows下直接进行这个环境的搭建.当然了,也是借助一些模拟Linux的环境进行搭建.<br>首先介绍一个软件 <code>bash on Ubuntu on Windows</code> 听这个软件名字这么长就知道这个很厉害了吧.这是微软爸爸最新弄出来的软件,正式版只能在最新的Windows 10 1709版本运行.这是一个Ubuntu运行环境,相当于在Windows上面运行了一个Ubuntu命令行版本的虚拟机,不过呢,这个环境底层又是直接调用的Windows系统级API,运行速度会比单纯的虚拟机快上很多,而且文件共享也更方便.</p><h3 id="安装bash-on-windows"><a href="#安装bash-on-windows" class="headerlink" title="安装bash on windows"></a>安装bash on windows</h3><p>安装过程非常简单,在Windows的程序和功能中选择<code>启动或关闭Windows功能</code> 然后勾选<code>Linux子系统</code>,重启之后再去应用商店下载Ubuntu即可.</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE11.png" alt=""></p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE12.png" alt=""></p><blockquote><p>打开PowerShell或者CMD,输入Ubuntu,这个运行环境就搭建完成了.</p></blockquote><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE13.png" alt=""></p><p>之后的操作和在真正的Ubuntu下操作终端就完全一样了,唯一需要注意的是和Windows文件交换的问题.整个Windows的文件都被挂载到 /mnt 文件夹下了,于是可以通过这个 /mnt文件夹方便的实现文件的交换.另外,系统默认使用root账户登录,权限高,在虚拟环境下又不会对Windows产生伤害,美滋滋.</p><h3 id="bash-on-Windows的完善"><a href="#bash-on-Windows的完善" class="headerlink" title="bash on Windows的完善"></a>bash on Windows的完善</h3><p>其实这一部分没什么好说的,一句话总结,操作和Linux下完全一样.<br><br>比如换成国内的软件源 使用命令<code>vi /etc/apt/sources.list</code>保存源的文件,替换成国内的源即可.比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>之后再 <code>apt-get update</code> 更新软件源就好了</p><p>顺便安装一些常用的软件</p><ul><li>apt-get install gcc  安装gcc C语言编译器</li><li>apt-get install g++  安装g++ C++编译器</li></ul><p>其他我就不列举了,重点说一下安装Java.安装java有两种方式,可以使用apt-get安装,这种方式不用自己配置环境变量.另外也可以去Oracle官网下载java的安装包手动配置环境变量进行安装.这里就说第一种安装方式吧.<br></p><ul><li><code>add-apt-repository ppa:webupd8team/java</code> 添加java的源</li><li><code>apt-get update</code> 更新软件源</li><li><code>apt-get install oracle-java9-installer</code> 安装Java安装包</li></ul><p>经过这三步之后,java安装包就会自动安装java了,等一会就好.值得注意的是,我们这里安装的是最新的java9,安装其他版本只需要把9改成其他数字就好了</p><h3 id="安装SDK-交叉编译工具链正式开始搭建"><a href="#安装SDK-交叉编译工具链正式开始搭建" class="headerlink" title="安装SDK,交叉编译工具链正式开始搭建"></a>安装SDK,交叉编译工具链正式开始搭建</h3><blockquote><p>此部分内容主要参考hiWiFi的官方文档 <a href="http://code.hiwifi.com/docs/sdk_usage" target="_blank" rel="noopener">code.hiwifi.com</a></p></blockquote><p>说句实话,OpenWrt工具链的搭建,网上资料真的是少之又少.感觉基本上就只有官方的帮助文档和几篇博文能看.另外,官方的帮助文档我只能用<strong>简洁</strong>二字来形容.只有十几页内容介绍完了编译环境搭建到刷机到全部的api接口……</p><p>根据官方的说法,先下载SDK包,直接说吧 hiwifiOS应该下载这一个<a href="http://sdk.ikcd.net/mtmips-sdk.tar.bz2" target="_blank" rel="noopener">mtmips</a> 使用前面讲的wget命令下载到电脑上就好了.下载完成后解压,<code>tar -xjvf [文件名]</code> 到目前为止,sdk已经下载完成了.其实吧,在Windows上也可以完全用浏览器下载下载下来,然后用图形化的解压缩工具解压缩.</p><p>继续阅读官方SDK 需要安装一些工具库,按照官方说的来就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install subversion git build-essential libncurses5-dev zlib1g-dev gawk unzip gettext libssl-dev intltool openjdk-6-jre-headless optipng</span><br><span class="line"></span><br><span class="line">ln -sf bash /bin/sh</span><br></pre></td></tr></table></figure></p><p>这个时候可能会弹出来说啥java6安装不上啥的.没关系,反正就是jre(java runtime environment)嘛,我们之前不就已经安装了java吗.</p><p>好了,如果没有出错的话,到目前位置,交叉编译环境就已经搭建好了.</p><h1 id="Hi-WiFi-第一个在路由器上运行的程序"><a href="#Hi-WiFi-第一个在路由器上运行的程序" class="headerlink" title="Hi~ WiFi! 第一个在路由器上运行的程序"></a>Hi~ WiFi! 第一个在路由器上运行的程序</h1><h3 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h3><p>上节说到交叉编译环境搭建.来来来,这节就该说说编译程序了.按照hiwifi的说明,有两种编译方法,我们这里使用脚本编译的方法.<br>cd 到sdk的根目录输入<code>./scripts/cross-compile.sh ./</code>启动这个编译脚本,cd到packge目录下你的要编译的文件的文件夹下执行<code>make</code>指令就好了.之后可以执行<code>file [编译出的文件名]</code>查看是不是mips架构的可执行文件,如果是的话那么祝贺,编译成功了!</p><h3 id="编写第一个程序"><a href="#编写第一个程序" class="headerlink" title="编写第一个程序"></a>编写第一个程序</h3><p>等等,漏了什么重要的东西,编译啥啊,啥都还没有呢…….可以在Windows下写好一个c语言程序,再编写一个makefile,再放到sdk的packge文件夹下就好了,比如这样:</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE111.png" alt=""></p><p>makefile的作用就是制定编译的顺序,以下是一个简单的makefile<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main : hello.c</span><br><span class="line">    gcc hello.c -o main</span><br></pre></td></tr></table></figure></p><h3 id="编译遇到的错误"><a href="#编译遇到的错误" class="headerlink" title="编译遇到的错误"></a>编译遇到的错误</h3><p>编写完成之后就执行刚才的操作,那么一切顺利的话就编译完成了.当然,事情也不会有那么顺利,有时候会编译报错,提醒你这没安装那没安装的.比如我第一次配置环境的时候就一直提醒我git没安装,可是我真的安装了的啊,后来发现是中文路径搞的鬼,SDK一定要放到一个全部是英文的路径下面,不然,可能就会像我一样出现一些奇奇怪怪的问题.</p><h3 id="将程序传输到路由器上"><a href="#将程序传输到路由器上" class="headerlink" title="将程序传输到路由器上"></a>将程序传输到路由器上</h3><p>好了,到目前为止就只剩下最后一个操作了,把文件传到路由器上去.用WinSCP传输文件就好了.看图!</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE112.png" alt=""></p><p>左边是电脑上的文件,右边是路由器上的文件,直接拖拽过去就上传成功了.<br><br>接下来,ssh连接路由器,执行.啊?无法执行?哦哦,忘了添加执行权限了,输入命令,添加就好 <code>chmod 777 [文件名]</code> 777就是添加可执行权限的代号<br>.最后执行! 运行正常,完美!上图!</p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE113.png" alt=""></p><p>终于成功了,激动!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hiwifi-OS的正确打开方式&quot;&gt;&lt;a href=&quot;#hiwifi-OS的正确打开方式&quot; class=&quot;headerlink&quot; title=&quot;hiwifi OS的正确打开方式&quot;&gt;&lt;/a&gt;hiwifi OS的正确打开方式&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
    
      <category term="mips" scheme="http://blog.zzshub.cn/tags/mips/"/>
    
      <category term="Linux" scheme="http://blog.zzshub.cn/tags/Linux/"/>
    
      <category term="OpenWrt" scheme="http://blog.zzshub.cn/tags/OpenWrt/"/>
    
  </entry>
  
  <entry>
    <title>uper2018使用说明</title>
    <link href="http://blog.zzshub.cn/2017/11/13/uper2018use/"/>
    <id>http://blog.zzshub.cn/2017/11/13/uper2018use/</id>
    <published>2017-11-13T07:25:06.000Z</published>
    <updated>2018-03-26T15:45:37.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="718蓝牙助手使用说明"><a href="#718蓝牙助手使用说明" class="headerlink" title="718蓝牙助手使用说明"></a>718蓝牙助手使用说明</h1><hr><blockquote><p>这篇文章主要介绍串口通信,用蓝牙实现串口通信,以及蓝牙助手的使用说明.</p></blockquote><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>蓝牙串口基于串口通信,普通串口使用有线传输,而蓝牙串口只是用蓝牙代替了有线,来传输信号而已.单片机发送的串口信号发送到<a href="https://baike.baidu.com/item/%E8%93%9D%E7%89%99%E4%B8%B2%E5%8F%A3/1415870?fr=aladdin" target="_blank" rel="noopener">蓝牙串口模块</a>上,然后蓝牙串口模块经过一些处理,将串口信号转化为蓝牙的传输信号使用蓝牙传输协议发送到手机上,手机上面的蓝牙,再将信号解析出来.虽然中间传输不是使用的串口传输的,但是利用蓝牙串口模块我们发送和接收却是使用的串口通信,所以我们可以忽略中间具体的传输过程.也就是说掌握了串口通信也就基本能够掌握蓝牙串口的使用了.</p><h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><p>直接进入正题,什么是串口通信. 这一段是来自<a href="https://baike.baidu.com/item/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/3775296?fr=aladdin" target="_blank" rel="noopener">百度百科</a>的说明: 串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。<br>同时我们之前提供的<a href="/2017/10/30/STM32培训/">STM32资料</a>中也有关于串口通信的说明<br>参见说明文档中的<em>stm32f10x系列usart模块</em><br><br>这里我们也再简单说明一下什么是串口通信.串口通信听名字就是串起来通信,就是将数据按照一定时间顺序,先后发送出去.与之相对应的当然还有并行通信,就是将一组(比如8bit)数据一次性发送出去.另外,通信当然包括发送和接收,所以串口通信有两条线,一条负责发送信息,我们称之为<strong>TXD</strong>(Transmit Data),另一条负责接收信息,我们称之为<strong>RXD</strong>(Receive Data).我们发送的信号无非就是高电平和低电平(1和0),提到电平,就必须知道是相对于谁的电平,所以串口通信中还需要一根线将传输的两个对象的参考电平保持一致,所以我们需要第三根地线<strong>GND</strong>(Ground).另外如果使用蓝牙串口,那么我们还需要为蓝牙模块提供电能,所以我们还需要电源<strong>VCC</strong>(Volt Current Condenser).<br><br>这样我们就清楚了,一共需要<strong>VCC,GND,TXD,RXD</strong>四根线连接单片机和蓝牙串口模块.<br><br>之后就是单片机串口使用的问题了,建议大家看看我们的例程和帮助文档,上面说明的比较详细.</p><hr><h1 id="HC-05-HC-06蓝牙串口模块的使用"><a href="#HC-05-HC-06蓝牙串口模块的使用" class="headerlink" title="HC-05/HC-06蓝牙串口模块的使用"></a>HC-05/HC-06蓝牙串口模块的使用</h1><blockquote><p>首先给大家推荐一个非常详细的资料,<a href="http://www.arduino.cn/forum.php?mod=viewthread&amp;tid=2961&amp;highlight=%E8%93%9D%E7%89%99" target="_blank" rel="noopener">http://www.arduino.cn/forum.php?mod=viewthread&amp;tid=2961&amp;highlight=%E8%93%9D%E7%89%99</a> </p></blockquote><p>好,我假设你已经看了上面的资料,那么我再补充总结几句:</p><ul><li>蓝牙串口模块分为两种模式: <strong>AT模式</strong>和<strong>传输模式</strong>,AT模式用于设置蓝牙串口,传输模式用于传输数据.</li><li>蓝牙设置和单片机上的串口设置类似,需要设置波特率,停止位,校验位等. <strong>注意:</strong> 因为是用串口和单片机通信,所以波特率等要和单片机上面设置的参数一致.另外,还要设置蓝牙的名称,密码,工作模式等.<strong>注意:</strong> 因为是手机主动连接到蓝牙模块,蓝牙模块是被链接的对象,所以工作模式要设置成从机模式. </li><li>蓝牙进入AT模式可以长按模块上的按键来进入,如果你购买的模块上没有按键,就只能使用资料里面说的用跳线的方式来进入了.</li><li>蓝牙配置注意一定要使用38400的波特率才行,另外,资料里面提供的那个配置蓝牙的工具非常好用,虽然我们提供的718蓝牙助手Windows版也能够配置,但还是建议大家用资料里提供的工具配置,用那个工具配置成功的概率更高.</li></ul><hr><h1 id="蓝牙串口控制原理"><a href="#蓝牙串口控制原理" class="headerlink" title="蓝牙串口控制原理"></a>蓝牙串口控制原理</h1><p>正如大家所熟知的,串口通信其实传输的就是<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2/1017763?fr=aladdin" target="_blank" rel="noopener">字符串</a>,但是我们需要传输给单片机的是控制命令.所以我们需要自己定义一些特殊的字符串,当单片机检测收到这些特定的字符串之后,就会执行相关的操作.就像定义C语言里面的关键字一样.比如在我们的<em>718蓝牙助手</em>当中,我们定义 X30 这个字符串的意思就是小车前进的速度为最大速度的30%,在比如 Y56 这个字符串的意思就是转向速度为56, FSTOP 这个字符串的意思就是紧急停车等等.当然我们蓝牙助手也只是会向单片机发送这么一个字符串而已,这些命令实现的功能也仅仅是我们建议的功能,最后到底怎么执行这些功能,也是需要在单片机上面自己定义的.<br><br>以下是<em>718蓝牙助手</em>能够发送的命令:</p><table><thead><tr><th>按钮</th><th>发送的命令</th><th>备注</th></tr></thead><tbody><tr><td>功能一</td><td>F1</td><td></td></tr><tr><td>功能二</td><td>F2</td><td></td></tr><tr><td>功能三</td><td>F3</td><td></td></tr><tr><td>功能四</td><td>F4</td><td></td></tr><tr><td>紧急停车</td><td>X0Y0FSTOP</td><td>发送X0,Y0和FSTOP</td></tr><tr><td>控制杆</td><td>X[number1]Y[Number2]</td><td>number就是代表直线速度和转向速度</td></tr><tr><td>重力控制</td><td>X[number1]Y[number2]</td><td>number就是代表直线速度和转向速度</td></tr></tbody></table><p><strong>特别说明:X后面的number就是显示出来的前进速度,范围是-99~99,Y后面的number就是显示出来的转向速度,范围是-99~99.</strong></p><hr><h1 id="软件界面简单介绍"><a href="#软件界面简单介绍" class="headerlink" title="软件界面简单介绍"></a>软件界面简单介绍</h1><h3 id="操作界面"><a href="#操作界面" class="headerlink" title="操作界面"></a>操作界面</h3><p><img src="https://s1.ax1x.com/2017/11/17/c5Deg.png" alt="操作界面"></p><ul><li>小方块是一个操作杆(略丑,一定会改进的,捂脸),操作小车前后左右移动</li><li>重力控制(移动版):可以通过前后转动手机控制小车</li><li>自动跟踪(桌面版):鼠标移动到操作杆上,不需要按下按键,就能移动操作杆</li><li>桌面版本可以通过键盘上q w e r 这四个按键控制功能1,2,3,4</li></ul><h3 id="串口连接界面-桌面版"><a href="#串口连接界面-桌面版" class="headerlink" title="串口连接界面(桌面版)"></a>串口连接界面(桌面版)</h3><p><img src="https://s1.ax1x.com/2017/11/17/c50OS.png" alt="连接桌面版"></p><ul><li>扫描端口后设置好波特率和端口好连接就可以了</li><li>支持USB转串口线或者蓝牙连接,使用USB连接时可以到设备管理器中查看具体的端口号,只用蓝牙连接,要首先在系统中配对蓝牙,并且查看蓝牙的端口号</li><li>可以在下面的对话框中发送和接收串口的数据.</li></ul><h3 id="串口连接界面-移动版"><a href="#串口连接界面-移动版" class="headerlink" title="串口连接界面(移动版)"></a>串口连接界面(移动版)</h3><p><img src="https://s1.ax1x.com/2017/11/17/c5wy8.png" alt="连接移动版"></p><ul><li>扫描蓝牙名称后连接即可,不需要配置波特率等</li><li>请确保蓝牙首先已经在系统中配对过了,未配对的蓝牙能搜索到,但是有可能连接不上.</li><li>部分安卓手机可能不支持蓝牙2.0的模块,所以有可能搜索不到HC-05/HC-06蓝牙模块,所以可能需要蓝牙4.0的模块</li><li>部分安卓手机权限审核可能比较严格,一定要给够蓝牙的权限,不然也有可能连接不上.</li><li>可以在下面的对话框中发送和接收串口的数据.</li></ul><hr><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>好吧其实也没有啥好说的了,有问题可以在我们的<strong>718科创交流群</strong>当中讨论,也可以在下面的评论框中评论.我们的App也会在后续不断的更新.</p><!-- UY BEGIN --><p><div id="uyan_frame"></div></p><p><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2147909"></script><br><!-- UY END --></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;718蓝牙助手使用说明&quot;&gt;&lt;a href=&quot;#718蓝牙助手使用说明&quot; class=&quot;headerlink&quot; title=&quot;718蓝牙助手使用说明&quot;&gt;&lt;/a&gt;718蓝牙助手使用说明&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章主要介绍串口通信,用蓝牙
      
    
    </summary>
    
      <category term="作品" scheme="http://blog.zzshub.cn/categories/%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="718创新实验室" scheme="http://blog.zzshub.cn/tags/718%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
      <category term="作品" scheme="http://blog.zzshub.cn/tags/%E4%BD%9C%E5%93%81/"/>
    
      <category term="Qt" scheme="http://blog.zzshub.cn/tags/Qt/"/>
    
      <category term="安卓" scheme="http://blog.zzshub.cn/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>uper2018开发和反馈</title>
    <link href="http://blog.zzshub.cn/2017/11/13/uper2018dev/"/>
    <id>http://blog.zzshub.cn/2017/11/13/uper2018dev/</id>
    <published>2017-11-13T07:24:34.000Z</published>
    <updated>2018-03-26T15:45:37.520Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: diansai2017上位机<br>author:<br> nick: ZZS<br> link: <a href="http://zzzzzzs.github.io/" target="_blank" rel="noopener">http://zzzzzzs.github.io/</a><br>date: 2017-10-29 13:31:50<br>tags: [作品,2017电赛,Qt,安卓]</p><h2 id="cover-http-pic-uuhy-com-uploads-2013-04-07-1-androidstich3-jpg"><a href="#cover-http-pic-uuhy-com-uploads-2013-04-07-1-androidstich3-jpg" class="headerlink" title="cover: http://pic.uuhy.com/uploads/2013/04/07/1_androidstich3.jpg"></a>cover: <a href="http://pic.uuhy.com/uploads/2013/04/07/1_androidstich3.jpg" target="_blank" rel="noopener">http://pic.uuhy.com/uploads/2013/04/07/1_androidstich3.jpg</a></h2><h1 id="暂无稍后完善"><a href="#暂无稍后完善" class="headerlink" title="暂无稍后完善"></a>暂无稍后完善</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: diansai2017上位机&lt;br&gt;author:&lt;br&gt; nick: ZZS&lt;br&gt; link: &lt;a href=&quot;http://zzzzzzs.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://z
      
    
    </summary>
    
    
      <category term="作品" scheme="http://blog.zzshub.cn/tags/%E4%BD%9C%E5%93%81/"/>
    
      <category term="Qt" scheme="http://blog.zzshub.cn/tags/Qt/"/>
    
      <category term="安卓" scheme="http://blog.zzshub.cn/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>2017实验室经历总结</title>
    <link href="http://blog.zzshub.cn/2017/11/03/2016%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%BB%8F%E5%8E%86%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.zzshub.cn/2017/11/03/2016实验室经历总结/</id>
    <published>2017-11-03T15:38:00.000Z</published>
    <updated>2018-03-26T15:45:37.479Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1491163&auto=1&height=66"></iframe><p>正式看之前还是放一个音乐吧,全文6000多字,废话又多,怕你们睡着了</p><hr><h1 id="2017年总结"><a href="#2017年总结" class="headerlink" title="2017年总结"></a>2017年总结</h1><h2 id="周子顺"><a href="#周子顺" class="headerlink" title="周子顺"></a>周子顺</h2><hr><blockquote><p>时间很快，转眼间在718实验室也呆了一年了。在这一年里也经历了很多，也有很多话想对下一年的人说。这个总结我想分为几个方面。首先我想谈一谈我这一年的经历，其次我再想谈一谈刚来实验室的一些感受，然后我想再谈一谈关于参加 NXP 智能车赛和全国大学生电子设计竞赛等其他比赛的一些感想，我还想谈一谈在实验室的日常和实验室之外的一些事情，最后我还想谈一谈实验室的发展。 </p></blockquote><h3 id="一年经历"><a href="#一年经历" class="headerlink" title="一年经历"></a>一年经历</h3><ol start="2"><li>首先说我的经历吧。我从小就对电子技术比较感兴趣，从小就喜欢拆卸研究各种电器，喜欢研究电脑的操作系统等。上大学前就自己修过手机屏幕和主板，制作过简单的红外遥控器，研究过Unity3D 做过游戏，学习过C++(面向过程的C++,相当于 C语言加上一些简单的 STL 算法库)，搞过算法竞赛，也略微自学过 Java，研究过路由器搭建小型服务器等。还记得当时刚入学班助就向我推荐了一个“718 创新交流群“，我怀着试一试的心态加入了这个群，开启了我这大学的科创生活。之后就是参加了实验室的纳新提前批，提前批也就是3道程序题，由于之前的 C++基础，我相对容易的完成了 3 道题,不过也是付出了很多，记得那个国庆假期，我就出去玩了2天，剩下的5天全部在寝室里解题，最晚一次是编程到凌晨两点。进入实验室后就开始学习 51 单片机，一个多星期写了一个电子钟。之后就开始开始准备校园智能车赛，我们采用的是KL26单片机和摄像头循迹方案，效果比单纯的用光电对管循迹效果要好很多，难度也涨了很多，记得当时的情况是一星期勉强入门ARM的单片机，之后结合例程和成品电驱板，花了一个周末的时间勉强让车动了起来。后来的一个多星期主要是在调参数。最后参赛，因为场地光线原因，遗憾没能拿到第一。记得那段时间提到做车就很激动，一点点的看着车从不能跑到能跑，过不了直角弯到稳定过直角弯，从经常时不时断言到后来稳定的运行，做小黄车一路上有激动也有遇到很多困难。经常是晚上接近 11 点了才回寝室，晚自习也是经常上一半就跑出去。小黄车结束后，实验室有了正式的第一批纳新。之后寒假就开始组队制作智能车，我和公续荣，董书航一组，参加的电磁节能组。说实话这是个今年新加入的组别，我们确实遇到了不少坑。我在队伍里面负责是是软件部分，原先的计划我软件,公续荣机械和电路，董书航电源，当然后来也发生了一些变化我后面会提到。二月份寒假，我基本写完了程序的完整框架，还学习了Qt图形编程。三月份时间安排不周，直到三月中旬才把电路板设计出来开始调试，三月份主要就是在调试电路板，调试程序等，之外还进一步学习了Qt，学习了Git代码版本控制工具，也初步了解了一些单片机的底层。四月份工作就很枯燥，就是调车，其实也没怎么调，基本就陷入了一个循环，运放出问题，修运放，之后电感出问题，修电感，然后运放又出问题……基本就是整个系统到处出问题，车基本不能跑，而我们节能组最重要的电源部分还没有开始做。四月份在调车之余用Qt 写了智能车校赛的光电计时系统。进入五月，五月初校赛，车还是跑的很烂，电源还是用的很普通的芯片，没有经过优化。校赛结果非常糟糕，6次发车全部失败。智能车就暂时告一段落，之后参加了校电赛，帆板控制系统，我设计了一个蓝牙控制的上位机，再加上公续荣设计的舵机控制距离，效果非常好，获得一等奖。记忆很深的是电赛最后那天晚上的死亡冲锋，一夜没睡，电赛大部分的东西都是那个周末做出来的，很累，也很有成就感。进入7月，车还是不能跑.7月22号比赛,离比赛还有20天,其他组都上两米了,摄像头都在想办法稳定在 3 米了,我们还不能跑,你们能想象我当时的心里压力吗.说实话那段时间我真的非常想放弃,而且看得出来,我们的一位队员可能已经放弃了.不过在学长的帮助下我们重新设计了电路,直到 7 月 17 号左右我们才开始快速的调车.我和老公(误)(公续荣)实验室连续通宵 5天,5 天没回寝室,等我回去发现人都少了两个.每天吃饭,睡觉,调车,就这三件事情,真的就是非常努力的调车,不过最后还好调到两米多了.记得那段时间印象最深的就是每天晚上两点我都会和老公一起去 3 楼的饮水机那里接开水泡方便面吃,休整一下,然后继续调车.那段时间我过得很累,不过内心却很满足,7 月份我瘦了 10 斤.之后去青岛比赛,比赛成绩并不是很理想,主要也是因为初始的方向选择的就有问题,就是在一条错误的道路上越走越远,所以今年想做节能组的一定要慎重,也一定要和我们多沟通,我们去年掉过的坑希望你们不会再掉进去.之后就是做电赛,没错,电赛就是在暑假,所以暑假想回去的同学我就先给你们说一下你们基本没有暑假了.我去年只回去了5天时间.电赛又是跟老公和刘健建学长在一起的8天8夜,又是8天没回寝室,又是每天晚上去3楼泡方便面……还发生了一件趣事,8天里每次都是刘健建的外卖最先到,之后是我的,最后是老公的,8 天,24 炖饭,每次都这样.然后电赛比赛,初赛很优秀,复赛失利,没能去西安的最终国赛.大概就是这样吧,没想到一年过得这么快,经历了这么多,现在想起来还有点感动吧,感谢那些和我一起奋斗的朋友们!</li></ol><h3 id="关于刚到实验室"><a href="#关于刚到实验室" class="headerlink" title="关于刚到实验室"></a>关于刚到实验室</h3><ol start="3"><li>有关刚来实验室的感受，其实我觉得首先还是要再问自己一次是不是真的喜欢科创，是不是真的愿意为科创付出心血。718实验室和很多其他学校的实验室不一样，平常没有老师或者其他人天天盯着你要求你完成什么任务，一切全靠兴趣和自觉，加入实验室也很累，有可能你要牺牲掉周末，牺牲掉你的睡眠，甚至牺牲掉你的学习时间。所以我觉得既然选择了科创，选择了加入实验室，就要努力为实验室付出。其次，我觉得要学会提问，向你身边的学长或者同学提问题，学长都是在实验室呆过一年的人，有技术上的难题总会有学长能解决，也许就是可能就是一句话，比你自己研究几天都更有效果。同时我也相信，实验室的所有学长学姐都是愿意帮助你们的。 </li></ol><h3 id="关于智能车比赛"><a href="#关于智能车比赛" class="headerlink" title="关于智能车比赛"></a>关于智能车比赛</h3><ol start="4"><li><p>之后我说一说关于做智能车方面的事情吧,做智能车的直观感受就是累,真的累,不管是身体上的累,还有心理上的累.这也是有些学长大二不太愿意做智能车的原因吧,不过我还是希望大一进来的队员都要参加这个比赛.一方面 718 实验室是智能车实验室,做智能车这个事情确实还是需要有人来传承的,从另一个方面来说,做一辆智能车确实很锻炼人的,智能车作为一个实际的工程项目,做一年智能车不仅能学到技术上的知识,更能学到的是处理实际工程问题的方法,做工程和做理论研究很不一样,什么不确定的情况都有可能发生,看看每年比赛有多少队伍翻车了就知道了,其实还能锻炼你的心态,锻炼团队协作能力等等.做智能车也仅仅是后期调参数比较累,前期准备写程序,画电路板等等还是很有意思也能学到很多东西的. 以下是我的一些建议: </p><ul><li>首先是队员一定要选好,真的队员太重要了,跟一个和你合作不好的队员合作,真的还不如没<br>有人合作,这是我今年的教训,希望来年学弟们一定要选择好队员.队员技术都是次要的,最主<br>要的还是看这个人是不是想和你做一样的组别,这个人是不是有十足的科创精神,是不是真心<br>的想做科创,别做到一半队员放弃了. </li><li>队员的任务分工一开始就要做好,最开始就要敲定每个人大概要做什么,别像我们去年那样,<br>一个寒假过去了都以为有人在学画板子,结果到头来根本就没有人画板子,分工不一定要很细<br>致,因为也不可能什么情况都考虑到,但是大体的分工一定要有,谁写程序,谁画板子等等.</li><li>理想<br>的结果是两个人写程序,一个人做硬件,另外如果你们想做节能组的话就两个人做硬件和机械,<br>另一个人做软件. </li><li>队员之间多沟通,尤其是在寒假的时候,一定要经常沟通,你们可以经常内部组织小会,当然我<br>们也会经常性的来督促你们.<br>如果沟通交流好的话,那么任务分工一定是清晰的,时间制定也一定是清晰的.</li><li>说下时间制定,<br>一定尽量把时间向前提,尽早的完成更多的工作.</li><li><strong>寒假非常重要</strong>,学软件的一定要在开学前把<br>大体的框架搭建出来,做硬件的要在开学之前把你们的第一板电路发出去,你们开学后就开始<br>软硬件的组合,最好的情况就是两周之内就能让车跑起来,前期工作做的好的话最坏一个月也<br>能跑起来.</li><li><p>一定要尽早的让车跑起来,跑起来才能发现问题,改进算法,一般都是软件等硬件的,<br>像我去年就是等了一个多月的硬件. </p></li><li><p>我去年是做软件的,就多讲一些软件方面的事情.关于用软件库的问题,不知道你们明年用什<br>么库什么单片机,我们去年用的k60单片机,山外的库,我建议如果有能力就上KV58等更高级<br>一点的单片机然后使用相对更复杂但是更正轨一点的官方库,并且使用 CMSIS 的算法库,这<br>样要求可能有点高,但是对后续学习有极大的帮助,能少走许多弯路.</p></li><li>做软件的别一上来就想<br>着什么高级算法,先就用最普通的PID,最普通的巡线算法,高级算法都是后期的事情,智能车也<br>不是一个非常复杂的系统,你会发现最后还是一些相对简单的算法更有效(相对简单),直到你<br>简单的算法调的差不多了也遇到瓶颈了,可以再加一些更高级的算法.主要也是这么多年了我<br>们实验室也没有能够对智能车建立一个数学模型,多数时候也是靠经验来调. </li><li>关于做车,硬件非常重要,机械更重要,千万不要以为车跑的不好就把锅推到软件身上,错了,硬<br>件决定了这个车的极限速度,软件只是说能不能达到这个极限速度.尤其是想做节能组的同学,<br>出问题基本都是电路和机械的问题,别把什么都往软件上推,就这么说吧,去年我们3到7月把<br>车调到了1m/s的垃圾速度,7月中旬换了电源方案,5天调上2m/s,我甚至有信心调到2.5m/s. </li><li>做车别想着什么都要自己干,学会信任队友,别人干过的东西就不要再去干一遍了,多花时间<br>在研究新的东西上面.</li><li>做车也别太过于拼命了,还是注意下你们的身体,你们的学习成绩等等. </li><li>做软件的一定要学会利用工具,比如我在这里强烈推荐的 Git 分布式代码管理系统,能有效的<br>对代码进行版本控制,版本控制是很重要的,经常是调着调着车就不能跑了,你代码的版本就<br>要回退回去,另外 Git 还可以用来多人协同编程等等.</li><li>学会查找资源,现在互联网上的资源已经<br>是很多的了,没事多去各种技术社区看看,比如 CSDN,不一定要和车有关的技术,什么都可以<br>了解了解吧.</li><li>平时都了解单片机底层的一些知识,了解了解寄存器的操作,不知道怎么操作就<br>可从单片机是如何启动的开始看起,看着是汇编,看着看着就会了.</li><li>想全方面发展的去看看单<br>片机之外的东西,学学电脑上的编程,学学操作系统啥的都是可以的. </li></ul></li></ol><h3 id="关于其他比赛"><a href="#关于其他比赛" class="headerlink" title="关于其他比赛"></a>关于其他比赛</h3><ol start="5"><li><p>关于做车我大概也就想暂时说这么多吧,进入实验室了,大家以后交流的机会还有很多,关于<br>做其他比赛以及比赛场上的相关注意事项,我想通过电赛这个比赛为例简单说一下吧,以下是<br>我以前在知乎上的一个回答: </p><blockquote><p>作者：周子顺<br>链接：<a href="https://www.zhihu.com/question/30453295/answer/216494491" target="_blank" rel="noopener">https://www.zhihu.com/question/30453295/answer/216494491</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>泻药～<br>刚参加完17年电赛，做的B题，板球控制系统，我负责的是软件部分目前省赛初赛结束，<br>我们组得分99分。感觉还行，就看几天之后的复试吧。<br>怎么说呢，全国电赛确实很难，我觉得最大的难点还是要求4天3夜就要做出来。不像NXP<br>智能车赛，电赛就要求前期必须要有很多的积累。<br>比如，熟悉各种外设，摄像头怎么调分辨率，怎么调阈值，蓝牙怎么配置，陀螺仪怎么卡尔<br>曼滤波，OLED怎么刷图，闪烁了怎么办，触摸屏怎么adc采集等等，熟悉参数整定的方法，<br>PID怎么调，什么时候该加入其他控制算法，是机械的问题还是参数的问题等等，知道如何<br>快速的解决问题，比如我们做到最后一天，摄像头突然图像撕裂了，网上也找不到解决方法，<br>就想到可能是中断嵌套了，修改了中断优先级立刻就好了那天晚上如果没有快速的解决问题，<br>那我们也就只能弃赛了，还要有耐得住通宵的身体，我们组在实验室呆了八天（电赛前就在<br>准备）每天睡4.5个小时，连通8天还是有很多人受不了的。<br>再说些其他感受吧。<br>1.人员配置很重要，队员间最好有一定默契，最坏也别有矛盾，队内先分裂了，那只有完蛋。<br>其次控制题机械真的很重要，也难怪有人说这是电子类机械设计大赛。我认为最理想的情况<br>就是有一个会3D打印，会切割，会雕刻，能快速设计出稳定的机械的人。一个一天能写几<br>千行代码，熟悉至少一块单片机和各种外设，能快速 debug 的软件很强的人，还有能一个<br>精通模电数电，能快速搭一个电路出来，熟悉焊接技术的模电强人。这样的话，软件硬件机<br>械都有就很强。<br>2.时间分配很重要，敲定一个题就不能中途换题。我们组的分配是这样的：第一天上午三人<br>共同决定做的题目，设计好大体的思路，下午和晚上负责软件的人搭建完大体的软件框架，<br>另外两个人搭建大体的机械和电路框架，焊接调试了以前设计的一块 PCB 印刷电路板。第<br>二天上午，我在对各种传感器进行调试，另外两人分别在安装传感器和组装机械，前一天3D<br>打印的各种器件也基本打印完毕，他们在安装。下午就基本组装完成了，勉强能开始调试，<br>当然遇到了很多的坑，发现很多不合理的地方，比如摄像头晃动严重，舵机供电不稳，舵机<br>舵盘太长，容易产生虚位，软件还是有一堆 bug，甚至我们还遇到 jlink 掉固件了。经过一<br>夜的努力，第三天上午我们开始调参数了，我和一个队友在调参数，另一个队友在进一步的<br>完善机械，3D打印确实很不错，就是很耗时间，有一个连接件我们打印了15个小时才打印<br>完。调参数也是遇到很多坑，最开始我们想的是用普通的PID控制，效果就还可以了，勉强<br>球不会掉下去，后来我们又尝试了模糊PID，变论域 PID，bangbang控制等等，最后越调<br>越烂，最后还是硬调普通的PID解决了问题。第四天，大概就是在搞附加功能，我们想的是<br>用之前我写的一个蓝牙调试助手来控制球的位置，用触摸屏控制小球位置，用自制遥控器控<br>制小球位置不过最后遥控器调了两个小时确实没调出来就放弃了，搞机械的队友继续搞附加<br>部分的机械，另一个队友继续调参数，我在调试附加功能，结果到晚上又出现之前提到的那<br>个问题，不过还好，最后顺利封箱了。<br>3.赛前的积累和准备很重要，这个积累不仅是个人的知识经验的积累，也是整个参赛实验室<br>整体的积累，这样就算一个人遇到了问题暂时解决不了，但实验室里总有人能解决。一般赛<br>前几天都会有很多猜题的人，可以多去论坛或者多加几个电赛群看看。赛前的前几天，我记<br>得我在调试熟悉各种外设，摄像头，陀螺仪，加速度传感器，OLED，触摸屏等，特别是触<br>摸屏，完全是临时学习的，电阻触摸屏没什么人用了，所以卖的也很少，网购怕来不及，跑<br>遍了半个市才找到几块，网上也只有原理没有现成的程序，我也就只能一边拿示波器了解原<br>理，一边自己写库，一个 xy 轴坐标互相影响导致定位不准的问题卡了我好久，最后发现是<br>一个gpio的电平配置出了问题。另外一个队友设计了一块PCB印刷电路板，发加急在赛前<br>发回来了。电赛前一个星期基本上实验室就是24小时有人的状态了。<br>4.比赛前运输设备和现场调试很重要，今年这个板球系统尺寸都很大，很多队伍都选择拆了<br>到现场组装，其实非常不好，很多都出问题了，比赛前螺丝掉了的，舵机舵盘被撞烂了的，<br>摄像头歪了的，舵机中值变了的….很多问题，我们也是那天比赛下暴雨，板子被雨淋了，有<br>点变形再加上之前标定的失误，最后那个绕圈的功能失败，不幸扣了一分。现场调试千万心<br>态别炸，遇到再严重的问题心态都别炸。赛前做好重要元件的备份，比如单片机，摄像头排<br>线等，想好可能遇到的问题，我应该怎么做。遇到答辩老师别紧张，一般他们不会故意为难<br>你的。 </p></blockquote><p>以上就是我知乎上的回答. </p></li></ol><h3 id="大一之后"><a href="#大一之后" class="headerlink" title="大一之后"></a>大一之后</h3><ol start="6"><li>说了这么多,最后再谈一谈实验室的发展和个人的发展吧.大二上也是个技术积累的关键<br>时期,大二上没有比赛,能更多的做自己想做的事情,也是拉开差距的时候,怎样让自己更有效<br>的学到东西?同时没有比赛,实验室成员之间的交流变少后怎样把大家团结在一起?众所周知,<br>实验室今年变化很大,尤其是纳新方面,怎么样才能在联合纳新的情况下收到更好的人?没有<br>提前批了怎么样才能吸引到技术很强的人?怎么样处理好和其他实验室的关系还有和科创中<br>心的关系?这些都是问题,不仅你们要面对,我们也要面对.到你们这一届实验室有可能要搬迁<br>了,会有更大的地盘,怎么利用好这些地盘,需不需要扩大实验室的规模,扩大以后人员在质量<br>会不会下降?随着时间的发展,智能车比赛也开始走下坡路了,如果有那么一天,智能车真的不<br>行了,我们实验室有应该如何转型?等等一系列问题都需要我们去思考. </li></ol><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><ol start="7"><li>说了这么多,也感谢你们有耐心听我这么啰嗦的说这么多吧,说了这么多,最后怎么做还<br>是看你们个人了.实验室是你们的,也是我们的,但最终是你们的.努力学习和生活吧,比较美好<br>的大学时光也是如此的短暂,我也希望你们日后回忆大学生活,有一个叫718的实验室,有一群<br>热爱科创的人令你们留念.</li></ol><h3 id="这是一个不那么正经的评论框"><a href="#这是一个不那么正经的评论框" class="headerlink" title="这是一个不那么正经的评论框"></a>这是一个不那么正经的评论框</h3><!-- UY BEGIN --><p><div id="uyan_frame"></div></p><p><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2147909"></script><br><!-- UY END --></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="718创新实验室" scheme="http://blog.zzshub.cn/tags/718%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
      <category term="个人总结" scheme="http://blog.zzshub.cn/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>STM32培训</title>
    <link href="http://blog.zzshub.cn/2017/10/30/STM32%E5%9F%B9%E8%AE%AD/"/>
    <id>http://blog.zzshub.cn/2017/10/30/STM32培训/</id>
    <published>2017-10-30T15:41:34.000Z</published>
    <updated>2018-03-26T15:45:37.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STM32从入门到精通"><a href="#STM32从入门到精通" class="headerlink" title="STM32从入门到精通"></a>STM32从入门到精通</h1><blockquote><p>Hi~ 哈工大威海718联创培训营的小伙伴们你们好,这是我们进行<strong>stm32</strong>单片机培训的相关资料,包括完整的<strong>示例程序,帮助文档,课件,</strong> 以及单片机的 <strong>硬件资料,原理图</strong> 等等.我们还将在大家学习的过程中不断地更新资料.</p></blockquote><h1 id="版本更新说明"><a href="#版本更新说明" class="headerlink" title="版本更新说明"></a>版本更新说明</h1><hr><ul><li>2017年10月15日 更新例程下载选项,以后无需手动选择下载器为STLink</li><li>2017年10月21日 修正了一个可能导致编译失败的问题,出现”core_cm3.o No such file”的小伙伴们可以更新试试</li><li>2017年10月22日 修正了SYSTICK定时器延时不正确的问题</li></ul><h1 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h1><hr><ul><li>下载地址:<a href="https://codeload.github.com/ZzzzzzS/STM32Learing/zip/master" target="_blank" rel="noopener"><strong>https://codeload.github.com/ZzzzzzS/STM32Learing/zip/master</strong></a></li><li>备用下载地址:<a href="https://github.com/ZzzzzzS/STM32Learing" target="_blank" rel="noopener"><strong>https://github.com/ZzzzzzS/STM32Learing</strong></a><blockquote><p>一般来说直接下载即可,若下载失败可点击备用下载地址,手动选择下载zip包,如图所示  <img src="https://s1.ax1x.com/2017/11/17/c5Iw4.png" alt="下载失败"></p></blockquote></li></ul><h1 id="资料说明"><a href="#资料说明" class="headerlink" title="资料说明"></a>资料说明</h1><hr><table><thead><tr><th>文件夹名</th><th>说明</th></tr></thead><tbody><tr><td>原理图</td><td>硬件资料,说明电路连接情况</td></tr><tr><td>例程</td><td>各个外设示例程序</td></tr><tr><td>课程资料</td><td>上课ppt等资料</td></tr><tr><td>开始前的准备</td><td>软件安装等资料</td></tr><tr><td>帮助文档</td><td>由718创新实验室编写的例程和外设说明</td></tr><tr><td>ST官方资料</td><td>由ST意法半导体提供的相关说明</td></tr></tbody></table><blockquote><p>其他文件与stm32学习无关,有兴趣可自行研究</p></blockquote><h1 id="stm32开发板简介"><a href="#stm32开发板简介" class="headerlink" title="stm32开发板简介"></a>stm32开发板简介</h1><hr><p> <img src="https://s1.ax1x.com/2017/11/17/c5hOU.png" alt="单片机图片"></p><p>由718创新实验室设计制作的<strong>stm32f103vet6</strong>开发板采用ST意法半导体生产的基于ARM cortex-M3内核的 stm32f103vet6作为主控芯片,另外附加有陀螺仪,加速度传感器,键盘,数码管等多种常用外设.</p><h3 id="以下是外设列表"><a href="#以下是外设列表" class="headerlink" title="以下是外设列表"></a>以下是外设列表</h3><table><thead><tr><th>名称&amp;型号</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>stm32f103vet6</td><td>主控芯片</td></tr><tr><td>温度传感器</td><td>较精确采集温度</td><td>集成在mpu6050内部</td></tr><tr><td>加速度传感器</td><td>感应加速度</td><td>集成在mpu6050内部</td></tr><tr><td>陀螺仪</td><td>感应旋转角速度</td><td>集成在mpu6050内部</td></tr><tr><td>单色LED灯</td><td></td><td>6个</td></tr><tr><td>全彩LED灯</td><td></td><td>1个</td></tr><tr><td>光电数码管</td><td>可以显示数字或其他信息</td><td>最多支持八位显示</td></tr><tr><td>蜂鸣器</td><td>产生声音信号</td><td></td></tr><tr><td>光敏电阻</td><td>感应光照强度</td><td></td></tr><tr><td>热敏电阻</td><td>粗略感知环境温度</td><td></td></tr><tr><td>独立按键</td><td>普通按钮</td><td>2个</td></tr><tr><td>矩阵键盘</td><td>利用特殊的编码方式实现的普通按钮</td><td>共16个按键</td></tr><tr><td>RTC晶振</td><td>可用于制作电子钟</td></tr></tbody></table><h1 id="例程说明"><a href="#例程说明" class="headerlink" title="例程说明"></a>例程说明</h1><hr><blockquote><p>这是建议的例程研究顺序</p></blockquote><ul><li>空白工程:方便大家建立工程使用</li><li>点亮一个小灯</li><li>闪烁一个小灯</li><li><a href="http://v.youku.com/v_show/id_XNDQxNTIxMzI=.html" target="_blank" rel="noopener">流水灯闪烁</a></li><li>独立按键操作</li><li>矩阵键盘操作</li><li><a href="https://baike.baidu.com/item/%E6%95%B0%E7%A0%81%E7%AE%A1/9903965?fr=aladdin" target="_blank" rel="noopener">数码管</a>显示(静态)</li><li><a href="https://baike.baidu.com/item/%E6%95%B0%E7%A0%81%E7%AE%A1/9903965?fr=aladdin" target="_blank" rel="noopener">数码管</a>显示(动态)</li><li>TIM定时器中断</li><li>TIM定时器<a href="https://baike.baidu.com/item/PWM%E4%BF%A1%E5%8F%B7/10621898?fr=aladdin" target="_blank" rel="noopener">PWM</a>波</li><li>TIM定时器脉冲计数</li><li>USART<a href="http://blog.csdn.net/huwei2003/article/details/36418471" target="_blank" rel="noopener">串口</a>发送接收(查询)</li><li>USART<a href="http://blog.csdn.net/huwei2003/article/details/36418471" target="_blank" rel="noopener">串口</a>发送接收(中断)</li><li>I2C<a href="https://baike.baidu.com/item/%E9%99%80%E8%9E%BA%E4%BB%AA/84317?fr=aladdin" target="_blank" rel="noopener">陀螺仪</a>读写(模拟)</li><li>SPI <a href="https://baike.baidu.com/item/OLED/1328114?fr=aladdin" target="_blank" rel="noopener">OLED</a>显示</li><li><a href="https://baike.baidu.com/item/ADC/6529867" target="_blank" rel="noopener">ADC</a>模拟量转数字量采集</li><li><a href="http://www.eepw.com.cn/article/273706.htm" target="_blank" rel="noopener">RTC</a>实时时钟计时</li></ul><hr><h4 id="POWERED-BY-718-INNOVATION-LAB"><a href="#POWERED-BY-718-INNOVATION-LAB" class="headerlink" title="POWERED BY 718 INNOVATION LAB"></a>POWERED BY <strong>718</strong> INNOVATION LAB</h4><p><img src="https://s1.ax1x.com/2017/11/17/c55mF.png" alt="logo"></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STM32从入门到精通&quot;&gt;&lt;a href=&quot;#STM32从入门到精通&quot; class=&quot;headerlink&quot; title=&quot;STM32从入门到精通&quot;&gt;&lt;/a&gt;STM32从入门到精通&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Hi~ 哈工大威海718联创培训营的小伙伴
      
    
    </summary>
    
    
      <category term="ARM" scheme="http://blog.zzshub.cn/tags/ARM/"/>
    
      <category term="718创新实验室" scheme="http://blog.zzshub.cn/tags/718%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
      <category term="STM32" scheme="http://blog.zzshub.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>diansai2017上位机</title>
    <link href="http://blog.zzshub.cn/2017/10/29/diansai2017%E4%B8%8A%E4%BD%8D%E6%9C%BA/"/>
    <id>http://blog.zzshub.cn/2017/10/29/diansai2017上位机/</id>
    <published>2017-10-29T05:31:50.000Z</published>
    <updated>2018-03-26T15:45:37.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电赛上位机"><a href="#电赛上位机" class="headerlink" title="电赛上位机"></a>电赛上位机</h1><h2 id="2017全国大学生电子设计竞赛板球控制系统上位机"><a href="#2017全国大学生电子设计竞赛板球控制系统上位机" class="headerlink" title="2017全国大学生电子设计竞赛板球控制系统上位机"></a>2017全国大学生电子设计竞赛板球控制系统上位机</h2><hr><blockquote><p>这是一个安卓版的蓝牙上位机,使用Qt on Android开发,原计划进入全国电赛总决赛时使用,可惜实力不够,没能进入全国总决赛.之后此上位机继续开发,供相关科技创新展示时控制板球系统使用.</p></blockquote><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/ZzzzzzS/diansai2017Uper" target="_blank" rel="noopener">https://github.com/ZzzzzzS/diansai2017Uper</a></p><h1 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h1><ul><li>蓝牙SPP协议连接HC-05等蓝牙串口模块</li><li>蓝牙串口调试接收数据</li><li>按键控制板球上球的移动</li><li>手势控制球移动</li></ul><p><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1fkyep92vhcj30u01hc0yc.jpg" alt="调试界面"><br>调试界面<br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fkyepbkoosj30u01hc7bx.jpg" alt="手势控制"><br>手势控制<br><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fkyepb2gqwj30u01hcdlc.jpg" alt="按键控制"></p><h1 id="开发经历"><a href="#开发经历" class="headerlink" title="开发经历"></a>开发经历</h1><ol><li>利用上位机控制板球这个想法是在做电赛的初期就有了,在板球的控制程序里面一直保留有串口控制的相关代码,在最初的省电赛时我们组就展示了蓝牙控制板球,不过那时采用的是网上找的上位机控制软件.省赛结束就开始用Qt安卓开发上位机,准备在国电赛的时候能够使用自己开发的上位机.<br>2.开发过程中遇到的第一个难点是串口数据的读取.原本认为安卓蓝牙和Windows平台上的一样,蓝牙连接后就会自动生成一个虚拟串口,使用QSerialport类即可读取.后来发现不是这样的,必须使用Qt的蓝牙类读取,蓝牙类配置蓝牙为SPP串口模式,配置好UUID等,通过蓝牙的socket类实现数据的读写,与Windows差别较大,Windows的Qt还没有QBluetooth类,不知道为什么.<br>3.第二个难点是在不同界面下蓝牙状态的确定.解决方法是每次生成一个页或者销毁一个页时都会向构造函数或者析构函数传入蓝牙的相关信息,有点类似于安卓的页面上下文切换.<br>4.另外在设计”神奇控制”模式时,研究了陀螺仪值的读取,发现非常简单,只需一句话即可读取.与单片机上陀螺仪读取的复杂形成鲜明对比.<br>5.有点遗憾的是这个上位机的界面设计太简陋了,以后有时间一定会优化界面布局.<br>6.由于ios系统限制,ios蓝牙无法使用普通蓝牙协议读取未经过MFi认证的蓝牙设备,读取未经认证的设备只能通过BLE低功耗蓝牙协议,也就是说基于蓝牙2.0的hc-05蓝牙模块无法被ios设备搜索到(经过实验确实检测不到),计划下一步换装cc2541蓝牙模块后开发ios版本的蓝牙上位机.</li></ol><h1 id="蓝牙连接以及读取过程简介"><a href="#蓝牙连接以及读取过程简介" class="headerlink" title="蓝牙连接以及读取过程简介"></a>蓝牙连接以及读取过程简介</h1><blockquote><p>首先感谢<a href="http://www.cnblogs.com/sigma0/p/5769527.html" target="_blank" rel="noopener">Qt on Android 蓝牙开发 </a>这篇博客的作者,他的博客让我学到很多.Qt安卓搞蓝牙串口的相关资料确实太少了,官方帮助文档也写得不够详细.</p></blockquote><h3 id="Qt蓝牙支持的平台"><a href="#Qt蓝牙支持的平台" class="headerlink" title="Qt蓝牙支持的平台"></a>Qt蓝牙支持的平台</h3><p>查阅<a href="http://doc.qt.io/qt-5/qtbluetooth-index.html" target="_blank" rel="noopener">Qt官方帮助文档</a>可知,Qt蓝牙和BLE蓝牙支持如下平台<br><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1fkyfnvyvonj30v507l3zw.jpg" alt="支持的蓝牙平台"></p><h3 id="蓝牙基本组成"><a href="#蓝牙基本组成" class="headerlink" title="蓝牙基本组成"></a>蓝牙基本组成</h3><p>Qt蓝牙主要有以下3个类</p><ul><li>QBluetoothDeviceDiscoveryAgent 负责蓝牙的查找</li><li>QBluetoothLocalDevice 负责蓝牙设备开关状态以及工作模式</li><li>QBluetoothSocket 负责蓝牙的数据传输</li></ul><p>使用前需要在pro中添加<br><code>QT += bluetooth</code><br>添加头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtBluetooth&gt; </span><br><span class="line">#include &lt;QBluetoothAddress&gt;</span><br><span class="line">#include &lt;QBluetoothDeviceDiscoveryAgent&gt;</span><br><span class="line">#include &lt;QBluetoothLocalDevice&gt;</span><br><span class="line">#include &lt;QBluetoothSocket&gt;</span><br></pre></td></tr></table></figure><h3 id="蓝牙的初始化"><a href="#蓝牙的初始化" class="headerlink" title="蓝牙的初始化"></a>蓝牙的初始化</h3><p>蓝牙初始化主要就是要配置好<a href="http://blog.csdn.net/zf_c_cqupt/article/details/52177723" target="_blank" rel="noopener">UUID</a>如果需要蓝牙串口的话使用我这个uuid即可,直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BlueTooth::BlueTooth(QWidget *parent) : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ServiceUuid=QLatin1String(<span class="string">"00001101-0000-1000-8000-00805F9B34FB"</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;LocalDevice=<span class="keyword">new</span> QBluetoothLocalDevice();</span><br><span class="line">    <span class="keyword">this</span>-&gt;DiscoverAgent=<span class="keyword">new</span> QBluetoothDeviceDiscoveryAgent();</span><br><span class="line">    <span class="keyword">this</span>-&gt;Socket=<span class="keyword">new</span> QBluetoothSocket(QBluetoothServiceInfo::RfcommProtocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蓝牙打开与关闭"><a href="#蓝牙打开与关闭" class="headerlink" title="蓝牙打开与关闭"></a>蓝牙打开与关闭</h3><p>蓝牙打开与关闭很简单,需要注意的是部分安卓手机权限审核非常严格,可能还是需要在系统里面手动打开关闭蓝牙.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BlueTooth::Power(<span class="keyword">bool</span> Power)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Power==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;LocalDevice-&gt;powerOn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Power==<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;LocalDevice-&gt;setHostMode(QBluetoothLocalDevice::HostPoweredOff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>值得注意的是蓝牙关闭并不是写PowerOff</strong></p><h3 id="蓝牙的查找"><a href="#蓝牙的查找" class="headerlink" title="蓝牙的查找"></a>蓝牙的查找</h3><p>蓝牙查找只需要使用QBluetoothDeviceDiscoveryAgent类查找即可,查找后会自动发送信号,这样我们只需要写一个找到信号的槽函数,在槽函数里保存蓝牙的名称,<strong>UUID</strong>等等.一定要保存<strong>UUID</strong>我们知道蓝牙连接是使用UUID来连接的,后面连接时还需要用到所以一定要保存下来.由于不清楚找到的蓝牙设备个数,我使用一个向量来保存所有找到的蓝牙信息.由于涉及到信号槽的操作,需要仔细的分析信号槽的连接情况,不然可能导致信号槽不触发或者重复触发的情况.</p><h5 id="扫描设置函数"><a href="#扫描设置函数" class="headerlink" title="扫描设置函数"></a>扫描设置函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BlueTooth::scan()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;LocalDevice-&gt;hostMode()==QBluetoothLocalDevice::HostPoweredOff)</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::information(<span class="literal">NULL</span>,<span class="string">"蓝牙未打开"</span>,<span class="string">"请打开蓝牙后重试"</span>,QMessageBox::Ok);</span><br><span class="line">    &#125;</span><br><span class="line">    QObject::disconnect(<span class="keyword">this</span>-&gt;DiscoverAgent,SIGNAL(deviceDiscovered(QBluetoothDeviceInfo)),<span class="keyword">this</span>,SLOT(Discoverd(QBluetoothDeviceInfo)));</span><br><span class="line">    <span class="keyword">this</span>-&gt;DeviceInfo.clear();</span><br><span class="line">    <span class="keyword">this</span>-&gt;DiscoverAgent-&gt;stop();</span><br><span class="line">    <span class="keyword">this</span>-&gt;DiscoverAgent-&gt;start();</span><br><span class="line">    QObject::connect(<span class="keyword">this</span>-&gt;DiscoverAgent,SIGNAL(deviceDiscovered(QBluetoothDeviceInfo)),<span class="keyword">this</span>,SLOT(Discoverd(QBluetoothDeviceInfo)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扫描到的槽函数"><a href="#扫描到的槽函数" class="headerlink" title="扫描到的槽函数"></a>扫描到的槽函数</h5><p>为了实现在不同的界面上显示蓝牙连接情况,我又自己设计了一下信号槽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BlueTooth::Discoverd(<span class="keyword">const</span> QBluetoothDeviceInfo &amp;info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;DeviceInfo.append(info);</span><br><span class="line">    QBluetoothDeviceInfo send=info;</span><br><span class="line">    <span class="function">emit <span class="title">DisCoverdSignal</span><span class="params">(send)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ConfigWindow::DisCoveredSlot(QBluetoothDeviceInfo InfoBase)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;BluetoothBox-&gt;addItem(InfoBase.name().toUtf8());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蓝牙的连接和断开"><a href="#蓝牙的连接和断开" class="headerlink" title="蓝牙的连接和断开"></a>蓝牙的连接和断开</h3><p>蓝牙的连接和断开操作类似.扫描完成后就进入连接操作,连接使用QBluetoothSocket类即可.与扫描类似,连接完成后可以设置在连接完成后发送信号,在槽函数中显示相应的提示信息.蓝牙也可以连接错误时发送错误信号,进入错误槽函数等.同样,由于涉及信号槽,需要仔细处理连接问题.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蓝牙连接函数</span></span><br><span class="line"><span class="keyword">void</span> BlueTooth::BlueToothConnect(QBluetoothDeviceInfo Base)</span><br><span class="line">&#123;</span><br><span class="line">    QObject::disconnect(<span class="keyword">this</span>-&gt;Socket,SIGNAL(connected()),<span class="keyword">this</span>,SLOT(Connected()));</span><br><span class="line">    <span class="keyword">this</span>-&gt;Socket-&gt;connectToService(Base.address(),QBluetoothUuid(<span class="keyword">this</span>-&gt;ServiceUuid));</span><br><span class="line">    QObject::connect(<span class="keyword">this</span>-&gt;Socket,SIGNAL(connected()),<span class="keyword">this</span>,SLOT(Connected()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连接完成槽函数</span></span><br><span class="line"><span class="keyword">void</span> BlueTooth::Connected()</span><br><span class="line">&#123;</span><br><span class="line">    emit <span class="keyword">this</span>-&gt;ConnectOK(<span class="literal">true</span>);</span><br><span class="line">    QMessageBox::information(<span class="literal">NULL</span>,<span class="string">"连接"</span>,<span class="string">"已连接成功!"</span>,QMessageBox::Ok);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开函数</span></span><br><span class="line"><span class="keyword">void</span> BlueTooth::BlueToothDisConnect()</span><br><span class="line">&#123;</span><br><span class="line">    QObject::disconnect(<span class="keyword">this</span>-&gt;Socket,SIGNAL(disconnected()),<span class="keyword">this</span>,SLOT(Disconnected()));</span><br><span class="line">    <span class="keyword">this</span>-&gt;Socket-&gt;disconnectFromService();</span><br><span class="line">    QObject::connect(<span class="keyword">this</span>-&gt;Socket,SIGNAL(disconnected()),<span class="keyword">this</span>,SLOT(Disconnected()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开成功槽函数</span></span><br><span class="line"><span class="keyword">void</span> BlueTooth::Disconnected()</span><br><span class="line">&#123;</span><br><span class="line">    emit <span class="keyword">this</span>-&gt;DisConnetOK(<span class="literal">true</span>);</span><br><span class="line">    QMessageBox::information(<span class="literal">NULL</span>,<span class="string">"断开"</span>,<span class="string">"已断开成功!"</span>,QMessageBox::Ok);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蓝牙的传输"><a href="#蓝牙的传输" class="headerlink" title="蓝牙的传输"></a>蓝牙的传输</h3><p>到了这么久才到了正题,蓝牙的传输,蓝牙的传输主要借助于QBluetoothSocket类,和串口的传输很类似.这里主要分为传入和传出来讲</p><h4 id="传出"><a href="#传出" class="headerlink" title="传出"></a>传出</h4><p>传出操作比较简单,直接写<code>Socket-&gt;write(data.toUtf8());</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BlueTooth::SafeWrite(QString data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Socket-&gt;state()==QBluetoothSocket::ConnectedState)</span><br><span class="line">    &#123;</span><br><span class="line">        Socket-&gt;write(data.toUtf8());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Socket-&gt;state()==QBluetoothSocket::UnconnectedState)</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::information(<span class="literal">NULL</span>,<span class="string">"蓝牙未连接"</span>,<span class="string">"请连接蓝牙或检查是否被其他程序占用"</span>,QMessageBox::Ok);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::information(<span class="literal">NULL</span>,<span class="string">"错误"</span>,<span class="string">"请检查蓝牙是否打开"</span>,QMessageBox::Ok);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是我设计的一个安全读写函数,可以在蓝牙未连接的时候报错</p><h4 id="传入"><a href="#传入" class="headerlink" title="传入"></a>传入</h4><p>蓝牙的传入就要相对复杂一些,和串口一样需要使用到信号槽实现,有点类似于单片机当中的UART中断<br>首先是初始化信号槽<code>QObject::connect(this-&gt;PortBase-&gt;Socket,SIGNAL(readyRead()),this,SLOT(ReceiveSlot()));</code><br>其次是槽函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ConfigWindow::ReceiveSlot()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;HEXBox-&gt;isChecked())</span><br><span class="line">    &#123;</span><br><span class="line">        QByteArray buf=<span class="keyword">this</span>-&gt;PortBase-&gt;Socket-&gt;read(<span class="number">1</span>);</span><br><span class="line">        QString str=<span class="string">" "</span>+buf.toHex();</span><br><span class="line">        ui-&gt;ReceiveAera-&gt;insertPlainText(str);</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!ui-&gt;HEXBox-&gt;isChecked())</span><br><span class="line">    &#123;</span><br><span class="line">        QByteArray buf;</span><br><span class="line">        buf =<span class="keyword">this</span>-&gt;PortBase-&gt;Socket-&gt;readAll();</span><br><span class="line">        QString str=<span class="string">"下位机:"</span>+buf;</span><br><span class="line">        QString test=buf;</span><br><span class="line">        qDebug()&lt;&lt;test.toInt();</span><br><span class="line">        ui-&gt;ReceiveAera-&gt;append(str);</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蓝牙部分大概就说这么多,其实这也只涉及Qt蓝牙操作当中的冰山一角,还有很多的部分值得我们去研究.</p><hr><h1 id="Qt安卓读取加速度计简介"><a href="#Qt安卓读取加速度计简介" class="headerlink" title="Qt安卓读取加速度计简介"></a>Qt安卓读取加速度计简介</h1><p>说起读取加速度计,那么一定要提到Qt的传感器类了.Qt的传感器类为我们提供了访问手机传感器的功能.读取传感器以前都需要在pro文件里面添加<br><code>QT       += sensors</code></p><h3 id="陀螺仪读取"><a href="#陀螺仪读取" class="headerlink" title="陀螺仪读取"></a>陀螺仪读取</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>由于我们是读取陀螺仪,那么就需要使用QAccelerometer类<br>需要包含头文件<code>#include &lt;QtSensors/QAccelerometer&gt;</code><br>同理,如果我们读取陀螺仪,那么就需要使用QGyroscope类,包含 <code>#include &lt;QGyroscope&gt;</code><br>我初始化时设置成定时器周期读取加速度计的值,所以在初始化的过程中也用到了QTimer类,以下是代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;AcceSensor.start();<span class="comment">//初始化传感器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;AcceScanTimer.start(<span class="number">10</span>);<span class="comment">//初始化定时器</span></span><br><span class="line">QObject::connect(&amp;AcceScanTimer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(AcceScan()));</span><br></pre></td></tr></table></figure></p><h3 id="读取值"><a href="#读取值" class="headerlink" title="读取值"></a>读取值</h3><p>读取值非常简单,一句话即可搞定,以下是读取代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取传感器的值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x=AcceSensor.reading()-&gt;x();</span><br><span class="line">        <span class="keyword">this</span>-&gt;y=AcceSensor.reading()-&gt;y();</span><br><span class="line">        <span class="keyword">this</span>-&gt;z=AcceSensor.reading()-&gt;z();</span><br></pre></td></tr></table></figure></p><p>需要注意,读取回来的类型实际上就是double类型,不要被Qt的typedef所迷惑</p><p><strong>到这里整个加速度计的使用就完了</strong>相比单片机又要配置i2c,又要配置陀螺仪寄存器,读取回来还要自己计算角度,自己滤波,安卓上面确实简单了太多. </p><hr><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>其实写到这里我已经不想再写下去了,但是谁叫我强迫症突然发作呢</strong><br>虽然遗憾没能拿到国电赛一等奖,没能在总决赛上使用这个上位机.学习编写安卓上位机的整个过程却学习到了很多知识.毕竟学习知识的过程才是最重要的.我下一步计划开发ios版蓝牙上位机,研究cc2541蓝牙模块配合上位机使用.同时也计划开发一个功能更复杂,界面更精美,可以在线调试多种参数的上位机供18年智能汽车竞赛调试使用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;电赛上位机&quot;&gt;&lt;a href=&quot;#电赛上位机&quot; class=&quot;headerlink&quot; title=&quot;电赛上位机&quot;&gt;&lt;/a&gt;电赛上位机&lt;/h1&gt;&lt;h2 id=&quot;2017全国大学生电子设计竞赛板球控制系统上位机&quot;&gt;&lt;a href=&quot;#2017全国大学生电子设计竞赛板球
      
    
    </summary>
    
    
      <category term="作品" scheme="http://blog.zzshub.cn/tags/%E4%BD%9C%E5%93%81/"/>
    
      <category term="2017电赛" scheme="http://blog.zzshub.cn/tags/2017%E7%94%B5%E8%B5%9B/"/>
    
      <category term="Qt" scheme="http://blog.zzshub.cn/tags/Qt/"/>
    
      <category term="安卓" scheme="http://blog.zzshub.cn/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>新建站点</title>
    <link href="http://blog.zzshub.cn/2017/10/27/%E6%96%B0%E5%BB%BA%E7%AB%99%E7%82%B9/"/>
    <id>http://blog.zzshub.cn/2017/10/27/新建站点/</id>
    <published>2017-10-26T16:50:44.000Z</published>
    <updated>2018-03-26T15:45:37.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刚刚终于建立了站点"><a href="#刚刚终于建立了站点" class="headerlink" title="刚刚终于建立了站点"></a>刚刚终于建立了站点</h1><hr><blockquote><p>刚刚终于基本建立了这个博客。博客是采用hexo框架托管在github page上面的.首先感谢<a href="https://github.com/Mrminfive" target="_blank" rel="noopener">Mrminfive</a>无私贡献的<a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank" rel="noopener">skapp</a>主题模板。</p></blockquote><hr><h2 id="建站更新"><a href="#建站更新" class="headerlink" title="建站更新"></a>建站更新</h2><ul><li>2017年11月17日</li></ul><p>重新优化博客访问速度</p><ul><li>2017年11月3日</li></ul><p>为博客添加了分享功能,博客采用<a href="http://www.mob.com/" target="_blank" rel="noopener">ShareSDK</a>实现分享功能</p><ul><li>2017年10月31日</li></ul><p>为博客添加了视频支持,底部有视频测试,添加了网易云音乐播放连接,底部有播放的连接</p><ul><li>2017年10月31日</li></ul><p>为博客添加了加密功能,部分博客需要输入密码才能查看</p><ul><li>2017年10月30日</li></ul><p>为博客系统添加了<a href="https://gitalk.github.io/" target="_blank" rel="noopener">gitalk</a>评论系统,可以通过登陆github账号实现对我的博客的评论</p><ul><li>2017年10月30日</li></ul><p>为博客添加了站内搜索,百度统计,文章阅读数统计,将网站背景指向必应美图等</p><h2 id="第一个个人站点"><a href="#第一个个人站点" class="headerlink" title="第一个个人站点"></a>第一个个人站点</h2><p>这是我成功放到网上的个人站点，同时这也是我第一篇博客。从小学起，我一直都有一个建立一个个人站点的愿望。小学4年级开始研究微软的<a href="https://baike.baidu.com/item/Frontpage/2137423?fr=aladdin" target="_blank" rel="noopener">frontpage</a>。只不过那时止步于88元一年的服务器费用，停止了研究。时间过得很快，很快就到了高中，那时家里换了路由器，我也有机会在新的路由器操作系统<a href="http://www.hiwifi.com" target="_blank" rel="noopener">hiwifiOS</a>玩一些东西，其实也就是纯粹的瞎折腾，那时候因为乱搞路由导致经常网络不稳定被家里人说过，不过也就是在那个时候，我才大概搞懂了网络的一些东西，利用hiwifiOS提供的插件，做了个上网欢迎页出来，也利用smb+DDNS服务搭建过个人网盘。真正开始系统的学习计算机方面的技术已经是大学的事了，上个月开发给新生培训用的<strong>STM32</strong>单片机的示例程序的时候才发现有一个叫github page的东西，顺藤摸瓜，找到了jekyll，学习了几天jekyll发现这个东西看起来太费劲了，进一步搜索，便找到了简单易学hexo，建立了这个很久以来都想建立的博客，也算是实现了儿时的一个愿望吧。</p><h2 id="构建博客的经历"><a href="#构建博客的经历" class="headerlink" title="构建博客的经历"></a>构建博客的经历</h2><ul><li>写STM32示例程序的过程中发现github page</li><li>初步了解github page 用自带的模板搭建了一个网页<a href="https://zzzzzzs.github.io/STM32Learning/" target="_blank" rel="noopener">718创联 STM32培训</a></li><li>进一步研究发现了jekyll</li><li>发现了hexo</li><li>用初始主题搭建了博客本地运行正常</li><li>找到了这个主题</li><li>Windows系统对某组件兼容异常</li><li>转到Mac平台，发布博客</li></ul><hr><h1 id="音乐测试"><a href="#音乐测试" class="headerlink" title="音乐测试"></a>音乐测试</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5264843&auto=0&height=66"></iframe><!-- UY BEGIN --><p><div id="uyan_frame"></div></p><p><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2147909"></script><br><!-- UY END --></p><p><img src="http://zzshubimage-1253829354.file.myqcloud.com/718logo.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;刚刚终于建立了站点&quot;&gt;&lt;a href=&quot;#刚刚终于建立了站点&quot; class=&quot;headerlink&quot; title=&quot;刚刚终于建立了站点&quot;&gt;&lt;/a&gt;刚刚终于建立了站点&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;刚刚终于基本建立了这个博客。博客是采用hexo
      
    
    </summary>
    
      <category term="系统测试" scheme="http://blog.zzshub.cn/categories/%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="blog" scheme="http://blog.zzshub.cn/tags/blog/"/>
    
      <category term="hexo" scheme="http://blog.zzshub.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://blog.zzshub.cn/tags/github/"/>
    
  </entry>
  
</feed>
