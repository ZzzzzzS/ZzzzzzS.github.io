<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZZSHUB</title>
  
  <subtitle>ZZS</subtitle>
  <link href="https://blog.zzshub.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.zzshub.cn/"/>
  <updated>2024-07-02T05:07:11.679Z</updated>
  <id>https://blog.zzshub.cn/</id>
  
  <author>
    <name>Zishun Zhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>强化学习仿真器Isaac Gym的安装，配置，与初步使用</title>
    <link href="https://blog.zzshub.cn/2024/06/21/DRL_LeggedgymInstall/"/>
    <id>https://blog.zzshub.cn/2024/06/21/DRL_LeggedgymInstall/</id>
    <published>2024-06-21T04:00:00.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习仿真器Isaac-Gym的安装，配置，与初步使用"><a href="#强化学习仿真器Isaac-Gym的安装，配置，与初步使用" class="headerlink" title="强化学习仿真器Isaac Gym的安装，配置，与初步使用"></a>强化学习仿真器Isaac Gym的安装，配置，与初步使用</h1><blockquote><p><strong>写在前面</strong> – 最近强化学习强化学习在机器人领域真是大放异彩，鉴于IsaacGym+LeggedGym的仿真器和训练框架组合已经成为了机器人领域强化学习算法的主流工具，于是我打算写一篇博客来记录一下这个仿真环境的安装和使用。</p></blockquote><blockquote><p>本文主要参考了<a href="https://zhuanlan.zhihu.com/p/560826876">这篇博客</a>的内容。</p></blockquote><h1 id="Isaac-Gym简介"><a href="#Isaac-Gym简介" class="headerlink" title="Isaac Gym简介"></a>Isaac Gym简介</h1><p>本文主要介绍Isaac Gym强化学习仿真器和Legged Gym强化学习训练框架的安装和使用。Isaac Gym是一个基于GPU加速的并行计算仿真环境，主要可进行强化学习研究。它支持导入URDF和MJCF文件、基于张量(tensor)的API、域随机化(domain randomlization)以及各种传感器和环境。该仿真器使用GPU并行加速，比传统使用cpu计算的仿真如mujoco&#x2F;raisim等可提速上百倍，非常适合需要大量采样的深度学习类算法使用，但仿真精度相较于mujoco等有略微下降，Isaac Gym框架对显存大小有较高要求，最低显存配置为4GB，(个人推荐8GB以上)，对显卡算力最低要求不高GTX10系列及以上可运行。Legged Gym是一个由ETH推出的腿足机器人强化学习训练框架，实现了如ppo等算法和ANYmal&#x2F;Cassie等机器人的训练权重等，该框架需要配合Isaacgym仿真器使用。经过我的测试<strong>Isaac Gym可以运行在Ubuntu20.04，Ubuntu22.04系统上，且python版本为python3.8。python3.9及以上版本实测无法运行，Windows10&#x2F;11，Windows Subsystem on Linux, Docker for Windows等环境实测无法运行，Linux虚拟机实测无法运行，Ubuntu24.04可以运行但坑比较多因此也不太建议</strong>，其余未提及的系统未测试，Docker for Linux理论上可以支持。<strong>但强烈建议安装Ubuntu20.04&#x2F;22.04配合anaconda的python3.8环境使用</strong>。</p><p>该环境安装主要包括以下几个部分，鉴于Ubuntu操作系统的安装网上资料已经很多，因此本文不会介绍这部分内容，建议读者自行获取资料。</p><ul><li>Nvidia 显卡驱动安装</li><li>Nvidia CUDA环境安装</li><li>anaconda python虚拟环境安装</li><li>Isaac Gym 仿真器安装</li><li>Legged Gym(我修改的版本) 训练框架安装</li></ul><h1 id="Isaac-Gym安装"><a href="#Isaac-Gym安装" class="headerlink" title="Isaac Gym安装"></a>Isaac Gym安装</h1><h2 id="Nvidia-显卡驱动安装"><a href="#Nvidia-显卡驱动安装" class="headerlink" title="Nvidia 显卡驱动安装"></a>Nvidia 显卡驱动安装</h2><p>显卡驱动安装，在终端中输入<code>sudo  ubuntu-drivers autoinstall</code>即可完成安装系统推荐的显卡驱动。</p><p>安装完成后在终端窗口中输入<code>nvidia-smi</code>命令，如果出现以下内容，则证明显卡驱动已经安装完成。如下所示，我安装的驱动版本是546.12, CUDA版本是12.3。**注意后续安装CUDA和pytorch时大版本号需要与之对齐，即对于这里的情况来说需要对应安装CUDA12.x版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 546.12                 Driver Version: 546.12       CUDA Version: 12.3     |</span><br><span class="line">|-----------------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name                     TCC/WDDM  | Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                                         |                      |               MIG M. |</span><br><span class="line">|=========================================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce RTX 4090      WDDM  | 00000000:01:00.0 Off |                  Off |</span><br><span class="line">|  0%   32C    P8               3W / 450W |      0MiB / 24564MiB |      0%      Default |</span><br><span class="line">|                                         |                      |                  N/A |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                            |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |</span><br><span class="line">|        ID   ID                                                             Usage      |</span><br><span class="line">|=======================================================================================|</span><br><span class="line">|  No running processes found                                                           |</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>若安装失败，可以参阅<a href="https://blog.csdn.net/Perfect886/article/details/119109380">这篇文章</a>提供的方法手动安装和卸载。注意如果安装时出现需要设置密码等情况可以从计算机bios中关闭security boot选项来避免一些麻烦，但这会破坏计算机启动过程中的<a href="https://zhuanlan.zhihu.com/p/25279889">可信计算链条</a>从而导致安全性略微降低。</p><h2 id="安装CUDA环境"><a href="#安装CUDA环境" class="headerlink" title="安装CUDA环境"></a>安装CUDA环境</h2><p>CUDA 是 NVIDIA 发明的一种并行计算平台和编程模型。它通过利用图形处理器 (GPU) 的处理能力，可大幅提升计算性能。是使用Nvidia显卡进行通用计算的基础。安装CUDA的方式较为简单，按照nvidia官网教程走基本上不会有太大问题。访问cuda<a href="https://developer.nvidia.com/cuda-downloads">下载官网</a>。选择适合自己系统的版本, 这里我选择的是离线安装的版本。<strong>请注意不建议使用apt源安装，apt源包含的cuda版本较为老旧，可能产生冲突！</strong></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/DRL_installIsaacgym/cuda_dl.png" alt="cuda_dl"></p><p>选择完成后将官网给出的下列代码依次输入即可完成安装，可以忽略下方可选的驱动更新选项。注意保持网络畅通，<code>wget</code>那一步报错是网络问题。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/DRL_installIsaacgym/cuda_ins.png" alt="cuda_ins"><br>安装完成后在命令行里输入<code>/usr/local/cuda/bin/nvcc --version</code>, 若出现类似如下内容即证明安装成功。（可以将该路径加入环境变量。）<strong>注意：千万不能使用<code>sudo apt install nvidia-cuda-toolkit</code>命令，否则会重新安装apt源的过时版本的CUDA</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2023 NVIDIA Corporation</span><br><span class="line">Built on Fri_Nov__3_17:51:05_Pacific_Daylight_Time_2023</span><br><span class="line">Cuda compilation tools, release 12.3, V12.3.103</span><br><span class="line">Build cuda_12.3.r12.3/compiler.33492891_0</span><br></pre></td></tr></table></figure><h2 id="安装Anaconda虚拟环境"><a href="#安装Anaconda虚拟环境" class="headerlink" title="安装Anaconda虚拟环境"></a>安装Anaconda虚拟环境</h2><p>Anaconda是一个开源的Python发行版，用于科学计算和数据分析。它包含了许多常用的科学计算和数据分析库，如NumPy、Pandas、Matplotlib等，并且提供了一个方便的环境管理工具。Anaconda的目标是简化Python环境的配置和管理，使得科学计算和数据分析的工作更加高效和便捷。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。Miniconda是Conda的轻量级版本，只包含最基本的内容——Python与conda以及相关的必须依赖项123。它适用于空间要求严格的用户或只需要Python和Conda核心功能的用户。本教程将安装miniconda。</p><p>访问miniconda的<a href="https://docs.anaconda.com/miniconda/">官方网站</a>下载linux版本的miniconda。并逐行在终端中执行官网最底部显示的快速安装教程(注意选择linux版本的教程)，miniconda默认安装在用户主目录下的miniconda3文件夹中。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/DRL_installIsaacgym/conda_ins.png" alt="conda_ins"></p><p>关闭终端并重新打开后发现终端命令行开头出现<code>(base)</code>字样即说明安装成功。这是安装后conda自动启动了base环境引起的现象，可正常使用(ros环境下能不能用不清楚)，也可以通过<code>conda config --set auto_activate_base false</code>命令来设置不自动启动base环境。</p><p>之后新建一个python3.8的虚拟环境供我们后续使用。使用如下命令新建一个python3.8环境。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n &quot;legged-gym&quot; python=3.8</span><br></pre></td></tr></table></figure><p>其中<code>-n</code>参数指定新环境的名字，可根据需要自行修改。<code>python=3.8</code>参数指定使用python3.8环境。</p><p>之后使用<code>conda activate legged-gym</code>命令激活新建的环境。在命令行中输入<code>python</code>，若出现<code>Anaconda</code>, <code>python3.8</code>等字样则说明安装成功。之后输入<code>exit()</code>即可退出python命令行解释器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python 3.8.19 (default, Mar 20 2024, 19:58:24)</span><br><span class="line">[GCC 11.2.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>可参阅<a href="https://anaconda.org.cn/">此链接</a>，或<a href="https://blog.csdn.net/chenxy_bwave/article/details/119996001">此链接</a>来快速入门anaconda。</p><h2 id="安装Isaac-Gym环境"><a href="#安装Isaac-Gym环境" class="headerlink" title="安装Isaac Gym环境"></a>安装Isaac Gym环境</h2><p>安装Isaac Gym可以从<a href="https://developer.nvidia.com/isaac-gym">官网下载</a>，但由于Nvidia官方已经不再维护该仿真器(Nvidia已经转向<a href="https://docs.omniverse.nvidia.com/isaacsim/latest/index.html">Omniverse Sim</a>了，但其API过于复杂，暂时用不到)，从官网下载的版本存在一些细小的依赖问题需要我们手动修复。</p><h3 id="修复官方版本的Isaac-Gym"><a href="#修复官方版本的Isaac-Gym" class="headerlink" title="修复官方版本的Isaac Gym"></a>修复官方版本的Isaac Gym</h3><p>下载软件包后将其解压缩 **(推荐解压缩到用户根目录，解压到的目录就是Isaac Gym的安装位置，配置好后无法变更)**。使用<a href="https://code.visualstudio.com/">vscode</a>等文本编辑器打开<code>./python/isaacgym/torch_utils.py</code>文件，将第135行的<code>np.float</code>修改为<code>float</code>如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_axis_params</span>(<span class="params">value, axis_idx, x_value=<span class="number">0.</span>, dtype=np.<span class="built_in">float</span>, n_dims=<span class="number">3</span></span>):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将np.float修改为float</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_axis_params</span>(<span class="params">value, axis_idx, x_value=<span class="number">0.</span>, dtype=<span class="built_in">float</span>, n_dims=<span class="number">3</span></span>):</span><br></pre></td></tr></table></figure><p>由于官方版本的Isaac Gym会默认安装cpu版本的<a href="https://www.ibm.com/cn-zh/topics/pytorch">pytorch</a>，因此我们还需要提前手动安装gpu版本的pytorch防止被覆盖安装。首先激活刚才新建的anaconda环境：<code>conda activate legged-gym</code>，之后前往<a href="https://pytorch.org/">pytorch官网</a>下载pytorch，向下滑动一些后在如下图所示的界面中选择对应的版本，并在激活的conda环境中输入指令来完成安装。<strong>请注意，推荐选择使用conda的方式安装，使用pip安装也可以，注意一定要安装对应的cuda大版本，如这里是cuda12。</strong></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/DRL_installIsaacgym/pytorch_ins.png" alt="torch_ins"></p><p>在激活的环境中启动python, 并输入<code>import torch</code>，和<code>print(torch.cuda.is_available())</code>，若输出为True则证明gpu版本的pytorch已经安装到位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.10</span><span class="number">.13</span> | packaged by Anaconda, Inc. | (main, Sep <span class="number">11</span> <span class="number">2023</span>, <span class="number">13</span>:<span class="number">24</span>:<span class="number">38</span>) [MSC v<span class="number">.1916</span> <span class="number">64</span> bit (AMD64)] on win32</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(torch.cuda.is_available())</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="正式安装Isaac-Gym与测试"><a href="#正式安装Isaac-Gym与测试" class="headerlink" title="正式安装Isaac Gym与测试"></a>正式安装Isaac Gym与测试</h3><p>激活刚才新建的anaconda环境：<code>conda activate legged-gym</code>。使用<code>cd</code>命令跳转到<code>./python</code>目录下。执行<code>pip install -e .</code>命令即可完成安装。</p><p>下面将测试Isaac Gym是否安装成功。使用<code>cd</code>命令跳转到<code>./python/examples</code>目录下。在激活的环境下执行<code>python ./joint_monkey.py</code> 或该文件夹下的其他任意一个文件，若能正常弹出窗口并运行，则说明安装成功。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/DRL_installIsaacgym/isaacgym_run.png" alt="Isaacgym_run"></p><h2 id="安装Legged-Gym环境"><a href="#安装Legged-Gym环境" class="headerlink" title="安装Legged Gym环境"></a>安装Legged Gym环境</h2><p>使用<code>conda activate legged-gym</code>命令激活刚才建立的环境。</p><p>在激活的环境中使用<code>git clone https://github.com/leggedrobotics/rsl_rl</code>命令克隆rsl_rl仓库到本地,<strong>注意请妥善选择克隆位置，安装后无法修改位置</strong>。<br>执行<code>cd rsl_rl &amp;&amp; git checkout v1.0.2 &amp;&amp; pip install -e .</code>命令完成rsl_rl的安装。</p><p>在激活的环境中使用<code>git clone https://github.com/leggedrobotics/legged_gym.git</code>命令克隆Legged Gym仓库到本地,<strong>注意请妥善选择克隆位置，安装后无法修改位置</strong>。<br>执行<code>cd legged_gym &amp;&amp; pip install -e .</code>命令完成安装。</p><p>使用<code>python legged_gym/scripts/train.py --task=anymal_c_flat</code>命令来测试环境是否能正常训练。</p><p>使用<code>python legged_gym/scripts/play.py --task=anymal_c_flat</code>命令来测试您刚才训练出的策略。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/DRL_installIsaacgym/leggedgym_train.png" alt="leg_train"></p><p>恭喜您，到目前为止您已经成功安装了Isaac Gym+Legged Gym环境。在下一篇文章中我将通过一个二阶倒立摆的例子来初步展示一个完整的训练过程。</p><h2 id="延申阅读：更多的训练框架"><a href="#延申阅读：更多的训练框架" class="headerlink" title="延申阅读：更多的训练框架"></a>延申阅读：更多的训练框架</h2><ul><li><p><a href="https://github.com/ZzzzzzS/legged_gym">Legged Gym(zzs_version)</a>: 由我本人修改，目前我正在使用的Legged Gym版本，添加了一些更友好的可视化功能，和一个注释完整，对新手友好的二阶倒立摆训练环境(comming soon)。</p></li><li><p><a href="https://github.com/roboterax/humanoid-gym">Humanoid Gym</a>: 由星动纪元推出的对ETH Legged Gym框架的改进版本。实现了IsaacGym仿真器到mujoco仿真器的sim2sim迁移。</p></li><li><p><a href="https://github.com/isaac-sim/IsaacGymEnvs">IsaacGymEnv</a>: 由Nvidia官方推出的强化学习训练框架，实现了如AMP模仿学习，基于SDF函数的碰撞检测等更多功能。但框架较复杂。</p></li></ul><h1 id="API参考文档和入门教程"><a href="#API参考文档和入门教程" class="headerlink" title="API参考文档和入门教程"></a>API参考文档和入门教程</h1><ul><li>Pytorch 文档: <a href="https://pytorch.org/docs/stable/index.html">https://pytorch.org/docs/stable/index.html</a></li><li>Pytorch 官方教程: <a href="https://pytorch.org/tutorials/">https://pytorch.org/tutorials/</a></li><li>Pytorch 中文教程(建议看英文原版): <a href="https://www.w3cschool.cn/pytorch/">https://www.w3cschool.cn/pytorch/</a></li><li>Isaac Gym 文档(本站镜像，官方不提供在线文档): <a href="https://blog.zzshub.cn/legged_gym/">https://blog.zzshub.cn/legged_gym/</a></li><li>Isaac Gym 论文：<a href="https://arxiv.org/abs/2108.10470">https://arxiv.org/abs/2108.10470</a></li><li>Legged Gym 项目主页： <a href="https://github.com/leggedrobotics/legged_gym">https://github.com/leggedrobotics/legged_gym</a></li><li>RSL_RL 项目主页：<a href="https://github.com/leggedrobotics/rsl_rl">https://github.com/leggedrobotics/rsl_rl</a></li></ul><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul><li><p>Ubuntu18-22.04安装和干净卸载nvidia显卡驱动：<a href="https://blog.csdn.net/Perfect886/article/details/119109380">https://blog.csdn.net/Perfect886/article/details/119109380</a></p></li><li><p>安装IsaacGym报错ImportError: libpython3.8.so.1.0: cannot open shared object file: No such file or directory <a href="https://blog.csdn.net/weixin_43989965/article/details/136612205">https://blog.csdn.net/weixin_43989965/article/details/136612205</a></p></li><li><p>isaacgym启动时窗口黑屏：<a href="https://forums.developer.nvidia.com/t/isaac-gym-examples-black-window-when-running-joint-monkey-py/165975">https://forums.developer.nvidia.com/t/isaac-gym-examples-black-window-when-running-joint-monkey-py/165975</a></p></li><li><p>isaacgym与远程桌面问题：<a href="https://forums.developer.nvidia.com/t/viewer-gui-with-virtual-display/187835">https://forums.developer.nvidia.com/t/viewer-gui-with-virtual-display/187835</a></p></li></ul><p>更多问题和解决方案建议访问Nvidia<a href="https://forums.developer.nvidia.com/">官方论坛</a>查询。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;强化学习仿真器Isaac-Gym的安装，配置，与初步使用&quot;&gt;&lt;a href=&quot;#强化学习仿真器Isaac-Gym的安装，配置，与初步使用&quot; class=&quot;headerlink&quot; title=&quot;强化学习仿真器Isaac</summary>
        
      
    
    
    
    
    <category term="强化学习" scheme="https://blog.zzshub.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器人" scheme="https://blog.zzshub.cn/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>机器人控制中的强化学习极简入门指南</title>
    <link href="https://blog.zzshub.cn/2024/05/21/start_rl/"/>
    <id>https://blog.zzshub.cn/2024/05/21/start_rl/</id>
    <published>2024-05-21T04:00:00.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器人控制中的强化学习极简入门指南"><a href="#机器人控制中的强化学习极简入门指南" class="headerlink" title="机器人控制中的强化学习极简入门指南"></a>机器人控制中的强化学习极简入门指南</h1><blockquote><p>最近随着深度强化学习在机器人领域大放异彩，大家对这个方向的关注热情日趋高涨。最近老有人来问我相关的问题，借此机会我写了一个强化学习极简入门教程，其实也就是回答了入门应该看一些什么资料的问题。其实我本人也是初学者，如有疏漏或者错误还请大家海涵，如有问题也欢迎大家一起讨论。这是本系列的第一篇文章，计划后续会继续写一些更具体的环境搭建教程和入门教程，争取不鸽。</p></blockquote><h1 id="强化学习-深度学习部分参考资料"><a href="#强化学习-深度学习部分参考资料" class="headerlink" title="强化学习&#x2F;深度学习部分参考资料"></a>强化学习&#x2F;深度学习部分参考资料</h1><ul><li><p>OpenAI的spinning up，主要讲深度强化学习的基本概念和算法的主流思想，里面也有配套代码，代码适合初学者学习，不过配置环境有点恶心，涉及到OpenMPI的内容，代码实在跑不起来就算了，能读懂就挺好，这个强烈推荐看完<br><a href="https://spinningup.openai.com/en/latest/">https://spinningup.openai.com/en/latest/</a></p></li><li><p>OpenAI的gym(更名为Gymnasium了，其实就是gym)环境，经典的强化学习环境，这个环境可以好好玩玩<br><a href="https://gymnasium.farama.org/">https://gymnasium.farama.org/</a><br><a href="https://github.com/Farama-Foundation/Gymnasium">https://github.com/Farama-Foundation/Gymnasium</a></p></li><li><p>stable baseline3，深度强化学习经典&#x2F;常用算法合集，和gym配合使用，gym只是一个环境，或者叫agent，这个是学习控制agent的算法，或者叫policy。<br>配合gym使用，熟悉一下api就好，别看里面的实现，太复杂了<br><a href="https://stable-baselines3.readthedocs.io/en/master/">https://stable-baselines3.readthedocs.io/en/master/</a></p></li><li><p>这个是网上一个老哥写的强化学习算法合集，这个和stable baseline3的算法内容基本相同，但是简单很多，适合初学者学习，可以配合这spinning up来看，这个代码很好读也很好跑起来。<br><a href="https://github.com/Lizhi-sjtu/DRL-code-pytorch">https://github.com/Lizhi-sjtu/DRL-code-pytorch</a></p></li><li><p>另一个不错的强化学习算法库：<br><a href="https://github.com/thu-ml/tianshou">https://github.com/thu-ml/tianshou</a></p></li><li><p>最后推荐一本叫《强化学习》的书，这本书很经典系统的介绍了强化学习的基础理论。但是这本书知识有点旧了，但是对入门还是有一些帮助，主要是前几张的内容可以仔细看看，理解一下动态规划，蒙特卡洛，和时序差分的概念比较重要。</p></li><li><p>pytorch必学深度学习框架，个人感觉学习pytorch看官网的教程就够了，不懂的api问gpt就好<br><a href="https://pytorch.org/">https://pytorch.org/</a></p></li></ul><p>一些可能会有帮助的资料：<br><a href="https://docs.anaconda.com/free/miniconda/index.html">https://docs.anaconda.com/free/miniconda/index.html</a><br><a href="https://code.visualstudio.com/docs">https://code.visualstudio.com/docs</a><br><a href="https://zh.cppreference.com/w/">https://zh.cppreference.com/w/</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a><br><a href="https://www.runoob.com/python3/python3-tutorial.html">https://www.runoob.com/python3/python3-tutorial.html</a><br><a href="https://www.runoob.com/linux/linux-tutorial.html">https://www.runoob.com/linux/linux-tutorial.html</a><br><a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></p><p>以上就是强化学习&#x2F;深度学习的一些资料，建议先熟悉熟悉基本的强化学习。熟悉一下linux和python，以及pytorch，之后再看下一步的强化学习在机器人上的应用。强烈建议看完spinning up，以及gym，后面那些框架大概看看就好，<strong>不要花费太多时间看算法框架，很多也不一定适合，而且太复杂，不要话太多时间思考算法细节，初步使用不会涉及到修改学习算法本身，多看看仿真器，多跑跑实际工程</strong>。多写多练才能更快进步。</p><h1 id="机器人控制和仿真器参考资料"><a href="#机器人控制和仿真器参考资料" class="headerlink" title="机器人控制和仿真器参考资料"></a>机器人控制和仿真器参考资料</h1><blockquote><p>啊，终于到正题了</p></blockquote><ul><li><p>强化学习的仿真器：<br>nvidia isaacgym (类比于mojoco)，这个是我们目前主要使用的仿真器，可以下载下来熟悉一下，ubuntu 20.04 22.04 24.04 实测支持，建议使用python3.8 </br><br>  官网：<a href="https://developer.nvidia.com/isaac-gym">https://developer.nvidia.com/isaac-gym</a></br><br>  镜像文档：<a href="https://blog.zzshub.cn/legged_gym/">https://blog.zzshub.cn/legged_gym/</a> </br><br>  安装教程：<a href="https://zhuanlan.zhihu.com/p/560826876">https://zhuanlan.zhihu.com/p/560826876</a></p></li><li><p>ETH Raisim<br><a href="https://raisim.com/">https://raisim.com/</a> 这个是另一个仿真器，可以看看，也可以不看。仿真精度高，但是速度慢。</p></li><li><p>nvidia isaac sim。这个可能是我们未来会使用的仿真器<br><a href="https://docs.omniverse.nvidia.com/isaacsim/latest/overview.html">https://docs.omniverse.nvidia.com/isaacsim/latest/overview.html</a></p></li><li><p>强化学习的框架（对仿真器做的二次封装，方便强化学习使用，类比于Pinocchio）：<br>目前我们使用的是eth的legged_gym，这个配合nvidia isaacgym使用</br><br>  官方版本：<a href="https://github.com/leggedrobotics/legged_gym">https://github.com/leggedrobotics/legged_gym</a> </br><br>  我修改版本：<a href="https://github.com/ZzzzzzS/legged_gym">https://github.com/ZzzzzzS/legged_gym</a></p></li></ul><h1 id="双足-四足机器人强化学习经典论文"><a href="#双足-四足机器人强化学习经典论文" class="headerlink" title="双足&#x2F;四足机器人强化学习经典论文"></a>双足&#x2F;四足机器人强化学习经典论文</h1><h2 id="算法理论"><a href="#算法理论" class="headerlink" title="算法理论"></a>算法理论</h2><ul><li><p>X. B. Peng, Z. Ma, P. Abbeel, S. Levine and A. Kanazawa, “AMP: adversarial motion priors for stylized physics-based character control,” ACM Transactions on Graphics, vol. 40, p. 144:1–144:20, July 2021.</p></li><li><p>X. B. Peng, P. Abbeel, S. Levine and M. van de Panne, “DeepMimic: example-guided deep reinforcement learning of physics-based character skills,” ACM Transactions on Graphics, vol. 37, p. 143:1–143:14, July 2018.</p></li><li><p>J. Schulman, F. Wolski, P. Dhariwal, A. Radford and O. Klimov, “Proximal Policy Optimization Algorithms,” 2017.</p></li><li><p>V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves, M. Riedmiller, A. K. Fidjeland, G. Ostrovski, S. Petersen, C. Beattie, A. Sadik, I. Antonoglou, H. King, D. Kumaran, D. Wierstra, S. Legg and D. Hassabis, “Human-level control through deep reinforcement learning,” Nature, vol. 518, p. 529–533, February 2015.</p></li><li><p>D. Kalashnikov, J. Varley, Y. Chebotar, B. Swanson, R. Jonschkowski, C. Finn, S. Levine and K. Hausman, “MT-Opt: Continuous Multi-Task Robotic Reinforcement Learning at Scale,” 2021.</p></li><li><p>E. Jang, A. Irpan, M. Khansari, D. Kappler, F. Ebert, C. Lynch, S. Levine and C. Finn, “BC-Z: Zero-Shot Task Generalization with Robotic Imitation Learning,” in Proceedings of the 5th Conference on Robot Learning, 2022.</p></li><li><p>C. Finn, P. Christiano, P. Abbeel and S. Levine, “A Connection between Generative Adversarial Networks, Inverse Reinforcement Learning, and Energy-Based Models,” 2016.</p></li><li><p>A. Creswell, T. White, V. Dumoulin, K. Arulkumaran, B. Sengupta and A. A. Bharath, “Generative Adversarial Networks: An Overview,” IEEE Signal Processing Magazine, vol. 35, p. 53–65, January 2018.</p></li></ul><h2 id="仿真工具"><a href="#仿真工具" class="headerlink" title="仿真工具"></a>仿真工具</h2><ul><li><p>N. Rudin, D. Hoeller, P. Reist and M. Hutter, “Learning to walk in minutes using massively parallel deep reinforcement learning,” in Conference on Robot Learning, 2022.</p></li><li><p>V. Makoviychuk, L. Wawrzyniak, Y. Guo, M. Lu, K. Storey, M. Macklin, D. Hoeller, N. Rudin, A. Allshire, A. Handa and G. State, “Isaac Gym: High Performance GPU-Based Physics Simulation For Robot Learning,” 2021.</p></li><li><p>M. Körber, J. Lange, S. Rediske, S. Steinmann and R. Glück, “Comparing Popular Simulation Environments in the Scope of Robotics and Reinforcement Learning,” 2021.</p></li></ul><h2 id="双足-四足控制"><a href="#双足-四足控制" class="headerlink" title="双足&#x2F;四足控制"></a>双足&#x2F;四足控制</h2><ul><li><p>A. Tang, T. Hiraoka, N. Hiraoka, F. Shi, K. Kawaharazuka, K. Kojima, K. Okada and M. Inaba, “HumanMimic: Learning Natural Locomotion and Transitions for Humanoid Robot via Wasserstein Adversarial Imitation,” September 2023.</p></li><li><p>J. Siekmann, Y. Godse, A. Fern and J. Hurst, “Sim-to-Real Learning of All Common Bipedal Gaits via Periodic Reward Composition,” in 2021 IEEE International Conference on Robotics and Automation (ICRA), Xi&apos;an, China, 2021.</p></li><li><p>T. Miki, J. Lee, J. Hwangbo, L. Wellhausen, V. Koltun and M. Hutter, “Learning robust perceptive locomotion for quadrupedal robots in the wild,” Science Robotics, vol. 7, p. eabk2822, 2022.</p></li><li><p>Z. Li, X. B. Peng, P. Abbeel, S. Levine, G. Berseth and K. Sreenath, “Reinforcement Learning for Versatile, Dynamic, and Robust Bipedal Locomotion Control,” January 2024.</p></li><li><p>J. Lee, J. Hwangbo, L. Wellhausen, V. Koltun and M. Hutter, “Learning quadrupedal locomotion over challenging terrain,” Science Robotics, vol. 5, p. eabc5986, October 2020.</p></li><li><p>A. Kumar, Z. Fu, D. Pathak and J. Malik, “RMA: Rapid Motor Adaptation for Legged Robots,” 2021.</p></li><li><p>Y. Jin, X. Liu, Y. Shao, H. Wang and W. Yang, “High-speed quadrupedal locomotion by imitation-relaxation reinforcement learning,” Nature Machine Intelligence, vol. 4, p. 1198–1208, December 2022.</p></li><li><p>F. Jenelten, J. He, F. Farshidian and M. Hutter, “DTC: Deep Tracking Control,” Science Robotics, vol. 9, p. eadh5401, January 2024.</p></li><li><p>D. Hoeller, N. Rudin, D. Sako and M. Hutter, “ANYmal parkour: Learning agile navigation for quadrupedal robots,” Science Robotics, vol. 9, p. eadi7566, March 2024.</p></li><li><p>H. Duan, B. Pandit, M. S. Gadde, B. van Marum, J. Dao, C. Kim and A. Fern, “Learning Vision-Based Bipedal Locomotion for Challenging Terrain,” September 2023.</p></li><li><p>D. Baek, A. Purushottam and J. Ramos, “Hybrid LMC: Hybrid Learning and Model-based Control for Wheeled Humanoid Robot via Ensemble Deep Reinforcement Learning,” in 2022 IEEE&#x2F;RSJ International Conference on Intelligent Robots and Systems (IROS), 2022.</p></li><li><p>I. M. Aswin Nahrendra, B. Yu and H. Myung, “DreamWaQ: Learning Robust Quadrupedal Locomotion With Implicit Terrain Imagination via Deep Reinforcement Learning,” in 2023 IEEE International Conference on Robotics and Automation (ICRA), 2023.</p></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>一个值得参考的强化学习简介PPT，<a href="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/start_rl/reinforce_learning_sharing.pdf">点击此处</a>下载。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;机器人控制中的强化学习极简入门指南&quot;&gt;&lt;a href=&quot;#机器人控制中的强化学习极简入门指南&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="强化学习" scheme="https://blog.zzshub.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器人" scheme="https://blog.zzshub.cn/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>WSL中的GPU原理总结</title>
    <link href="https://blog.zzshub.cn/2023/08/30/wslgperformace/"/>
    <id>https://blog.zzshub.cn/2023/08/30/wslgperformace/</id>
    <published>2023-08-30T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WSL中的GPU原理总结"><a href="#WSL中的GPU原理总结" class="headerlink" title="WSL中的GPU原理总结"></a>WSL中的GPU原理总结</h1><blockquote><p>自wsl(Windows Subsystem on Linux)发布以来，许多性能已经得到了长足的进步。经过多年的发展，该项目从一个玩具项目发展成现在可以真正用于生产环境的项目，给需要使用Linux环境但是又不想脱离Windows便利生态的开发者们来说带来了福音。<br>wsl的图形性能也受到许多人的关注，特别是自微软2020build大会官方发布支持图形界面的wslg之后，wsl的图形性能发展进入了快车道。本文主要结合微软和英伟达提供的资料简要总结了一下wsl中调用GPU的原理以及使用GPU进行3D渲染加速和CUDA编程可能遇到的问题。</p></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>关于wsl是如何调用GPU加速的主要参考了这篇微软推出的<a href="https://devblogs.microsoft.com/directx/directx-heart-linux/">博客</a>。这篇博客里把大概的原理讲清楚了，简单来说就是hyperv虚拟机虚拟了一个<code>/dev/dxg</code>硬件，这个硬件通过WDDM(Windows Display Driver Model)(版本不低于2.9)共享了Windows端的显卡，然后在这个虚拟出的硬件上建立了一个Direct 3D的API实现了在Linux上使用Direct 3D(真的会有人在Linux上用这个吗。。。)。然后通过修改Mesa(OpenGL的开源实现)来实现了对OpenGL的支持(暂时还不支持vulkan)，以及让Nvidia单独推出了一个版本的CUDA调用D3D的API来实现通用计算。这样，显卡虚拟化最重要的图形流水线和计算流水线都得到了支持。其实下面这几张从官方博客中截取出来的图能够更好的说明这个调用关系。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/wslgpuperformance/dxg.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/wslgpuperformance/d3d.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/wslgpuperformance/opengl.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/wslgpuperformance/cuda.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/wslgpuperformance/directml.png"></p><p>可以看出这套方案还是很精妙的，是目前我已知的唯一不使用显卡直通，不适用英伟达专业卡的虚拟化接口等技术的虚拟化方案了。显卡直通会让宿主机无法使用显卡，而后者仅供专业卡使用。都有一些缺陷。而vmware等虽然能实现图形流水线从而进行3D加速，但是无法使用CUDA并行加速计算，因此难以用来进行科学计算等任务。这套方案的精妙之处是巧妙的使用了windows的显示驱动模型实现共享，以及让Nvidia单独推出了wsl版本的CUDA来支持计算流水线。了解原理后对出现故障的修复很有帮助。</p><h1 id="CUDA使用与性能分析"><a href="#CUDA使用与性能分析" class="headerlink" title="CUDA使用与性能分析"></a>CUDA使用与性能分析</h1><p>CUDA的使用还是比较简单，按照原理的描述，首先需要找一个支持WDDM2.9以上的显卡驱动(官网下载的最新版就支持)，然后去Nvidia的CUDA下载页面下载wsl专用的CUDA工具包。安装完成后分别在wsl和Windows上执行<code>nvidia-smi</code>命令，应该可以发现驱动版本是完全一致的。之后就一切按照正常的Linux环境配置就可以开启炼丹之旅了。由于wsl对内存进行了虚拟化，因此显存不够时可以使用内存作为虚拟显存使用，这么虽然慢一点，但是可以缓解小显存无法开大batch size的情况。<br>从原理上看增加了这么多调用确实会降低一些性能。这篇来自Nvidia的<a href="https://developer.nvidia.com/blog/leveling-up-cuda-performance-on-wsl2-with-new-enhancements/">技术报告</a>详细的测试了性能的损失。从这张图中可以看到随着batch_size的增加，wsl与原生linux之间的性能差距在逐渐缩小。这是由于额外开销只发生在调用GPU的阶段。所以尽可能的减少对GPU的调用，并让GPU充分忙碌，提升性能，这对所有的cuda编程都有效。（毕竟就算是原生系统，创建cuda核函数，复制内存等也需要时间）。总的来说，确实有很大的性能下降，但是也还在可接受范围内，此外nvidia在报告中也提到他们在改善性能，比最初发布的版本已经快很多了。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/wslgpuperformance/PyTorch-MNIST-sample-time.png"></p><h1 id="3D加速"><a href="#3D加速" class="headerlink" title="3D加速"></a>3D加速</h1><p>与上一段讲的通用计算不同，本章讲的图形渲染加速又是另一个故事了。这里主要介绍OpenGL的配置，目前来看想使用GPU加速直接下载最新版本的Mesa即可。但可能需要设置一下后端的名字。使用<code>MESA_D3D12_DEFAULT_ADAPTER_NAME</code>变量来指定。具体可以参考<a href="https://github.com/microsoft/wslg/wiki/GPU-selection-in-WSLg">这篇文档</a>。<br>安装完成后可以输入<code>glxinfo -B</code>命令来查看，如果输出有显卡的名字那么基本安装成功了，如果还是输出LLVM等字样那么说明还是使用CPU在计算。也可以通过<code>glxgears</code>程序来判断，如果在任务管理器中发现GPU占用上升，且CPU负载不高那么证明加速成功。当然显示情况也跟RDP有关，这里放一张窗口显示的框架。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/wslgpuperformance/wslg-wayland.png"></p><p>最后说一个任务管理器的奇怪特性，如果在设置中关闭了<code>GPU加速调度</code>选项，那么无法看到wsl的3D渲染对gpu的占用情况，但是任务管理器此时可以看到CUDA的占用，如果开启，可以看到wsl的3D渲染占用gpu了，但是CUDA的选项就消失了。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/wslgpuperformance/acc.png"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文大概总结了一下wslg的现状，详细内容建议阅读本文出现的几篇官方文档。总的来说wslg经过调教基本可以作为生产工具使用，但是还存在一些问题，比如各种lib需要手动安装，不支持vulkan，cuda效率不高等问题，相信只要微软不弃坑，这些问题都会逐渐得到解决。（至少比wsl1的技术路线好多了）</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;WSL中的GPU原理总结&quot;&gt;&lt;a href=&quot;#WSL中的GPU原理总结&quot; class=&quot;headerlink&quot; title=&quot;WSL中的GPU原理总结&quot;&gt;&lt;/a&gt;WSL中的GPU原理总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;自wsl(Windows</summary>
        
      
    
    
    
    
    <category term="wsl" scheme="https://blog.zzshub.cn/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>强化学习仿真器Raisim进行深度强化学习的初步尝试</title>
    <link href="https://blog.zzshub.cn/2023/07/26/DRL_RaisimGymTorch/"/>
    <id>https://blog.zzshub.cn/2023/07/26/DRL_RaisimGymTorch/</id>
    <published>2023-07-26T08:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习仿真器Raisim进行深度强化学习的初步尝试"><a href="#强化学习仿真器Raisim进行深度强化学习的初步尝试" class="headerlink" title="强化学习仿真器Raisim进行深度强化学习的初步尝试"></a>强化学习仿真器Raisim进行深度强化学习的初步尝试</h1><p>本文主要结合Raisim官方实例，介绍如何使用Raisim进行深度强化学习。本文主要参考了Raisim官方文档，以及Raisim的github仓库中的一些例子。部分内容使用AI辅助生成。</p><p>raisimGymTorch是raisim的Gym环境示例。还提供了一个简单的基于pytorch的RL框架，但它应该可以很好地与任何其他RL框架配合使用。该项目使用pybind11作为python接口，这样的好处是将矢量化环境包装在C++中，以便使用OpenMP在C++中完成并行化，这极大地提高了仿真速度。这里直接上官方的图。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/RaisimInstall/raisimGymTorch.png"></p><p>如图所示，该框架定义了<code>Environment</code>类型，在该类中完成环境的定义。然后<code>VectorizedEnvronment</code>将<code>Environment</code>进行矢量化，以便在C++中进行并行化。最后<code>riasim_gym.cpp</code>和<code>RaisimVecEnv.py</code>使用pybind11将上述C++环境封装成python包供其他RL框架调用。并行化的过程是在C++中完成的，因此可以大大提高仿真速度。</p><p>RaisimGymTorch的使用可以参考<a href="https://raisim.com/sections/RaisimGymTorch.html">官方文档</a>，但事实上该文档写的并不是很详细，因此本文将对其进行补充。也可以结合示例来进一步研究。</p><h1 id="RaisimGymTorch的目录结构"><a href="#RaisimGymTorch的目录结构" class="headerlink" title="RaisimGymTorch的目录结构"></a>RaisimGymTorch的目录结构</h1><p>RaisimGymTorch位于raisimGymTorch文件夹下，目录结构如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">│   CMakeLists.txt <span class="comment"># cmake文件, 用于编译但不要直接使用该文件编译，而是使用setup.py编译</span></span><br><span class="line">│   LICENSE</span><br><span class="line">│   README.md</span><br><span class="line">│   setup.py <span class="comment"># 用于编译raisimGymTorch的脚本文件，使用python setup.py develop编译</span></span><br><span class="line">│   __init__.py </span><br><span class="line">|</span><br><span class="line">├───raisimGymTorch <span class="comment"># raisimGymTorch库，核心文件夹</span></span><br><span class="line">│   ├───algo <span class="comment"># algorithm文件，自带了一个ppo算法，添加其他算法可以在这里添加</span></span><br><span class="line">│   │   │   __init__.py</span><br><span class="line">│   │   └───ppo</span><br><span class="line">│   ├───env <span class="comment"># env文件夹，用于存放环境文件，非常重要的文件夹，</span></span><br><span class="line">            <span class="comment"># 修改环境时需要修改这里的文件，</span></span><br><span class="line">            <span class="comment"># c++和python的交互也是通过这里的文件进行的</span></span><br><span class="line">│   │   │   Common.hpp</span><br><span class="line">│   │   │   debug_app.cpp <span class="comment"># c++部分封装成py库后还想调试需要用这个</span></span><br><span class="line">│   │   │   RaisimGymEnv.hpp <span class="comment"># 环境基类，自己定义环境需要继承这个类</span></span><br><span class="line">│   │   │   RaisimGymVecEnv.py <span class="comment"># VectorizedEnvironment封装成py之后的再次封装文件，</span></span><br><span class="line">                               <span class="comment"># 用于和其他RL框架配合使用，就是一个语法糖</span></span><br><span class="line">│   │   │   raisim_gym.cpp     <span class="comment"># 使用pybind11将VectorizedEnvironment封装成py库</span></span><br><span class="line">│   │   │   Reward.hpp      <span class="comment"># 奖励函数，用来记录奖励，具体的奖励函数需要自己定义</span></span><br><span class="line">│   │   │   VectorizedEnvironment.hpp <span class="comment"># 矢量化环境，用于并行化，这个文件不要修改，</span></span><br><span class="line">                                      <span class="comment"># 该文件将自定义的环境并行化</span></span><br><span class="line">│   │   │   Yaml.cpp        <span class="comment"># yaml文件读取，用于读取配置文件</span></span><br><span class="line">│   │   │   Yaml.hpp</span><br><span class="line">│   │   │   __init__.py</span><br><span class="line">│   │   │</span><br><span class="line">│   │   ├───bin <span class="comment"># c++编译出来的python包会出现在这里，也可以在cmakelists中修改</span></span><br><span class="line">│   │   └───envs <span class="comment"># 这里面就是各种环境了，可以参考这里的环境来自己定义环境</span></span><br><span class="line">│   │       └───rsg_anymal <span class="comment"># 这是一个四足机器人使用PPO算法的例子</span></span><br><span class="line">│   │               cfg.yaml</span><br><span class="line">│   │               Environment.hpp <span class="comment"># 这个Environment.hpp是自己定义的环境, 继承RaisimGymEnv.hpp</span></span><br><span class="line">│   │               runner.py       <span class="comment"># 这个是训练的主程序</span></span><br><span class="line">│   │               tester.py</span><br><span class="line">│   │</span><br><span class="line">│   ├───helper <span class="comment"># 杂项，包括了一些辅助函数，不用管</span></span><br><span class="line">│   │       raisim_gym_helper.py</span><br><span class="line">│   │       __init__.py</span><br><span class="line">│   │</span><br><span class="line">│   └───stable_baselines3 <span class="comment"># 按照stable_baseline3格式封装并行化环境的例子</span></span><br><span class="line">│           anymal.py <span class="comment"># 上述rsg_anymal例子的训练主程序，按照stable_baseline3的格式封装的</span></span><br><span class="line">│           RaisimSbGymVecEnv.py <span class="comment"># 这个文件是将VectorizedEnvironment封装成stable_baseline3格式的环境</span></span><br><span class="line">│           __init__.py</span><br><span class="line">│</span><br><span class="line">└───thirdParty <span class="comment"># 第三方库pybind11</span></span><br><span class="line">    └───pybind11</span><br></pre></td></tr></table></figure><h1 id="核心文件定义"><a href="#核心文件定义" class="headerlink" title="核心文件定义"></a>核心文件定义</h1><p>本部分介绍raisimGymTorch的核心文件，了解这些文件的结构有助于理解raisimGymTorch的工作原理，也有助于自己定义环境。核心文件的调用关系如下图所示，该图中<code>RaisimGymEnv</code>需要自行继承修改，其他文件不需要修改，但是可以了解其作用。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/RaisimInstall/Drawing1.svg"></p><h2 id="RaisimGymEnv-hpp"><a href="#RaisimGymEnv-hpp" class="headerlink" title="RaisimGymEnv.hpp"></a>RaisimGymEnv.hpp</h2><p>该文件是定义环境的基类，所有自定义的环境需要继承该类来定义。该类定义了环境的基本接口，包括了初始化，重置，step，以及其他一些接口。该类的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RaisimGymEnv</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">RaisimGymEnv</span> <span class="params">(std::string resourceDir, <span class="type">const</span> Yaml::Node&amp; cfg)</span> :</span></span><br><span class="line"><span class="function">      resourceDir_(std::move(resourceDir)), cfg_(cfg) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">RaisimGymEnv</span>() &#123; <span class="keyword">if</span>(server_) server_-&gt;<span class="built_in">killServer</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/////// implement these methods /////////</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 初始化函数，用于初始化环境</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 重置函数，用于重置环境</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">observe</span><span class="params">(Eigen::Ref&lt;EigenVec&gt; ob)</span> </span>= <span class="number">0</span>; </span><br><span class="line">  <span class="comment">// 观测函数，用于获取观测值，注意可观向量的维度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">step</span><span class="params">(<span class="type">const</span> Eigen::Ref&lt;EigenVec&gt;&amp; action)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// step函数，用于执行动作，返回奖励值，输入为动作，输出为奖励值</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isTerminalState</span><span class="params">(<span class="type">float</span>&amp; terminalReward)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 判断是否为终止状态，如果是终止状态，返回true，并将终止奖励值赋值给terminalReward</span></span><br><span class="line">  <span class="comment">////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/////// optional methods ///////</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">curriculumUpdate</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setSeed</span><span class="params">(<span class="type">int</span> seed)</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">////////////////////////////////</span></span><br><span class="line">  <span class="comment">//***部分代码省略***//</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="编译raisimGymTorch与定制化自己的环境"><a href="#编译raisimGymTorch与定制化自己的环境" class="headerlink" title="编译raisimGymTorch与定制化自己的环境"></a>编译raisimGymTorch与定制化自己的环境</h1><p>raisimGymTorch框架编译使用pybind11库将c++文件编译为python包，因此有必要了解一些pybind11的基本用法。pybind11的使用可以参考<a href="https://pybind11.readthedocs.io/en/stable/index.html">官方文档</a>，这里主要介绍一下如何编译raisimGymTorch，以及如何自定义环境。</p><p>使用 <code>python setup.py develop</code>命令即可编译raisimGymTorch，编译完成后会在raisimGymTorch文件夹下生成<code>build</code>文件夹，该文件夹下包含了编译出来的python包，在<code>raisimGymTorch/raisimGymTorch/env/bin</code>目录下会生成最终编译的包。编译完成后，可以在python中使用<code>import raisimGymTorch</code>来导入raisimGymTorch包。（在安装raisim到<code>/usr/local</code>后无需如官方教程所示指定<code>--CMAKE_PREFIX_PATH</code>路径）。</p><p>该编译脚本将会调用<code>CMakeLists.txt</code>文件完成编译，因此修改这个文件可以自定义编译内容。具体自定义路径的方法如下。</p><ul><li>修改包名称：您可以在 setup.py 中找到它（name&#x3D;’raisim_gym_torch’）。这是您将在 anaconda 环境的目录中找到的名称site_packages。</li><li>修改目录名称：这是您可以在顶部raisimGymTorch目录中找到的目录名称。默认名称也是 raisimGymTorch 目录。如有必要，请对其进行修改。然后，您必须修改 runner.py 和 CMakeLists.txt 标头中的目录。</li><li>修改二进制名称：这是环境目录的名称。默认名称为 rsg_anymal。如果更改目录名称，则必须重命名 runner.py 文件中的rsg_anymal。</li><li>修改环境名称：这是将从 Environment.hpp 文件生成的二进制文件的名称。默认名称是RaisimGymVecEnv。您可以在raisim_gym.cpp文件中找到它。如果更改它，您还必须更改文件名 runner.py 文件。</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文简要介绍了RaisimGymTorch的使用，对官方文档做了一些补充说明，以及对核心文件进行了简要介绍。方便后续查阅。Raisim也提供RaisimPy接口可以更方便的与python进行交互，但是由于RaisimPy是单线程的，因此在强化学习中使用的话速度会比较慢。此外Raisim还提供Matlab接口，但由于强化学习多使用python，因此这里不做介绍，有兴趣的可以自行研究。</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;强化学习仿真器Raisim进行深度强化学习的初步尝试&quot;&gt;&lt;a href=&quot;#强化学习仿真器Raisim进行深度强化学习的初步尝试&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="强化学习" scheme="https://blog.zzshub.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="仿真器" scheme="https://blog.zzshub.cn/tags/%E4%BB%BF%E7%9C%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>强化学习仿真器Raisim的安装，配置，与初步使用</title>
    <link href="https://blog.zzshub.cn/2023/07/26/DRL_RaisimInstall/"/>
    <id>https://blog.zzshub.cn/2023/07/26/DRL_RaisimInstall/</id>
    <published>2023-07-26T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习仿真器Raisim的安装，配置，与初步使用"><a href="#强化学习仿真器Raisim的安装，配置，与初步使用" class="headerlink" title="强化学习仿真器Raisim的安装，配置，与初步使用"></a>强化学习仿真器Raisim的安装，配置，与初步使用</h1><blockquote><p><strong>写在前面</strong> – 最近入坑了强化学习，看了一些基础理论后觉得需要实操一下，于是便研究了一下Raisim这个仿真器。这个仿真器使用的人较少，网上资料也不多，所以在这里记录一下，以便后续查阅。不过说实话，新入强化学习的坑还是建议从OpenAI的gym(gymnasium)看起，毕竟资料多，而且也有很多成熟的算法可以直接使用。不像Raisim是一个单纯的仿真器，gym是一个完整的强化学习框架，可以直接使用，以及配合”stable baseline3”使用可以很快速的将demo跑起来。不过Raisim的优点也很明显，就是仿真速度快，而且可以直接使用C++进行编程，并利用OpenMP并行加速。所以在一些对速度要求较高的场景下，Raisim还是很有优势的。</p></blockquote><p>本文主要介绍了Raisim仿真器的安装，配置，并简要介绍API，以及如何使用Raisim仿真器来进行强化学习仿真环境的搭建。本文主要参考了Raisim官方文档，以及Raisim的github仓库中的一些例子。部分内容使用AI辅助生成。</p><h1 id="Raisim简介和安装"><a href="#Raisim简介和安装" class="headerlink" title="Raisim简介和安装"></a>Raisim简介和安装</h1><p>Raisim是由ETH Zurich的Robotics and Perception Group开发的一个开源的跨平台物理仿真器，主要用于机器人的仿真。该仿真器的主要特点是仿真速度快，而且可以直接使用C++进行编程，并利用OpenMP并行加速。该仿真器使用CPU进行仿真，官方地址为：<a href="https://raisim.com/">https://raisim.com/</a>。</p><p>该仿真器的安装较为简单，基本上只需要下载源码，然后编译即可。该仿真器在分发的时候直接分发的二进制文件，因此编译的过程基本就是在编译demo，以及一些测试用例。安装过程遵循官方文档即可，所需依赖包括eigen和cmake，Windows平台使用vs2022编译实测通过，但由于gym对Windows的支持不太好，因此建议使用Linux平台进行开发，这里最终选择了WSL2下的Ubuntu22.04开发。在官方的安装教程中提到了需要设置<code>&quot;WORKSPACE&quot;</code>和<code>&quot;LOCAL_INSTALL&quot;</code>环境变量，但是实际测试发现这些环境变量不需要设置，直接安装即可。Linux平台执行<code>make install</code>命令后会将raisim的头文件和库文件,以及cmake文件安装到<code>/usr/local</code>文件夹下，这样后续使用就无需使用<code>--CMAKE_PREFIX_PATH</code>指定路径了。</p><h2 id="Raisim目录结构"><a href="#Raisim目录结构" class="headerlink" title="Raisim目录结构"></a>Raisim目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name</span><br><span class="line">----</span><br><span class="line">cmake       <span class="comment"># cmake文件</span></span><br><span class="line">DEVELOPERS_ONLY</span><br><span class="line">docs        <span class="comment"># 文档</span></span><br><span class="line">examples    <span class="comment"># 例子</span></span><br><span class="line">raisim      <span class="comment"># raisim库二进制文件和头文件</span></span><br><span class="line">raisimGymTorch <span class="comment"># raisimGymTorch库和实例，用于和gym，以及pytorch配合使用</span></span><br><span class="line">raisimMatlab</span><br><span class="line">raisimPy    <span class="comment"># raisim的python接口</span></span><br><span class="line">raisimUnity <span class="comment"># 基于unity3D的仿真器</span></span><br><span class="line">raisimUnityOpengl <span class="comment"># 基于unity3D的仿真器，使用opengl渲染（linux下使用）</span></span><br><span class="line">rsc         <span class="comment"># 资源文件，主要是例子里的各种模型文件</span></span><br><span class="line">thirdParty  <span class="comment"># 第三方库，包括了Eigen和pybind11（共raisimGymTorch使用）</span></span><br><span class="line">CMakeLists.txt</span><br><span class="line">COPYING</span><br><span class="line">LICENSE.md</span><br><span class="line">package.xml</span><br><span class="line">README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Raisim激活"><a href="#Raisim激活" class="headerlink" title="Raisim激活"></a>Raisim激活</h2><p>激活部分建议参阅官方文档的激活章节<a href="https://raisim.com/sections/License.html">https://raisim.com/sections/License.html</a>, 由于raisim使用了Google Doc来填写申请，因此可能需要一些神奇工具才能打开网页。注意申请学术账户可以使用自己的google账户来申请，但是后续需要填写学校邮箱，激活码将发给学校邮箱内。学术账户最多可以申请10个，应该够用了。</p><p>将通过电子邮件收到的激活密钥重命名为 activation.raisim。将该文件保存在 <code>&lt;YOUR-HOME-DIR&gt;/.raisim/</code> 中。在 Linux 和 Mac 中，这是<code>/home/&lt;YOUR-USERNAME&gt;/.raisim/</code>。在 Windows 中，这是 <code>C/Users/&lt;YOUR-USERNAME&gt;/.raisim/</code>（您可能不使用 C 作为主目录）。</p><h1 id="Raisim的Visualizers"><a href="#Raisim的Visualizers" class="headerlink" title="Raisim的Visualizers"></a>Raisim的Visualizers</h1><p>Raisim目前包含3个Visualizers，分别是raisimUnity，RaisimUnreal，和RaisimOgre。</p><ul><li>如果你只在Linux上工作，并且你想自定义可视化工具 - RaisimOgre。</li><li>如果您想要一个适用于所有操作系统的简单解决方案 - RaisimUnity。</li><li>如果你只有一个集成的GPU，并且你在Linux上工作 - RaisimUnityOpenGL。</li><li>如果您想要最通用的解决方案，如果您想为出版物提供良好的图形，或者如果您在强化学习项目中使用视觉数据 – RaisimUnreal。</li></ul><p>本文测试后认为raisimUnity效果最好，因此本文主要介绍raisimUnity的使用。RaisimUnity安装在raisimUnity文件夹下，可以直接打开使用。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/RaisimInstall/1.png"></p><p>在仿真器运行后(后续讲解如何使用<code>Raisim::Server</code>类建立服务端)点击连接就可以查看仿真了，默认端口号是8080，支持连接到远程仿真器。仿真时可以使用键盘<code>QWEASD</code>按钮和鼠标控制视角。下面总结一下仿真过程中会遇到的一些问题。</p><h2 id="Visualizers遇到的坑"><a href="#Visualizers遇到的坑" class="headerlink" title="Visualizers遇到的坑"></a>Visualizers遇到的坑</h2><ul><li>首先遇到的坑是模型资源加载失败，这个问题有时候会出现有时候又不会出现，坑了我很久，尝试过修改模型里的资源文件为绝对路径等方法，但是都没有解决。<strong>最后发现在RaisimUnity中可以指定模型路径，只需要在这里面添加模型的文件夹就可以解决这个问题了。</strong> 该问题在访问远程仿真器时必然会出现，因此需要注意。</li></ul><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/RaisimInstall/2.png"></p><ul><li><p>网络防火墙问题，如果你的电脑上有防火墙，那么需要将raisimUnity添加到防火墙的白名单中，否则会导致无法连接到远程仿真器，在Windows上列入白名单后仍可能会出现问题，建议重启或者关闭防火墙后使用。</p></li><li><p>wslg问题，如果使用的是wsl运行仿真器，那么请不要尝试在wslg中运行RaisimUnity，wslg的图形对3D类应用程序支持欠佳（包括ros的rviz也是）（关闭wslg的缩放会缓解该问题，wslg目前尚不支持vulkan API, 对OpenGL支持还行），会导致RaisimUnity无法正常运行。建议还是在Windows上运行Visualizers，将wsl视为远端服务器。</p></li></ul><h1 id="Raisim的API"><a href="#Raisim的API" class="headerlink" title="Raisim的API"></a>Raisim的API</h1><p>Raisim的API文档可以在<a href="https://raisim.com/">https://raisim.com/</a>查看，这里简单介绍一下Raisim的API。</p><h2 id="World类"><a href="#World类" class="headerlink" title="World类"></a>World类</h2><p>World类是Raisim仿真器的核心类，所有的仿真都是在World类中进行的。所有在同一个World对象下的物体支持碰撞检查。World类可以使用XML文件来初始化，也可以使用代码来初始化。World类也可以使用MJCF(MuJoCo格式)来初始化，<strong>但是实际测试效果不好，不建议使用。</strong> 可以将Objects类等注册到World类中来仿真物体的运动和设置摩擦力，弹性形变等属性。</p><p>World类中使用<code>integrate()</code>方法来完成一个时间片的更新。</p><blockquote><p>integrate the world It is equivalent to call <code>integrate1(); integrate2();</code>.<br><code>integrate1()</code> performs 1) deletion contacts from previous time step 2) collision detection 3) register contacts to each body 4) calls “preContactSolverUpdate1()” of each object.<br><code>integrate2()</code> performs 1) calls “preContactSolverUpdate2()” of each body 2) run collision solver 3) calls “integrate” method of each object.</p></blockquote><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>有三种可用的类型。</p><ul><li>DYNAMICS：可以有速度，质量有限（如待仿真的机器人）。</li><li>KINEMATIC：可以有速度，有无限的质量（例如，传送带）。</li><li>STATIC：不能有速度，有无限的质量（例如，墙壁）。<br>这些物体可以指定为SingleBodyObject或者ArticulatedSystem。前者表示一个单一的物体如球，立方体等，而后者是一个带有铰接的系统，可以从URDF文件读取。可以进行逆向运动学解算或者使用PD控制器控制，具体请参阅API手册。</li></ul><h2 id="材质系统"><a href="#材质系统" class="headerlink" title="材质系统"></a>材质系统</h2><p>在RaiSim中，所有材料属性都与材料对相关联。目前，RaiSim中使用了五种材料属性。</p><blockquote><ul><li><strong>Coefficient of friction ($\mu\ge 0$)</strong>: This defines how much friction is applied between the two materials.</li><li><strong>Coefficient of restitution ($c_r\ge 0$)</strong>: How bouncy the material pair is.</li><li><strong>Restitution Threshold ($r_{th}\ge 0$)</strong>: If the impact velocity is smaller than this number, objects do not bounce off.</li><li><strong>Coefficient of static friction ($\mu_{s}\ge \mu$)</strong>: If specified, it defines how much friction is applied when the relative velocity between the contact points is very small. By default, it is the same as the coefficient of friction.</li><li><strong>Velocity threshold for static friction ($v_s \ge 0$)</strong>: Must be specified if the coefficient of static friction is specified. If the relative velocity is bigger than this value, than static friction is not used. Otherwise, the effective coefficient of friction is interpolated between the two coefficients.</li></ul></blockquote><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/RaisimInstall/materials.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/RaisimInstall/materials.gif"></p><h2 id="Server类"><a href="#Server类" class="headerlink" title="Server类"></a>Server类</h2><p>使用<code>Raisim::Server</code>类可以创立服务器供Visualizers监听。使用<code>inline explicit RaisimServer(World *world)</code>方法将World类绑定到server上，之后使用<code>inline explicit RaisimServer(World*world)</code>方法即可开始监听。<strong>注意Server与Visualizers的通信和实际仿真过程发生在不同的线程上，因此需要一些锁来进行线程同步</strong>。</p><p>例如在更新World的过程中使用Server类的<code>lockVisualizationServerMutex(),unlockVisualizationServerMutex()</code>来加锁防止在更新World时读取数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节选自 examples/server/balls.cpp</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">    <span class="built_in">RS_TIMED_LOOP</span>(<span class="built_in">int</span>(world.<span class="built_in">getTimeStep</span>()*<span class="number">1e6</span>))</span><br><span class="line">    server.<span class="built_in">lockVisualizationServerMutex</span>(); <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">if</span> (i % interval == <span class="number">0</span> &amp;&amp; j &lt; numBalls) &#123;</span><br><span class="line">      <span class="keyword">auto</span>* ball = world.<span class="built_in">addSphere</span>(<span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line">      ball-&gt;<span class="built_in">setPosition</span>(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">0.8</span>);</span><br><span class="line">      ball-&gt;<span class="built_in">setVelocity</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      ball-&gt;<span class="built_in">setAppearance</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    server.<span class="built_in">applyInteractionForce</span>();  <span class="comment">//更新交互力，这句话不能删除，否则会出问题</span></span><br><span class="line">    world.<span class="built_in">integrate</span>(); <span class="comment">//更新World</span></span><br><span class="line">    server.<span class="built_in">unlockVisualizationServerMutex</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>或者使用<code>integrateWorldThreadSafe()</code>方法来更新World，该方法会自动加锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节选自 examples/server/meshes.cpp</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">RS_TIMED_LOOP</span>(<span class="built_in">int</span>(world.<span class="built_in">getTimeStep</span>()*<span class="number">1e6</span>))</span><br><span class="line">    server.<span class="built_in">integrateWorldThreadSafe</span>();</span><br><span class="line">    <span class="comment">//相当于执行如下代码</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    server.lockVisualizationServerMutex();</span></span><br><span class="line"><span class="comment">    server.applyInteractionForce();</span></span><br><span class="line"><span class="comment">    world.integrate();</span></span><br><span class="line"><span class="comment">    server.unlockVisualizationServerMutex();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文初步介绍了Raisim的安装，配置，以及API，以及如何使用Raisim仿真器来进行强化学习仿真环境的搭建。Raisim的API文档可以在<a href="https://raisim.com/">https://raisim.com/</a>查看，本文简单介绍一下Raisim的API，本文还介绍了raisimUnity的使用。在下一篇文章中，将介绍如何使用RaisimGymTorch配合stable_baseline3, gymnasium(Gym), Pytorch等来搭建强化学习仿真环境。</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;强化学习仿真器Raisim的安装，配置，与初步使用&quot;&gt;&lt;a href=&quot;#强化学习仿真器Raisim的安装，配置，与初步使用&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="强化学习" scheme="https://blog.zzshub.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="仿真器" scheme="https://blog.zzshub.cn/tags/%E4%BB%BF%E7%9C%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Image Segmentation via Spectral Clustering</title>
    <link href="https://blog.zzshub.cn/2023/05/20/Image_Segmentation_via_Spectral_Clustering/"/>
    <id>https://blog.zzshub.cn/2023/05/20/Image_Segmentation_via_Spectral_Clustering/</id>
    <published>2023-05-20T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Image-Segmentation-via-Spectral-Clustering"><a href="#Image-Segmentation-via-Spectral-Clustering" class="headerlink" title="Image Segmentation via Spectral Clustering"></a>Image Segmentation via Spectral Clustering</h1><blockquote><p><strong>Abstract</strong>-Image Segmentation is a classic computer vision problem, which is also one of the foundation stones for many computer vision applications, e.g., 3D reconstruction, object tracking. This paper implemented two classic image segmentation methods via spectral clustering. Namely, the image segmentation based on K-means clustering and image segmentation based on normalized cuts and spectral clustering. Although nowadays most image segmentation methods are based on deep learning, the traditional solution can still be used in industrial environments, due to the computational cost. In this paper, we implemented two image segmentation methods using C++, and conduct testing on CIFAR-10 dataset. Solid experiments on the datasets demonstrate the robustness and effectiveness of the two implemented algorithms.</p></blockquote><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Image segmentation is a computer vision task that involves dividing an image into meaningful and distinct regions or objects. It aims to partition an image into semantically cohesive regions based on similarities in color, texture, or other visual properties. It plays a crucial role in various applications, such as medical imaging, autonomous driving, object recognition, and scene understanding. By accurately delineating boundaries and identifying individual elements within an image, image segmentation enables advanced analysis, object tracking, and understanding of visual content. This process not only aids in extracting meaningful information from images but also paves the way for numerous downstream tasks and applications in diverse fields.</p><h2 id="Related-Works"><a href="#Related-Works" class="headerlink" title="Related Works"></a>Related Works</h2><p>As a classic computer vision task, the image segmentation problem has been widely studied during recent decades. Among all methods, the solutions can be categorized into two major aspects. Namely, traditional methods, and the deep learning-based methods. The former has received extensive attention in the early stage of image segmentation and requires fewer computing resources than methods based on deep learning, it is still widely used in scenes where the image background is simple but computing resources are limited. The latter is currently a research hotspot. With the increase in the complexity of the network model, the image segmentation effect is still on the rise.</p><h3 id="Traditional-Methods"><a href="#Traditional-Methods" class="headerlink" title="Traditional Methods"></a>Traditional Methods</h3><p>These traditional approaches often rely on handcrafted features, such as color, texture, or edge information, combined with sophisticated algorithms. These methods can be categorized as thresholding methods, edge-based methods, region-based methods, Clustering-based methods. One commonly used technique is thresholding, where pixel intensities are compared to a fixed threshold value to distinguish between foreground and background regions [1][2]. The threshold methods include global Thresholding, which use one threshold for whole image, variable thresholding, where the threshold value T can vary over the image, and multiple thresholding. This method is simple and computationally efficient, but it struggles with images containing complex backgrounds or varying lighting conditions. Another approach is region-based segmentation, which groups pixels based on their similarity in color, texture, or other features [3][4]. Popular algorithms like K-means clustering and mean-shift segmentation fall under this category. Region-based methods offer good results when dealing with homogeneous regions, but they often struggle with accurately capturing object boundaries and handling overlapping regions. Clustering-based algorithms, such as graph cuts [5], leverage graph theory to model image segmentation as an optimization problem. These methods excel in capturing object boundaries and handling irregular shapes. However, they require prior knowledge or user interactions to define the initial seeds or cost functions, limiting their applicability in fully automated scenarios. Additionally, edge-based techniques, such as the Canny edge detector or active contours, focus on detecting and tracing object boundaries using edge information [6]. While these methods can achieve precise boundaries, they may struggle with noise, incomplete edges, or complex object shapes. </p><h3 id="Deep-Learning-based-Methods"><a href="#Deep-Learning-based-Methods" class="headerlink" title="Deep Learning-based Methods"></a>Deep Learning-based Methods</h3><p>Nowadays most image segmentation solutions are based on deep learning, since it provides significantly better results than traditional methods. Long et al. introduced Fully Convolutional Networks (FCNs), a significant advancement in deep learning-based models for semantic image segmentation [7]. FCNs exclusively consist of convolutional layers, allowing them to generate segmentation maps that match the size of the input image. Chen et al. developed a semantic segmentation algorithm by combining Convolutional Neural Networks (CNNs) with fully connected Conditional Random Fields (CRFs) [8]. Their approach exhibited superior accuracy in localizing segment boundaries compared to previous methods. Schwing and Urtasun proposed a deep structured network that integrates CNNs and fully connected CRFs for semantic image segmentation [9]. Through joint training, their model achieved promising results on the challenging PASCAL VOC 2012 dataset. Badrinarayanan et al. presented SegNet, an architecture based on fully convolutional encoder-decoder networks for image segmentation [10]. SegNet’s segmentation engine comprises an encoder network, identical in topology to VGG16’s 13 convolutional layers, and a corresponding decoder network followed by a pixel-wise classification layer. Taking inspiration from the success of large models in natural language processing [11], researchers have also explored their application in image segmentation. Meta AI proposed the “Segment Anything” model, which is designed and trained to be promptable, enabling it to transfer knowledge to new image distributions and tasks.</p><h2 id="Main-Contributions"><a href="#Main-Contributions" class="headerlink" title="Main Contributions"></a>Main Contributions</h2><p>The main contribution of this paper is as follows:</p><ul><li>A C plus plus implementation of K-means clustering for color-based image segmentation is provided in this project.</li><li>A C plus plus implementation of normalized-cut algorithm and spectral clustering image segmentation is provided in this project.</li><li>Solid experiments based on our implemented solutions are conducted, and comparisons with each algorithm are presented.</li></ul><p>The rest of the paper is organized as follows. Related works are presented in section II. Section III is the problem statement, the mathematical description of the problem is introduced. The details of the implemented two segmentation algorithms are in section IV, and experiments are conducted, and results are shown in section V, and in section VI we draw conclusions and future improvements.</p><h1 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h1><p>This paper focuses on images segmentation problem. Given $n$ unlabeled data points $ {x_1,x_2,\ldots,x_n} $ with $ x_i\in R^d $ and number of desired classes $K$ with no labels given this paper is trying to find cohesive clusters so that similar input data can be grouped. And the intra-class similarity is high, while the inter-class similarity is low.</p><h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><h2 id="K-means-Clustering"><a href="#K-means-Clustering" class="headerlink" title="K-means Clustering"></a>K-means Clustering</h2><p>K-means is a popular clustering algorithm used in image segmentation. It aims to partition an image into distinct regions based on similarity of pixel values. K-means starts by randomly selecting $K$ initial cluster centers. Each pixel in the image is then assigned to the cluster with the closest center, based on the Euclidean distance between the pixel’s color values and the center’s color values. We use pseudo-random number generator based on Mersenne Twister [12] to generate $k$ color vectors from 0-255 in our implementation. After the initial assignment, the algorithm calculates the mean color values ${\mu_j\in R^3:1\le j\le K}$ for each cluster, based on the pixels assigned to it. These mean values become the new cluster centers. </p><p>$$<br>C_i&#x3D;\arg{\min_{1\le j\le K}{d}}\left(x_i,\mu_j\right)<br>$$</p><p>$$<br>\mu_j&#x3D;\frac{\sum_{i&#x3D;1}^{n}{1{c_i&#x3D;j}x_i}}{\sum_{i&#x3D;1}^{n}{1{c_i&#x3D;j}}}<br>$$</p><p>The assignment and recalculation steps are repeated iteratively until convergence, when the cluster centers no longer change significantly. Once convergence is reached, the image pixels are classified into K segments based on their final cluster assignments. Each segment represents a distinct region of similar pixel values. By varying the number of clusters K, the algorithm can produce different levels of segmentation granularity. To get better segmentation result, our method will perform k-means segmentation for one image multiple times with random generated initial values, and then find the best result among these segmentation result. Namely, find the best result corresponding to the minimum g, where $g&#x3D;\sum_{i}|samples_i-centers_{labels_i}|^2$.</p><h2 id="Normalized-cut-algorithm"><a href="#Normalized-cut-algorithm" class="headerlink" title="Normalized-cut algorithm"></a>Normalized-cut algorithm</h2><p>The normalized-cut algorithm considers the image as a graph and performs graph cut to segment images in to two clusters. Represent the image as a graph $G\left(V,E\right)$, where vertex $V$ represents each pixel in the image, and weighted edge $E$ represents the connectivity between pixels. Let two disjoint sets be $A, B$, where $A \cap B\ &#x3D;V, A \cup B &#x3D;\emptyset$. Then, the dissimilarity between the two pieces can be measured by calculating the combined weight of the removed edges. In graph theory, this measurement is referred to as the “cut”.</p><p>$$cut\left(A,B\right)&#x3D;\sum_{u\in A,v\in B}\omega\left(u,v\right)$$</p><p>The image segmentation problem then can be transformed into finding the minimum cut of the graph. However, the minimum cut criteria will result in cutting small sets of isolated nodes in the graph, which are isolated pixels in the image. To avoid this issue, the Normalized cut introduced a novel metric for quantifying the disassociation between two groups. Instead of solely considering the total weight of edges connecting the partitions, they metric calculates the cut cost relative to the overall edge connections involving all nodes in the graph. </p><p>$$<br>Ncut\left(A,B\right)&#x3D;\frac{cut\left(A,B\right)}{asso\left(A,V\right)}+\frac{cut\left(A,B\right)}{asso\left(B,V\right)}<br>$$</p><p>Where $asso\left(A,V\right)&#x3D;\sum_{u\in A,t\in V}\omega\left(u,t\right)$ is the sum up connection from nodes in A to all nodes in the graph, and $asso\left(B,V\right)$ is defined similarly. Let x be an $N&#x3D;\left|V\right|$ vector, and $x_i&#x3D;1$ when $V_i\in A, x_i&#x3D;-1 when V_i\in B$. $d\left(i\right)&#x3D;\sum_{j}\omega\left(i,j\right)$ is the sum up connection from $V_i$ to other vertices. The $Ncut\left(A,B\right)$ can be rewritten as follows.</p><p>$$<br>Ncut(A, B)&#x3D; \frac{\sum_{\left(\boldsymbol{x_i}&gt;0, \boldsymbol{x_j}&lt;0\right)}-w_{ij} \boldsymbol{x_i} \boldsymbol{x_j}}{\sum_{\boldsymbol{x_i}&gt;0} \boldsymbol{d_i}}<br> +\frac{\sum_{\left(\boldsymbol{x_i}&lt;0, \boldsymbol{x_j}&gt;0\right)}-w_{ij} \boldsymbol{x_i} \boldsymbol{x_j}}{\sum_{\boldsymbol{x_i}&lt;0} \boldsymbol{d_i}}<br>$$</p><p>Let <strong>D</strong> be an $N\times N$ diagonal matrix, <strong>W</strong> be an $N\times N$ symmetrical matrix with $W\left(i,j\right)&#x3D;\omega_{ij}$. Then the $Ncut$ function can be rewritten as follows.</p><p>$$<br> Ncut\left(A,B\right)&#x3D;\frac{\left(\boldsymbol{x}^T(\mathbf{D}-\mathbf{W}) \boldsymbol{x}+\mathbf{1}^T(\mathbf{D}-\mathbf{W}) \mathbf{1}\right)}{k(1-k) \mathbf{1}^T \mathbf{D} \mathbf{1}}+\frac{2(1-2 k) \mathbf{1}^T(\mathbf{D}-\mathbf{W}) \boldsymbol{x}}{k(1-k) \mathbf{1}^T \mathbf{D} \mathbf{1}}<br>$$</p><p>$$<br>&#x3D;\frac{[(\mathbf{1}+\boldsymbol{x})-b(\mathbf{1}-\boldsymbol{x})]^T(\mathbf{D}-\mathbf{W})[(\mathbf{1}+\boldsymbol{x})-b(\mathbf{1}-\boldsymbol{x})]}{b \mathbf{1}^T \mathbf{D} \mathbf{1}}<br>$$</p><p>Where $b&#x3D;\frac{k}{1-k}$,  $k&#x3D;\frac{\sum_{x_i&gt;0}{\boldsymbol{d_i}}}{\sum_{i}{\boldsymbol{d_i}}}$<br>Then putting everything together, the minimum cut can be formulated as follows.</p><p>$$<br>\min \boldsymbol{x} N \operatorname{cut}(\boldsymbol{x})&#x3D;\min y \frac{\boldsymbol{y}^T(\boldsymbol{D}-\boldsymbol{W}) \boldsymbol{y}}{\boldsymbol{y}^T \boldsymbol{D} \boldsymbol{y}}<br>$$</p><p>The normalized cut problem can be solved by calculating the second smallest eigenvector of the following equation.</p><p>$$<br>\left(\boldsymbol{D}-\boldsymbol{W}\right)\boldsymbol{y}&#x3D;\lambda\boldsymbol{Dy}<br>$$</p><p>$$<br>\mathbf{D}^{-\frac{1}{2}}(\mathbf{D}-\mathbf{W}) \mathbf{D}^{-\frac{1}{2}} \boldsymbol{z}&#x3D;\lambda \boldsymbol{z}<br>$$</p><p>Where $\boldsymbol{z}&#x3D;\boldsymbol{D}^\frac{1}{2} \boldsymbol{y}$.<br>Finally, recursively calling the process for multiple partition.</p><h1 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h1><p>In the experimental section, this paper initially presents the implementation process of the algorithm and the selection of certain parameters. Subsequently, we provide a detailed comparison of the performance and shortcomings of the two algorithms.</p><h2 id="System-Setup"><a href="#System-Setup" class="headerlink" title="System Setup"></a>System Setup</h2><p>All algorithms in this paper are implemented in C++. The chosen data-set for testing is the CIFAR-10 data-set, which consists of 6000 images with a resolution of 32x32 pixels. This data-set is primarily used in the field of image classification, providing 10 class labels but no ground truth segmentation for the images. The data used in this paper is in binary format. Initially, the C++ standard library’s binary file I&#x2F;O library is employed to read the binary data. Then, the data is segmented according to the format provided by the data-set, and the segmented data is stored in OpenCV Mats for further processing.</p><p>For the k-means segmentation algorithm, the initial cluster centers are generated using the Mersenne Twister-based pseudo-random number generator mt19937, which ensures good clustering results. To maximize the clustering effectiveness, the algorithm is iterated 100 times with different random initialization in 10 attempts. Experimental results have shown that this configuration yields stable results, minimizing the impact of random initialization and achieving optimal segmentation outcomes.</p><p>In the Normalized Cut algorithm for image segmentation, the definition of edge weights is as follows.</p><p>$$<br>w_{ij}&#x3D; e^{\frac{-\left|F_{(i)}-F_{(j)}\right|_2^2}{\sigma_I^2}} *<br>$$</p><p>$$<br>\begin{cases}&#x3D;e^{\frac{-\left|X_{(i)}-X_{(j)}\right|_2^2}{\sigma_X^2}} &amp; \text { if }|X(i)-X(j)|_2&lt;r \ , &#x3D;0 &amp; \text { otherwise. }\end{cases}<br>$$</p><p>where, $r$ represents the pixel neighborhood radius. The vector $F(i)$ is defined as<br>$[v, v * s * sin(h), v * s * cos(h)]^T$. Where h, s, and v are the three components of the image’s HSV color space. It is important to note that the HSV definition in OpenCV differs from the standard definition, requiring special handling. The vector X(i) represents the coordinates of the pixel. In this experiment, we set $\sigma_I &#x3D; 0.01, \sigma_X &#x3D; 4.0$, and $r &#x3D; 5$. The color space conversion and computation of feature values in this implementation utilize functions provided by OpenCV.</p><h2 id="Segmentation-Experiment"><a href="#Segmentation-Experiment" class="headerlink" title="Segmentation Experiment"></a>Segmentation Experiment</h2><p>This section will show the segmentation result for airplane, house, and deer images.</p><center>    <table>        <tr>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/ori.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/k.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/c.png"></td>        </tr>        <tr>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/ori2.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/k2.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/c2.png"></td>        </tr>    </table>    Figure 1: Airplane Segmentation Result</center><br>In the given airplane images shown in Figure.1, both algorithms achieved good classification results due to the simple background. However, the k-means-based algorithm, which clusters based solely on color, may result in splitting an airplane into multiple disconnected regions, affecting the segmentation outcome. On the other hand, the Normalized Cut method considers both distance and color in edge weights, leading to a more cohesive segmentation of the airplane and yielding better results.<p>The segmentation results of the horse, as shown in Figure.2, demonstrate that both algorithms experience a certain degree of performance degradation as the complexity of the background increases. </p><center>    <table>        <tr>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/ori5.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/k5.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/c5.png"></td>        </tr>        <tr>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/ori6.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/k6.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/c6.png"></td>        </tr>    </table>    Figure 2: Horse Segmentation Result</center><br>The segmentation results of the deer, as shown in figure.3, indicate that as the background complexity increases and includes multiple colors with significant differences, the performance of the k-means clustering model deteriorates significantly. On the other hand, the segmentation method based on Normalized Cut performs relatively well because it takes into account minimizing outliers during segmentation and incorporates both positional and color information in the edge weights.<center>    <table>        <tr>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/ori3.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/k3.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/c3.png"></td>        </tr>        <tr>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/ori4.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/k4.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/c4.png"></td>        </tr>    </table>    Figure 3: Deer Segmentation Result</center><br><h2 id="Failure-Analysis"><a href="#Failure-Analysis" class="headerlink" title="Failure Analysis"></a>Failure Analysis</h2><p>As the background complexity increases and the target region becomes less distinct, both classification algorithms struggle to achieve satisfactory results. The classification outcomes for complex backgrounds are displayed in Figure.4.</p><center>    <table>        <tr>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/bad1.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/badk1.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/badc1.png"></td>        </tr>        <tr>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/bad2.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/badk2.png"></td>            <td style="border: none;"><img src = "https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/badc2.png"></td>        </tr>    </table>    Figure 4: Segment failed images</center><br>The segmentation difficulty is high for the above images, and even for the human eye, it is challenging to distinguish them at low resolution. Both algorithms show poor segmentation performance, but Normalized Cut can significantly reduce the fragmentation of the segmentation.<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this work, we implemented two image segmentation approaches. First, we implemented an image segmentation algorithm based on K-means clustering, and we clustered using different color features, we mainly discuss the case of clustering into 4 categories. Secondly, this paper implements the algorithm based on Normalized-cut algorithm for clustering. We discuss the situation of using this algorithm to cluster into two categories at beginning. Then, by introducing recursive hierarchical clustering, we extend the clustering algorithm to multiple Class clustering, and discuss the case of clustering into 4 classes. Experiments show that the K-means algorithm has a better clustering effect in images with simple background and obvious color distribution, while the effect of Normalized-cut algorithm is more effective in images with uniform color distribution and no obvious distribution. However, for images with complex backgrounds, both types of segmentation algorithms perform poorly. Due to the lack of true values in this data set, it is difficult to do quantitative analysis on the clustering effect. In addition, this paper does not consider the sparse structure of the matrix when solving the eigenvalues, and still uses the general eigenvalue solving algorithm, the calculation performance has a certain loss. These issues still require further research in the future.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Y.-J. Zhang, “An overview of image and video segmentation in the last 40 years,” Advances in Image and Video Segmentation, pp. 1–16, 2006.<br>[2] T. Lindeberg and M.-X. Li, “Segmentation and classification of edges using minimum description length approximation and complementary junction cues,” Computer Vision and Image Understanding, vol. 67, no. 1, pp. 88–98, 1997.<br>[3] M. R. Khokher, A. Ghafoor, and A. M. Siddiqui, “Image segmentation using multilevel graph cuts and graph development using fuzzy rule-based system,” IET image processing, vol. 7, no. 3, pp. 201–211, 2013.<br>[4] N. Senthilkumaran and R. Rajesh, “Image segmentation-a survey of soft computing approaches,” in 2009 International Conference on Advances in Recent Technologies in Communication and Computing. IEEE, 2009, pp. 844–846.<br>[5] J. Shi and J. Malik, “Normalized cuts and image segmentation,” in Proceedings of IEEE Computer Society Conference on Computer Vision and Pattern Recognition, Jun. 1997, pp. 731–737, iSSN: 1063-6919.<br>[6] S. S. Al-Amri, N. Kalyankar, and S. Khamitkar, “Image segmentation by using edge detection,” International journal on computer science and engineering, vol. 2, no. 3, pp. 804–807, 2010.<br>[7] J. Long, E. Shelhamer, and T. Darrell, “Fully convolutional networks for semantic segmentation,” in Proceedings of the IEEE conference on computer vision and pattern recognition, 2015, pp. 3431–3440.<br>[8] L.-C. Chen, G. Papandreou, I. Kokkinos, K. Murphy, and A. L. Yuille, “Semantic image segmentation with deep convolutional nets and fully connected crfs,” arXiv preprint arXiv:1412.7062, 2014.<br>[9] A. G. Schwing and R. Urtasun, “Fully connected deep structured networks,” arXiv preprint arXiv:1503.02351, 2015.<br>[10] V. Badrinarayanan, A. Kendall, and R. Cipolla, “Segnet: A deep convolutional encoder-decoder architecture for image segmentation,” IEEE transactions on pattern analysis and machine intelligence, vol. 39, no. 12, pp. 2481–2495, 2017.<br>[11] A. Kirillov, E. Mintun, N. Ravi, H. Mao, C. Rolland, L. Gustafson, T. Xiao, S. Whitehead, A. C. Berg, W.-Y. Lo, P. Dollár, and R. Girshick, “Segment anything,” 2023.<br>[12] M. Matsumoto and T. Nishimura, “Mersenne twister: A 623-dimensionally equidistributed uniform pseudo-random number generator,” ACM Trans. Model. Comput. Simul., vol. 8, no. 1, p. 3–30, jan 1998. [Online]. Available: <a href="https://doi.org/10.1145/272991.272995">https://doi.org/10.1145/272991.272995</a></p><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p>The source code of this project is available at <a href="https://github.com/ZzzzzzS/Image-Segmentation-via-Spectral-Clustering">here</a>.</p><h2 id="PDF-Version"><a href="#PDF-Version" class="headerlink" title="PDF Version"></a>PDF Version</h2><p>The PDF version of this paper is available at <a href="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Img_Segment/Image_Segmentation_via_Spectral_Clustering.pdf">here</a>.</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Image-Segmentation-via-Spectral-Clustering&quot;&gt;&lt;a href=&quot;#Image-Segmentation-via-Spectral-Clustering&quot; class=&quot;headerlink&quot; title=&quot;Image</summary>
        
      
    
    
    
    
    <category term="Computer Vision" scheme="https://blog.zzshub.cn/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>基于图像雅可比的目标跟踪控制</title>
    <link href="https://blog.zzshub.cn/2023/03/24/JacobiBasedPTZControl/"/>
    <id>https://blog.zzshub.cn/2023/03/24/JacobiBasedPTZControl/</id>
    <published>2023-03-24T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于图像雅可比的目标跟踪控制"><a href="#基于图像雅可比的目标跟踪控制" class="headerlink" title="基于图像雅可比的目标跟踪控制"></a>基于图像雅可比的目标跟踪控制</h1><p>本文从李群李代数的方式对二轴云台的目标跟踪控制(视觉伺服)问题进行了推导。基于图像的视觉伺服(IBVS)问题多使用基于解析几何的方法进行推到，但是似乎很少有人使用李群李代数进行推到。本文使用李代数完成对基于图像雅可比的视觉伺服问题推导，相比于解析几何的方法，我认为在面对更多更复杂关节的情况下，李代数的方法更具有通用性。下面将介绍系统模型，并基于此模型开始推导。</p><h1 id="系统建模"><a href="#系统建模" class="headerlink" title="系统建模"></a>系统建模</h1><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/JacobiPTZControl/1690384932504.png"></p><p>系统模型如上图所示，该系统由两个相机和一个二关节云台构成，其中C1相机为广角相机，C2相机为长焦相机。该系统将使用C1相机检测目标，并控制C2相机跟踪目标。该系统的目标是使C2相机的视野中始终包含目标，即在C1相机能看到目标的情况下使目标在C2相机视野中移动。{C1},{C2}坐标系为前文所述两相机的坐标系; {G1},{G2}为电机法兰坐标系; {M1}{M2}为电机基座坐标系，{M}系与{G}系的z轴同方向共线。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>目标是使C2相机的视野中始终包含目标，即在C1相机能看到目标的情况下使目标在C2相机视野中移动。为了实现上述目标，我们需要获得长焦相机中目标像素坐标与相机光心坐标的误差与云台电机旋转之间的关系，即：</p><p>$$<br>\vec{e}&#x3D;[\begin{matrix} u \ v \ \end{matrix}] - [\begin{matrix} u_0 \ v_0 \ \end{matrix}]&#x3D; {}^{2}T_{1} P_1+\frac{\partial e}{\partial \phi_1}\delta\phi_1+\frac{\partial e}{\partial \phi_2}\delta\phi_2<br>$$<br>在获得雅可比矩阵后即可根据误差雅可比进行视觉伺服控制。</p><h1 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h1><h2 id="预备定理与公式"><a href="#预备定理与公式" class="headerlink" title="预备定理与公式"></a>预备定理与公式</h2><h3 id="SE-3-群的伴随性质"><a href="#SE-3-群的伴随性质" class="headerlink" title="SE(3)群的伴随性质"></a>SE(3)群的伴随性质</h3><p>$$<br>\boldsymbol{T} Exp(\xi) \boldsymbol{T}^{-1}&#x3D;Exp(Ad(\boldsymbol{T})\xi)<br>$$</p><p>稍加变形后可得：<br>$$<br>Exp(\xi)\boldsymbol{T}&#x3D;\boldsymbol{T}Exp(Ad(T^{-1})\xi)<br>$$<br>其中：<br>$$<br>Exp(\xi)&#x3D;exp(\xi^\wedge)<br>$$</p><p>$$<br>Ad(\boldsymbol{T})&#x3D;[\begin{matrix} R &amp; t^\wedge R \ 0 &amp; R \ \end{matrix}]<br>$$</p><h3 id="SE-3-群的BCH近似公式"><a href="#SE-3-群的BCH近似公式" class="headerlink" title="SE(3)群的BCH近似公式"></a>SE(3)群的BCH近似公式</h3><p>$$<br>Exp(\xi+\delta\xi)\approx Exp(\xi)Exp(J_r(\xi)\delta\xi)<br>$$</p><p>$$<br>Exp(\xi)Exp(\delta\xi)&#x3D;Exp(\xi+J_r^{-1}(\xi)\delta\xi)<br>$$</p><p>其中$J_r，J_r^{-1}$为其右乘雅可比以及它的逆，由于我们只用到了右乘，这里仅展示右乘，左乘有类似形式。当$\delta\xi$为小量时，雅可比矩阵约等于单位阵，即：</p><p>$$<br>J_r(\delta\xi)&#x3D;J_r^{-1}(\delta\xi)&#x3D;I_(6×6)<br>$$</p><h3 id="SO-3-群中的向量叉积有以下性质"><a href="#SO-3-群中的向量叉积有以下性质" class="headerlink" title="SO(3)群中的向量叉积有以下性质"></a>SO(3)群中的向量叉积有以下性质</h3><p>$$<br>a^\wedge b&#x3D;-b^\wedge a<br>$$</p><h3 id="se-3-李代数的升运算"><a href="#se-3-李代数的升运算" class="headerlink" title="se(3)李代数的升运算"></a>se(3)李代数的升运算</h3><p>$$<br>\xi^\wedge&#x3D;\left[ \begin{matrix} \rho \ \phi \ \end{matrix} \right]^\wedge &#x3D; \left[ \begin{matrix} \phi^\wedge &amp; J\rho \ \boldsymbol{0} &amp; \boldsymbol{0} \ \end{matrix} \right]<br>$$</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>$$<br>e&#x3D;[u^2,v^2]^T-[u_0^2,v_0^2]^T&#x3D;K_2 {}^{C2}T_{G2} rot(\omega_2) {}^{M2}T_{G1} rot(\omega_1) {}^{M1}T_{C1}P_1-[u_0^2,v_0^2]^T      (1)<br>$$</p><p>我们对(1)式加入右扰动<br>$$<br>\hat{e}&#x3D;[u^2,v^2]^T-[u_0^2,v_0^2]^T&#x3D;K_2 {}^{C2}T_{G2} rot(\omega_2) Exp(\delta\xi_2) {}^{M2}T_{G1} rot(\omega_1) Exp(\delta\xi_1){}^{M1}T_{C1}P_1-[u_0^2,v_0^2]^T       (2)<br>$$</p><p>利用伴随性质将扰动项移至末尾<br>$$<br>\hat{e}&#x3D;[u^2,v^2]^T-[u_0^2,v_0^2]^T&#x3D;K_2 {}^{C2}T_{G2} rot(\omega_2) Exp(\delta\xi_2) {}^{M2}T_{G1} rot(\omega_1) {}^{M1}T_{C1} Exp(Ad({}^{M1}T_{C1}^{-1})\delta\xi_1) P_1-[u_0^2,v_0^2]^T       (3)<br>$$</p><p>$$<br>\hat{e}&#x3D;[u^2,v^2]^T-[u_0^2,v_0^2]^T&#x3D;K_2 {}^{C2}T_{G2} rot(\omega_2) {}^{M2}T_{G1} rot(\omega_1) {}^{M1}T_{C1} Exp(Ad(({}^{M2}T_{G1} rot(\omega_1) {}^{M1}T_{C1})^{-1})\delta\xi_2)  Exp(Ad({}^{M1}T_{C1}^{-1})\delta\xi_1) P_1-[u_0^2,v_0^2]^T<br>$$</p><p>令<br>$$<br>{}^{C2}T_{C1}&#x3D;k_2 {}^{C2}T_{G2} rot(\omega_2) {}^{M2}T_{G1} rot(\omega_1) {}^{M1}T_{C1}<br>$$</p><p>$$<br>{}^{C1}T_{M2}&#x3D;({}^{M2}T_{G1} rot(\omega_1) {}^{M1}T_{C1})^{-1}<br>$$</p><p>可得<br>$$<br>\hat{e}&#x3D;K_2{}^{C2}T_{C1} Exp(Ad({}^{C1}T_{M2})\delta\xi_2)  Exp(Ad({}^{M1}T_{C1}^{-1})\delta\xi_1) P_1-[u_0^2,v_0^2]^T<br>$$</p><p>利用BCH近似可得<br>$$<br>\hat{e}&#x3D;K_2{}^{C2}T_{C1} Exp(Ad({}^{C1}T_{M2})\delta\xi_2+J_r^{-1}(Ad({}^{C1}T_{M2})\delta\xi_2) Ad({}^{M1}T_{C1}^{-1})\delta\xi_1) P_1-[u_0^2,v_0^2]^T<br>$$</p><p>由于$Ad( ^{C1}T_{M2} )\delta\xi_2$是小量，其右雅可比约等于单位阵，可得：</p><p>$$<br>\hat{e}\approx K_2{}^{C2}T_{C1} Exp(Ad({}^{C1}T_{M2})\delta\xi_2+Ad({}^{C1}T_{M1})\delta\xi_1) P_1-[u_0^2,v_0^2]^T<br>$$</p><p>$$<br>\hat{e}\approx K_2{}^{C2}T_{C1} (I + (Ad({}^{C1}T_{M2})\delta\xi_2)^\wedge+(Ad({}^{C1}T_{M1})\delta\xi_1)^\wedge) P_1-[u_0^2,v_0^2]^T<br>$$</p><p>$$<br>\hat{e}\approx K_2{}^{C2}T_{C1}  P_1-[u_0^2,v_0^2]^T +K_2((Ad({}^{C1}T_{M2})\delta\xi_2)^\wedge+(Ad({}^{C1}T_{M1})\delta\xi_1)^\wedge)P_1<br>$$</p><p>将旋转平移矩阵进行拆分，由于转轴的平移分量为0，因此 $\rho&#x3D;0$.</p><p>$$<br>\hat{e}\approx K_2{}^{C2}T_{C1}P_1-[u_0^2,v_0^2]^T+K_2 [\begin{matrix} ({}^{C1}R_{M2}\delta\phi_2)^\wedge &amp; 0 \ 0 &amp; 0\\end{matrix}][\begin{matrix}P_1 \ 1\ \end{matrix}]+K_2[\begin{matrix} ({}^{C1}R_{M1}\delta\phi_1)^\wedge &amp; 0 \ 0 &amp; 0\ \end{matrix}][\begin{matrix}P_1 \ 1\ \end{matrix}]<br>$$</p><p>$$<br>\hat{e}\approx K_2{}^{C2}T_{C1}P_1-[u_0^2,v_0^2]^T+K_2 [\begin{matrix} ({}^{C1}R_{M2}\delta\phi_2)^\wedge P_1   \  0\\end{matrix}]+K_2[\begin{matrix} ({}^{C1}R_{M1}\delta\phi_1)^\wedge P_1 \ 0\ \end{matrix}]<br>$$</p><p>利用SO(3)群中的向量叉积的性质可得</p><p>$$<br>\hat{e}\approx K_2{}^{C2}T_{C1}P_1-[u_0^2,v_0^2]^T+K_2 [\begin{matrix}  -P_1^\wedge ({}^{C1}R_{M2}\delta\phi_2)  \  0\ \end{matrix}]+K_2[\begin{matrix} - P_1^\wedge({}^{C1}R_{M1}\delta\phi_1) \ 0\ \end{matrix}]<br>$$</p><p>$$<br>\hat{e}\approx K_2{}^{C2}T_{C1}P_1-[u_0^2,v_0^2]^T+K_2 [\begin{matrix}  -P_1^\wedge {}^{C1}R_{M2} &amp; 0  \  0 &amp; 0\ \end{matrix}][\begin{matrix} \delta\phi_2 \ 0 \ \end{matrix}]+K_2[\begin{matrix} - P_1^\wedge{}^{C1}R_{M1} &amp; 0 \ 0&amp; 0\ \end{matrix}][\begin{matrix} \delta\phi_1 \ 0 \ \end{matrix}]<br>$$</p><p>$$<br>\hat{e}&#x3D;e+\frac{\partial e}{\partial \phi_2}\delta\phi_2+\frac{\partial e}{\partial \phi_1}\delta\phi_1<br>$$</p><p>最后我们可以得到误差关于电机旋转的偏导数，由于电机只能饶z轴旋转，因此需要将x, y分量置零</p><p>$$<br>\frac{\partial e}{\partial \phi_2}&#x3D;-K_2 diag(0,0,1) P_1^\wedge {}^{C1}R_{M2}<br>$$</p><p>$$<br>\frac{\partial e}{\partial \phi_1}&#x3D;-K_2 diag(0,0,1) P_1^\wedge {}^{C1}R_{M1}<br>$$</p><p>$$<br>\hat{e}&#x3D;e+ [\begin{matrix} \frac{\partial e}{\partial \phi_1}&amp; \frac{\partial e}{\partial \phi_2}\\end{matrix}][\begin{matrix} \delta\phi_1 \ \delta\phi_2 \ \end{matrix}]<br>$$</p><p>$$<br>\delta e&#x3D;\hat{e}-e&#x3D;J\phi<br>$$</p><p>最后对雅可比矩阵求伪逆即可得到控制增量$\delta\phi$</p><p>$$<br>\phi&#x3D;(J^TJ)^{-1}(J^T(\delta e))<br>$$</p><p>电机新的目标位置即为$\phi+\delta\phi$.</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;基于图像雅可比的目标跟踪控制&quot;&gt;&lt;a href=&quot;#基于图像雅可比的目标跟踪控制&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="Computer Vision" scheme="https://blog.zzshub.cn/tags/Computer-Vision/"/>
    
    <category term="Control" scheme="https://blog.zzshub.cn/tags/Control/"/>
    
  </entry>
  
  <entry>
    <title>Research Report of 360VO Visual Odometry Using A Single 360 Camera</title>
    <link href="https://blog.zzshub.cn/2022/11/13/360VO_Research/"/>
    <id>https://blog.zzshub.cn/2022/11/13/360VO_Research/</id>
    <published>2022-11-13T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Research-Report-of-360VO-Visual-Odometry-Using-A-Single-360-Camera"><a href="#Research-Report-of-360VO-Visual-Odometry-Using-A-Single-360-Camera" class="headerlink" title="Research Report of 360VO: Visual Odometry Using A Single 360 Camera"></a>Research Report of 360VO: Visual Odometry Using A Single 360 Camera</h1><blockquote><p><strong>Abstract</strong>—This article is a review and evaluation of the paper 360VO: Visual Odometry Using A Single 360 Camera in the 2022 IEEE International Conference on Robotics and Automation (ICRA). Starts from this article and summarizes the method of it and then presents the related works. Then, some improvement directions are proposed for this article. Finally, the commercial value and social value of the visual slam field are discussed. After decades of development in the field of visual slam, good localization and mapping effects have been achieved. This article proposes a slam framework based on 360 cameras and combines direct methods to complete localization and mapping tasks. Experiments show that the method proposed in this paper has good robustness and accuracy.</p></blockquote><h1 id="EXECUTIVE-SUMMARY"><a href="#EXECUTIVE-SUMMARY" class="headerlink" title="EXECUTIVE SUMMARY"></a>EXECUTIVE SUMMARY</h1><p>This article is a summary and review of the paper <em><a href="https://doi.org/10.1109/ICRA46639.2022.9812203"> 360VO: Visual Odometry Using A Single 360 Camera</a></em> published in the 2022 IEEE International Conference on Robotics and Automation (ICRA). This paper uses a 360° omnidirectional camera to complete the simultaneous localization and mapping task (SLAM). simulation experiment and the real indoor and outdoor mapping experiments using a handheld 360° camera demonstrate that the method achieves good results. A 360 camera is a special kind of camera that can capture 360° horizontal and 180° vertical information at once.</p><p>360° camera can be achieved using only 2 fisheye cameras placed back-to-back. This significantly reduces costs, such these commercial products are becoming more popular and accessible, such as insta 360, go pro, etc. To utilize 360° cameras for localization and mapping, this paper proposes slam method based on direct method. Direct methods estimate camera pose and depth features by minimizing the photometric error. Pinhole and various fisheye camera models are not suitable for describing projections from 360 cameras. This paper proposes an appropriate 360 camera model, which uses a spherical model for projection. Images using equidistant projection assume that the 360 camera is an undistorted camera. The spherical camera model only needs two parameters, namely the width and height of the image, to complete the projection. The defined photometric error in DSO is expressed as the energy loss of the corresponding pattern. For the mapping, this paper models the inverse depth estimation of points with probability distributions. The depth range was initially assumed over a wide range. As new frames appear, it will continuously search for the best corresponding point to estimate depth more accurately. In order to speed up the search and guarantee the accuracy, the search process should follow the epipolar constraints. This paper searches for the minimum error on the epipolar line with a certain step to complete the depth estimation. To quantitatively evaluate the performance of this method, this paper proposes a synthetic dataset with dense features. The dataset contains 10 sequences whose features appear in different urban models. 360VO achieves a similar effect compared to the indirect method of Open-VSLAM. At the same time this article cuts the image and then runs orb-slam3. Apparently, methods using 360 cameras are generally more robust and accurate because there is more features in widefield camera than normal cameras. Then, physical experiments of indoor and outdoor mapping based on handheld 360 cameras have well demonstrated the effect of the algorithm.</p><h1 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h1><p>The visual odometry (VO) or visual-inertial odometry (VIO) problem has been extensively studied in the past few decades. This problem mainly uses the information obtained from the image to complete the estimation of camera pose and the estimation of 3D landmarks in map. Visual SLAM platforms can be mainly divided into three categories according to different camera types: monocular cameras, stereo cameras and RGBD cameras. The monocular camera refers to a system that uses a single camera to complete mapping (such as Apple ARKit). stereo camera refers to a system that uses two cameras with known extrinsic parameters to complete the mapping (such as Leap Motion, ZED). Since the monocular camera loses the scale information in the process of pose estimation, it is necessary to introduce auxiliary method such as odometer to calculate the scale information. However, the scale information can be more easily recovered when the stereo cameras are used. Neither monocular nor binocular cameras can easily calculate depth information, and the use of RGBD cameras is a good solution to this problem. RGBD cameras usually use the time-of-flight method ToF (such as Microsoft Kinect-2), and the structured light method (such as Microsoft Kinect-1, Apple Prime Sense) to obtain depth information [1]. good positioning and mapping performance can also be obtained in areas such as dark light and weak textures. But its higher cost compared to cameras limits its widesp use.</p><p>MonoSLAM [2][3] is the pioneer work of visual slam systems. Produced by Andrew J Davison with support from the Engineering and Physical Sciences Research Council (EPSRC) Advanced Research Fellowship programme in the UK. MonoSLAM uses Extended Kalman Filter as the backend to track sparse feature points in the frontend. MonoSLAM is based on EKF, taking the current state of the camera and all landmark points as state quantities, and updating its mean and covariance. </p><p>In 2007, Klein et al. proposed PTAM (Parallel Tracking and Mapping) [6], which is also an important event in the development of visual SLAM, and the project was mainly funded by Oxford University. The significance of PTAM lies in the following two aspects: </p><ul><li>PTAM proposes and realizes the parallelization of the tracking and mapping process. </li><li>PTAM is the first slam framework to use nonlinear optimization instead of traditional filter as backend.</li><li>The system also introduces a keyframe mechanism to reduce computation and better optimize the map.</li></ul><p>ORB-SLAM is a very famous successor of PTAM [7], This work was supported by the Direccion General de Investigaci ´ on of ´ Spain. It was proposed in 2015 and is one of the most well-established and easy-to-use systems in modern SLAM systems. Currently ORB-SLAM has been developed to ORB-SLAM3[8]. The advantages of the ORB-SLAM3 system can be mainly summarized as follows:</p><ul><li>Supports monocular, binocular and RGBD modes.</li><li>The system mainly based on calculate FAST-ORB feature, including visual odometry and close-loop detection modules. Compared with feature points such as SIFT or SURF, ORB feature points have faster calculation speed and can realize real-time calculation. In addition, the feature descriptor of ORB can provide certain rotation and scaling invariance.</li><li>The system introduces a loop closure detection system based on hierarchical clustering model DBoW2[5]. Compared with the traditional SLAM system based on extended Kalman filter, this system can better solve the problem of cumulative error. At the same time, it can be quickly retrieved after being lost.</li><li>The system uses multiple threads to synchronously complete the tasks of tracking, local optimization and global optimization, making the operation more efficient.</li></ul><p>The main system components of orb-slam are shown in Figure 1</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Research360Vo/Figure1.png"><br><em>Figure 1 Main system components of ORB-SLAM3</em></p><p>Large Scale Direct monocular SLAM is a SLAM work proposed by J. Engle et al. in 2014 [9][10], sponsored by the Technical University of Munich. Unlike ORB-SLAM, which uses feature points to extract image features, LSD-SLAM uses a direct method to complete feature extraction. The core contribution of LSD-SLAM is the application of direct methods to semi-dense monocular SLAM. Not only does it not need to compute feature points, it also builds semi-dense maps. Compared with the feature point method, the direct method can be used to complete the mapping in the missing feature point area, but it is prone to loss problems when the camera moves too fast. Furthermore, since loop closure detection usually relies on the clustering of feature points[5], LSD-SLAM still needs to compute feature points.</p><p>Semi-direct Visual Odoemtry (SVO) [11]. It is a semi-direct method based visual odometry proposed by Forster et al. The framework mixes feature points with direct methods. SVO tracks some keypoints and then performs block matching to estimate camera motion. Since it uses the sparse direct method, it neither has to work hard to compute descriptors nor deal with as much information as dense and semi-dense, so it can achieve real-time performance even on low-end computing platforms. Some commonly used SLAM systems can be summarized in Table 1.</p><p>The core of visual SLAM is to estimate the pose and position of the camera and landmarks, and the key to the estimation is to extract the information in the image. A larger field of view can provide cameras with more features and a larger common field of view between cameras. Thereby reducing the occurrence of dropped frames, and can better complete the mapping task[12]. But the wide-angle camera has more serious distortion problems, and the ordinary pinhole camera model is not enough to directly express the wide-angle camera. Therefore, many scholars have done extensive research in this area. Caruso[13], and Matsuki [14] et al. established SLAM systems using omnidirectional cameras in LSD-SLAM and DSO, respectively, by introducing a generic camera model. Furthermore, the Kannala Brandt camera model [15] is used in Campos [16] et al. to support fisheye cameras as input in ORB-SLAM3. </p><p>Some scholars have also devoted themselves to using more cameras to complete feature extraction with larger field of view. MULTICOL-SLAM [17] proposed a fast and applicable SLAM system based on multiple cameras. ROVO [18] is also a similar multi-camera SLAM system. The system uses a hybrid projection model that uses 4 cameras to cover a 360° field of view to detect the environment. However, the above-mentioned system based on the multi-camera model requires multiple cameras, thereby increasing the cost of use, and more cameras significantly increase the complexity of calibration. Using the reflection of the lens can also increase the viewing angle of the camera. X. Long [4] and others from the Institute of Automation, Chinese Academy of Sciences installed a high-speed mirror in front of the camera and assisted the high-speed camera. In the case of using only a single ordinary pinhole camera, a wide-angle camera is virtualized to complete multi-target extraction. This method can ensure local high resolution while obtaining a large field of view, but its complex mechanical structure limits the use of the scene. The above-mentioned methods for increasing the field of view are all complicated. An easy way to do this is to use two wide-angle cameras arranged back-to-back to form a 360° wide-angle system. The OpenVSLAM [19] system can support such camera input and use the feature point-based slam algorithm to complete the mapping task. This paper proposes the 360VO framework, uses a photometric error-based approach to recover camera pose, and introduces epipolar constraints to recover the coordinates of landmark points.</p><p><strong>TABLE 1 COMMON USED VISUAL SLAM FRAMEWORK</strong></p><table><thead><tr><th>framework</th><th>sensor type</th><th>sponsorwebpage</th></tr></thead><tbody><tr><td>MonoSLAM</td><td>monocamera</td><td>University of Oxford<a href="https://github.com/hanmekim/SceneLib2">https://github.com/hanmekim/SceneLib2</a></td></tr><tr><td>PTAM</td><td>monocamera</td><td>University of Oxford<a href="http://www.robots.ox.ac.uk/~gk/PTAM/">http://www.robots.ox.ac.uk/~gk/PTAM/</a></td></tr><tr><td>ORB-SLAM</td><td>mainly monocamera</td><td>University of Zaragoza<a href="http://webdiis.unizar.es/~raulmur/orbslam/">http://webdiis.unizar.es/~raulmur/orbslam/</a></td></tr><tr><td>LSD-SLAM</td><td>mainly monocamera</td><td>Technical University of Munich<a href="http://vision.in.tum.de/research/vslam/lsdslam">http://vision.in.tum.de/research/vslam/lsdslam</a></td></tr><tr><td>SVO</td><td>monocamera</td><td>University of Zurich<a href="https://github.com/uzh-rpg/rpg_svo">https://github.com/uzh-rpg/rpg_svo</a></td></tr><tr><td>DTAM</td><td>RGB-D</td><td>Imperial College London<a href="https://github.com/anuranbaka/OpenDTAM">https://github.com/anuranbaka/OpenDTAM</a></td></tr><tr><td>DVO</td><td>RGB-D</td><td>Technical University of Munich<a href="https://github.com/tum-vision/dvo_slam">https://github.com/tum-vision/dvo_slam</a></td></tr><tr><td>DSO</td><td>monocamera</td><td>Technical University of Munich<a href="https://github.com/JakobEngel/dso">https://github.com/JakobEngel/dso</a></td></tr><tr><td>RTAB-MAP</td><td>stereo cameras&#x2F;RGB-D</td><td>University of Sherbrooke<a href="https://github.com/introlab/rtabmap">https://github.com/introlab/rtabmap</a></td></tr><tr><td>VINS-Fusion</td><td>monocamera&#x2F;stereo cameras</td><td>HKUST<a href="https://github.com/HKUST-Aerial-Robotics/VINS-Fusion">https://github.com/HKUST-Aerial-Robotics/VINS-Fusion</a></td></tr></tbody></table><h1 id="CONTRIBUTION"><a href="#CONTRIBUTION" class="headerlink" title="CONTRIBUTION"></a>CONTRIBUTION</h1><p>The main contributions of this article are as follows:</p><ul><li>A projection model based on a 360° camera is proposed.</li><li>An epipolar constraint relation suitable for 360 cameras is proposed, and an error search strategy based on epipolar is designed.</li><li>A back-end error optimization model based on local windows is designed.</li></ul><h2 id="360-camera-model"><a href="#360-camera-model" class="headerlink" title="360 camera model"></a>360 camera model</h2><p>The camera model is used to express the relationship between the real world coordinate system $\Omega$ and the camera image coordinate system $\Psi$. Let $u&#x3D;\left[u,v\right]^T \in \Psi$ represent the coordinate point in the image coordinate system, and let $X_c&#x3D;\left[X_c,Y_c,Z_c\right]^T\in\Omega$ represent points in the camera coordinate system. The camera model in this article refers to the need to find a mapping relationship $\pi:\ \Omega\rightarrow\Psi$ to express the relationship between 3D points and 2D points. Conversely, $\pi^{-1}:\Psi\rightarrow\Omega$ can be used to express the mapping relationship between 2D points and 3D points. Generally speaking, the ordinary camera based on the pinhole imaging model can be expressed by the following formula.</p><p>$$<br>s\left[ \begin{matrix} u \ v \ 1 \ \end{matrix}\right ]&#x3D;\left[ \begin{matrix} f_x &amp; 0 &amp; c_x\ 0 &amp; f_y &amp; c_y \ 0 &amp; 0 &amp; 1 \  \end{matrix} \right]\left[ \begin{matrix} X_c \ Y_c \ Z_c \ \end{matrix} \right ]<br>$$</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Research360Vo/Figure2.png"><br><em>Figure 2 Coordinate systems used in 360VO. It takes advantage of a spherical model to represent camera projection, and the 2D image is in equirectangular projection.</em></p><p>However, this camera model cannot express a camera model with a field of view exceeding 180°. Therefore, a spherical projection model suitable for 360 cameras is proposed. As shown in Figure 2, the projection model projects the points in the world coordinates onto the unit sphere to complete the mapping between 3D and 2D points. The projection model can be expressed by the following formula:</p><p>$$<br>\pi\left(X_c\right)&#x3D;\left[\begin{matrix}u\v\\end{matrix}\right]&#x3D;K\left[\begin{matrix}lon\lat\\end{matrix}\right]&#x3D;K\left[\begin{matrix}arctan\left(X_c&#x2F;Z_c\right)\-arcsin\left(dY_c\right)\\end{matrix}\right]<br>$$</p><p>Where $d&#x3D;1&#x2F;\sqrt{X_c^2+Y_c^2+Z_c^2}$ represents the reciprocal of the distance from the 3D point to the unit sphere. lon and lat represent the latitude and longitude on the sphere. $-\pi &lt; lon &lt; \pi$ and $-\pi&#x2F;2 &lt; lat &lt; \pi&#x2F;2$. The last K represents the camera intrinsic parameter.</p><p>$$<br>\mathbf{K}&#x3D;\left[\begin{matrix}f_x&amp;0&amp;c_x\0&amp;f_y&amp;c_y\\end{matrix}\right]&#x3D;\left[\begin{matrix}W&#x2F;2\pi&amp;0&amp;W&#x2F;2\0&amp;-H&#x2F;\pi&amp;H&#x2F;2\\end{matrix}\right]<br>$$</p><h2 id="Camera-pose-and-landmark-estimation"><a href="#Camera-pose-and-landmark-estimation" class="headerlink" title="Camera pose and landmark estimation"></a>Camera pose and landmark estimation</h2><h3 id="get-camera-pose"><a href="#get-camera-pose" class="headerlink" title="get camera pose"></a>get camera pose</h3><p>This article uses the direct method to complete the estimate of camera pose and landmark point coordinates. The direct method usually uses the method of minimizing the energy function to complete the optimal pose estimation of the camera. the energy function of a pixel $p \in\ \Psi$ in the host frame $i$ regrading to a co-visible target frame $j$ is<br>$$<br>\begin{aligned}<br>&amp; E_{\mathbf{p}}^{i j}&#x3D;\sum_{\mathbf{u} \in N_{\mathrm{p}}}|r|&#x3D;\sum_{\mathbf{u} \in N_{\mathbf{p}}} w_{\mathbf{u}}\left|\left(I_j\left[\mathbf{u}^{\prime}\right]-b_j\right)-\frac{t_j e^{a_j}}{t_i e^{e_i}}\left(I_i[\mathbf{u}]-b_i\right)\right| \<br>&amp; \mathbf{u}^{\prime}&#x3D;\pi\left(\mathbf{R}<em>{j i} \pi^{-1}\left(\mathbf{u}, \hat{d}^{\mathbf{p}}\right)+\mathbf{t}</em>{j i}\right) \<br>&amp; {\left[\begin{array}{cc}<br>\mathbf{R}<em>{i j} &amp; \mathbf{t}</em>{i j} \<br>0 &amp; 1<br>\end{array}\right]&#x3D;\mathbf{T}_{i j}&#x3D;\mathbf{T}_j \mathbf{T}<em>i^{-1}}<br>\end{aligned}<br>$$<br>In this paper, the weighted sum of squared differences (SSD) algorithm is used to calculate the matching error, specifically, there are 8 pixels between each matching block, i.e., 8 pixels share the same depth. $T_i^{-1}$ and $T_j^{-1}$ are the representations of the $i-th$ frame and the $j-th$ frame in the world coordinate system. $u^$ prime and $u$ represent the correspond pixels to be calculated in the $j$ frame and the $i$ frame, respectively. $t</em>{ji}$ represents the exposure time between frame $i$ and frame $j$. Finally combining the pixels of all neighborhood frames, the final energy function can be expressed as:</p><p>$$<br>\boldsymbol{E}&#x3D;\sum_{i \in F}\sum_{\boldsymbol{p}\in P_i}\sum_{j \in obs(\boldsymbol{P})}{E_{\boldsymbol{P}}^{ij}}<br>$$</p><p>where $F$ represents frames contained in local optimization window, $P_i$ represents a set of selected points in the frame $i$ and are randomly sampled from directional points with local gradients above a certain threshold, and $obs\left(p\right)$ represents the frames that can observe point $p$. The optimization method of bundle adjustment is used.</p><h3 id="Calculate-landmark-pose"><a href="#Calculate-landmark-pose" class="headerlink" title="Calculate landmark pose"></a>Calculate landmark pose</h3><p>Different from methods such as ORB-SLAM that use feature points, the direct method lacks the direct correspondence between two pixels. therefore, it is difficult to directly determine the depth of landmark points. Similar to other systems using the direct method [20][21][22][23], this paper also uses a preset depth range and an epipolar constraint to find the optimal pixel disparity and generate a semi-dense map. However, since this paper uses a camera projection model different from the pinhole model, it is necessary to derive a new epipolar constraint relationship on the spherical surface, as shown in Figure 3.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Research360Vo/Figure3.png"><br><em>Figure 3 Epipolar constraints. When tracking succeeds, it needs to create new activated points and refine their inverse depth via triangulation. High corresponding points of host frame $c_i$ lie in the epipolar curve instead of line in the target frame $c_j$</em></p><p>Let the epipolar plane be $\rho$ and the unit sphere plane be $S$, then the constraints in the camera coordinate system $\Omega$ can be expressed as follows:</p><p>$$<br>\left{\begin{array}{l}<br>\rho: a X+b Y+c Z+d&#x3D;0 \<br>S: \quad X^2+Y^2+Z^2&#x3D;1<br>\end{array}\right.<br>$$</p><p>Combined with the 360 camera projection model derived above, the following constraints on the epipolar curve in the pixel coordinate system can be obtained:</p><p>$$<br>\mathbf{u}(\alpha)&#x3D;\pi(\alpha \mathbf{P}_0^{\prime}+(1-\alpha) \mathbf{P}_\infty^{\prime} ), \alpha \in[0,1]<br>$$</p><p>$$<br>\mathbf{P}<em>0^{\prime}&#x3D;\pi_s\left(\mathbf{R}</em>{j i} \pi^{-1}\left(\mathbf{p}, \hat{d}<em>{\text {min }}\right)+\mathbf{t}</em>{j i}\right)<br>$$</p><p>$$<br>\mathbf{P}<em>\infty^\prime&#x3D;\pi_s(\mathbf{R}</em>{ji} \pi^{-1}(\mathbf{p}, \hat{d}<em>{\max })+\mathbf{t}</em>{ji})<br>$$</p><p>Where $P_0^\prime P_\infty^\prime$ represents the projection point of point $p$ in frame $i$ at the maximum disparity and the minimum disparity in frame $j$.</p><h2 id="local-optimization"><a href="#local-optimization" class="headerlink" title="local optimization"></a>local optimization</h2><p>In order to enhance robustness and reduce a certain amount of computation, this article uses bundle adjustment to optimize local frame and landmark coordinates. In this paper, the local frame selection is 7 adjacent keyframes and 2500 landmark points.</p><h3 id="keyframe-selection"><a href="#keyframe-selection" class="headerlink" title="keyframe selection"></a>keyframe selection</h3><p>The quality of key frame selection determines the quality of the map. In this article, the relative pose between the current frame and the previous key frame is calculated, and when the relative distance reaches a certain threshold, the frame is recorded as a new key frame. At the same time, since this article is based on the direct method, since the direct method has the assumption of illumination invariance, it is necessary to generate new key frames when the ambient light changes greatly.</p><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><p>This article uses the Gauss-Newton method to complete the optimization of camera intrinsic parameters, extrinsic parameters, and optical flow parameters. Here, the disturbance derivation method on the SE3 manifold is used to complete the derivation. Its Jacobian matrix can be expressed as follows:</p><p>$$<br>\mathbf{J}_{\mathbf{M}&#x3D;\left(\mathbf{T}_i,\mathbf{T}_j,\hat{d},\mathbf{K},a_i,b_i,a_j,b_j\right)}&#x3D;\left[\frac{\partial r\left(\left(\delta+x\right)\boxplus\zeta_0\right)}{\partial\delta}\right]<br>$$</p><p>where $\zeta_0\in SE\left(3\right)$ and $\boxplus$ denotes the operation: $se{\left(3\right)}\times SE\left(3\right)\rightarrow SE\left(3\right)$.</p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>This article innovatively proposes a SLAM framework based on 360 cameras. This paper proposes a projection model for the 360 camera and derives the epipolar constraints of the sphere from this model. In addition, this paper combines the direct method to complete the localization and mapping tasks. But I think this article still has some things worth improving. </p><ul><li>Wide-angle cameras generally have large distortions, but this article does not consider the distortion, whether the quality of the mapping will be improved after the distortion correction model is introduced. </li><li>This article uses a spherical projection model to model a 360 camera, but the physical model of the camera is composed of two 180 wide-angle cameras arranged back-to-back. The optical centers of the two cameras are not completely coincident, and if the two wide-angle cameras  do not have the same internal parameter matrix K due to the existence of manufacturing tolerances, whether the projection model proposed in this paper can correctly handle this situation. </li><li>This article uses the bundle adjustment method to obtain the intrinsic and extrinsic parameters of the camera and optical flow parameters. If the camera is calibrated in advance and the intrinsic parameters are not optimized during the mapping process, can a better mapping result be produced. </li><li>In this paper, the direct method is used to complete the positioning and mapping, but if the feature point method is used, there might be a big difference between the image generated by the spherical projection and the image generated by the pinhole camera (especially at the edge of the image, there will be a large curvature), whether it is necessary to design a new corner detection algorithm and feature descriptor.</li></ul><h1 id="SOCIAL-IMPART"><a href="#SOCIAL-IMPART" class="headerlink" title="SOCIAL IMPART"></a>SOCIAL IMPART</h1><p>The SLAM system has produced enormous commercial value to modern society. In general, there are two main trends in the future development direction of SLAM. </p><ul><li>Lighter and smaller SLAM systems, these systems can run on embedded systems, mobile phones and other small devices to better serve mobile robots, AR&#x2F;VR and other devices. These devices have important application scenarios in the fields of navigation, sports, and entertainment. </li><li>A more sophisticated SLAM system that uses high-performance computing equipment to complete tasks such as more precise 3D reconstruction. The aim of these applications is to perfectly reconstruct the scene without much restriction on computing resources and device portability.</li></ul><p>The 360VO system based on two wide-angle cameras proposed in this article effectively reduces the hardware cost of the product. Currently, there are various low-cost panoramic cameras such as INSTA360 and GO PRO. If these cameras can be combined with SLAM, new commercial value can be generated.<br>For example, in the current popular VR&#x2F;AR and short video effects fields, SLAM technology can build a map with more realistic visual effects, so as to render the superimposed effect of virtual objects according to the current perspective, making it more realistic and free of inconsistency. Among the representative products of VR&#x2F;AR, Microsoft Hololens, Google Project Tango and Magic Leap have all applied SLAM as a visual enhancement method.<br>In the field of mobile robots, the existing mobile robots need to install multiple sensors in order to complete all-round obstacle avoidance. If the 360 camera is used as the sensor, the hardware cost can be reduced without sacrificing the obstacle avoidance performance, and the positioning and mapping can be improved at the same time. Sweeping robot manufacturers Ecovacs, Tammy, etc. use SLAM to allow sweepers to efficiently draw indoor maps, intelligently analyze and plan the sweeping environment, and complete sweeping tasks more efficiently.<br>In the field of unmanned aerial vehicles(UAV), the use of omnidirectional sensors can make aerial photography more flexible, and better 3D reconstruction of buildings at high altitudes. SLAM can quickly build a local 3D map, and combined with geographic information system (GIS) and visual object recognition technology, it can assist UAVs to identify roadblocks and automatically avoid obstacles and plan paths.<br>In the field of autonomous driving. SLAM technology can provide the function of visual odometer and integrate with other positioning methods such as GPS, so as to meet the needs of precise positioning of unmanned driving.</p><h1 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h1><p>Starting from the paper <em><a href="https://doi.org/10.1109/ICRA46639.2022.9812203">360VO: Visual Odometry Using A Single 360 Camera</a></em> published in the 2022 IEEE International Conference on Robotics and Automation (ICRA), this paper analyzes the method proposed in this paper and proposes some possible solutions in this paper. The research status and commonly used SLAM frameworks in the field of SLAM are analyzed. And finally analyzes the commercial value and social value of SLAM system.</p><h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p>[1]Han, Ruilu, Hongjuan Yan, and Liping Ma. “Research on 3D Reconstruction methods Based on Binocular Structured Light Vision.” Journal of Physics: Conference Series. Vol. 1744. No. 3. IOP Publishing, 2021.</p><p>[2]A. Davison, I. Reid, N. Molton, and O. Stasse, “Monoslam: Real-time single camera SLAM,” IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 29, no. 6, pp. 1052–1067, 2007.</p><p>[3]A. J. Davison, “Real-time simultaneous localisation and mapping with a single camera,” in Computer Vision, 2003. Proceedings. Ninth IEEE International Conference on, pp. 1403– 1410, IEEE, 2003.</p><p>[4]X. Long, L. Ma, H. Jiang, Z. Li, Y. Chen and Q. Gu, “Mechanical Particle Filter-Based Active Vision System for Fast Wide-Area Multiobject Detection,” in IEEE Transactions on Instrumentation and Measurement, vol. 71, pp. 1-13, 2022, Art no. 9510113, doi: 10.1109&#x2F;TIM.2022.3201949.</p><p>[5]D. Galvez-López and J. D. Tardos, “Bags of Binary Words for Fast Place Recognition in Image Sequences,” in IEEE Transactions on Robotics, vol. 28, no. 5, pp. 1188-1197, Oct. 2012, doi: 10.1109&#x2F;TRO.2012.2197158.</p><p>[6]G. Klein and D. Murray, “Parallel tracking and mapping for small ar workspaces,” in Mixed and Augmented Reality, 2007. ISMAR 2007. 6th IEEE and ACM International Symposium on, pp. 225–234, IEEE, 2007.</p><p>[7]R. Mur-Artal, J. Montiel, and J. D. Tardos, “Orb-slam: a versatile and accurate monocular slam system,” arXiv preprint arXiv:1502.00956, 2015</p><p>[8]Carlos Campos, Richard Elvira, Juan J. Gómez Rodríguez, José M. M. Montiel and Juan D. Tardós, ORB-SLAM3: An Accurate Open-Source Library for Visual, Visual-Inertial and Multi-Map SLAM, IEEE Transactions on Robotics 37(6):1874-1890, Dec. 2021</p><p>[9]J. Engel, J. Sturm, and D. Cremers, “Semi-dense visual odometry for a monocular camera,” in Proceedings of the IEEE International Conference on Computer Vision, pp. 1449–1456, 2013.</p><p>[10]J. Engel, T. Schöps, and D. Cremers, “Lsd-slam: Large-scale direct monocular slam,” in Computer Vision–ECCV 2014, pp. 834–849, Springer, 2014.</p><p>[11]C. Forster, M. Pizzoli, and D. Scaramuzza, “Svo: Fast semi-direct monocular visual odometry,” in Robotics and Automation (ICRA), 2014 IEEE International Conference on (rs, ed.), pp. 15–22, IEEE, 2014.</p><p>[12]Z. Zhang, H. Rebecq, C. Forster, and D. Scaramuzza, “Benefit of large field-of-view cameras for visual odometry,” in 2016 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 2016, pp. 801–808.</p><p>[13]D. Caruso, J. Engel, and D. Cremers, “Large-scale direct slam for omnidirectional cameras,” in 2015 IEEE&#x2F;RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2015, pp. 141–148.</p><p>[14]H. Matsuki, L. von Stumberg, V. Usenko, J. Stuckler, and D. Cremers, ¨ “Omnidirectional dso: Direct sparse odometry with fisheye cameras,” IEEE Robotics and Automation Letters, vol. 3, no. 4, pp. 3693–3700, 2018.</p><p>[15]J. Kannala and S. S. Brandt, “A generic camera model and calibration method for conventional, wide-angle, and fish-eye lenses,” IEEE transactions on pattern analysis and machine intelligence, vol. 28, no. 8, pp. 1335–1340, 2006.</p><p>[16]C. Campos, R. Elvira, J. J. G. Rodr´ıguez, J. M. Montiel, and J. D. Tardos, “Orb-slam3: An accurate open-source library for visual, ´ visual–inertial, and multimap slam,” IEEE Transactions on Robotics, 2021.</p><p>[17]S. Urban and S. Hinz, “Multicol-slam-a modular real-time multi-camera slam system,” arXiv preprint arXiv:1610.07336, 2016.</p><p>[18]H. Seok and J. Lim, “Rovo: Robust omnidirectional visual odometry for wide-baseline wide-fov camera systems,” in 2019 International Conference on Robotics and Automation (ICRA). IEEE, 2019, pp. 6344–6350.</p><p>[19]S. Sumikura, M. Shibuya, and K. Sakurada, “Openvslam: a versatile visual slam framework,” in Proceedings of the 27th ACM International Conference on Multimedia, 2019, pp. 2292–2295.</p><p>[20]C. Forster, M. Pizzoli, and D. Scaramuzza, “Svo: Fast semi-direct monocular visual odometry,” in 2014 IEEE international conference on robotics and automation (ICRA). IEEE, 2014, pp. 15–22. </p><p>[21]R. Mur-Artal, J. M. M. Montiel, and J. D. Tardos, “Orb-slam: a versatile and accurate monocular slam system,” IEEE transactions on robotics, vol. 31, no. 5, pp. 1147–1163, 2015. </p><p>[22]J. Engel, T. Schops, and D. Cremers, “Lsd-slam: Large-scale di- ¨ rect monocular slam,” in European conference on computer vision. Springer, 2014, pp. 834–849. </p><p>[23]J. Engel, V. Koltun, and D. Cremers, “Direct sparse odometry,” IEEE transactions on pattern analysis and machine intelligence, vol. 40, no. 3, pp. 611–625, 2017.</p><h1 id="PDF-VERSION"><a href="#PDF-VERSION" class="headerlink" title="PDF VERSION"></a>PDF VERSION</h1><p>The PDF version of this article can be downloaded from the following link:</p><p><a href="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Research360Vo/Research%20Report%20of%20360VO%20Visual%20Odometry%20Using%20A%20Single%20360%20Camera.pdf">Download Here</a></p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Research-Report-of-360VO-Visual-Odometry-Using-A-Single-360-Camera&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="SLAM" scheme="https://blog.zzshub.cn/tags/SLAM/"/>
    
    <category term="Computer Vision" scheme="https://blog.zzshub.cn/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>Visual Place Recognition via HMM Filter and Smoother</title>
    <link href="https://blog.zzshub.cn/2022/10/28/visual_place_recognition/"/>
    <id>https://blog.zzshub.cn/2022/10/28/visual_place_recognition/</id>
    <published>2022-10-27T16:00:00.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Visual-Place-Recognition-via-HMM-Filter-and-Smoother"><a href="#Visual-Place-Recognition-via-HMM-Filter-and-Smoother" class="headerlink" title="Visual Place Recognition via HMM Filter and Smoother"></a>Visual Place Recognition via HMM Filter and Smoother</h1><blockquote><p><strong>Abstract</strong>—Visual position recognition affects the safety and accuracy of automatic driving. To accurately identify the location, this paper studies a visual place recognition algorithm based on HMM filter and HMM smoother. Firstly, we constructed the traffic situations in Canberra city. Then the mathematical models of the HMM filter and HMM smoother were performed. Finally, the vehicle position was predicted based on the algorithms. Experiment results show that HMM smoother is better than HMM filter in terms of prediction accuracy. </p></blockquote><h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>Visual place recognition is a well-defined problem: given an image taken at a certain place, people, animals, computers or robots should judge whether the corresponding place of the image has been seen before; If it has been seen, where is the image taken [1]. This technique provides basic position information for automatic driving, and its accuracy directly determines the safety and accuracy of automatic driving. Therefore, the research on visual place recognition is particularly basic and important.</p><p>Due to the large amount of data, low latency and the limitation of the hardware in autonomous driving vison-based scenarios, it is required to develop an algorithm that can not only process the image data output by the camera sensor quickly and efficiently but also reduce the storage and computing burden for the hardware chips.  </p><p>For vision-based location recognition, the sophisticated local-invariant feature extractors, such as Scale-Invariant Feature Transformation and Speed-Up Robust Features, hand-crafted global image descriptors, such as Generalized Search Tress, and the bag-of-visual-words approach were widely used [2]. Recent years, with the development of the deep learning, the convolution neural network is a widely used technique. It offers state-of-the-art performance on many category-level recognition tasks, such as object classification, scene recognition, and image classification.  </p><p>However, all the techniques above required not only high-performance computing of the hardware but also a huge storage of the memory. It needs to store all the past picture data and compare it with the sensor’s current measurements, which will highly increase the cost of the autonomous vehicle.</p><p>Markov chain has the characteristics of the current state only depends on the previous state, fast computation, easy deployment and does not require too high performance. Hidden Markov Chains only require the measurements of each current state. This feature can significantly improve the speed of the recognition and highly reduce the amount of data to be processed and stored for the place recognition. In this paper, we proposed two methods based on Hidden Markov Chains.</p><p>Filtering is the problem if estimating the current state at this time given the history of the sensor (camera) measurements. Hidden Markov filter obtains the estimated current state based on the past measurements, while hidden Markov Smoother obtains the estimated state based on the measurements before and after it, which are forward pass and backward pass. It is the problem of estimating the state at this time given past, present and future sensor measurements. The key point in the algorithms above is to obtain a reasonable transmission matrix that can compute to estimate the current state of the autonomous driving vehicle. On the basis of the filter, the smoother introduces more state data, which will improve the accuracy of location recognition.</p><p>Thus, in this paper, the filter and smoother of Hidden Markov Chains were used in place recognition. It is expected that the algorithms can avoid the hardware performance requirements while maintaining high accuracy. It can improve computing speed and simplify the complexity of location recognition algorithms. This paper is organized as follows. In section 1, we introduced the topic of this paper, system modeling and problem statement is in section 2, the proposed algorithm is described in section 3, detailed simulation result is shown in section 4 and in section 5 summarize this paper.</p><h1 id="SYSTEM-MODELING"><a href="#SYSTEM-MODELING" class="headerlink" title="SYSTEM MODELING"></a>SYSTEM MODELING</h1><p>As mentioned above, this paper mainly discusses the problem of re-localization in autonomous driving systems. Different from existing hierarchical clustering-based bag-of-words methods, this paper introduces a directed graph-based Hidden Markov Model. Combined with observation it can relocate vehicle positions. This paper uses a Hidden Markov Model based filter to solve the location. In addition, this paper also uses HMM based smoother to verify the results.</p><h2 id="map-prior-probability"><a href="#map-prior-probability" class="headerlink" title="map prior probability"></a>map prior probability</h2><p>In order to describe the actual position of the vehicle in the map, we establish a position set $V&#x3D;{p_1,p_2,\ldots p_i,\ldots,p_M}$. Where $p_i\in V$ represents a certain position in the map. Let $E_{ij}$ represent the connection from the $p_i$ to the $p_j$ , where $i,j \in M$. Let $\Phi_{ij}$ represent the transition probability from position $p_i$ to position $p_j$, that is, the probability that the next status is $p_j$ when the current position is $p_i$, which also can be represented as $P\left(p_j\middle| p_i\right)$. Since $\Phi_{ij}$ is expressed as probability, the sum of transition probabilities should be one.</p><p>$$<br>\sum_{j}^{j\in s}\Phi_{i,j}&#x3D;1<br>$$</p><p>where <em>s</em> is the position directly connected to the current position. Since the transition probability is position dependent, $E_{ij}\neq E_{ji}$, which is $P\left(p_j\middle| p_i\right)\neq P\left(p_i\middle| p_j\right)$. From this we can build a directed graph.</p><p>$$<br>G\left(V,E,\Phi\right)<br>$$</p><p>In the graph, $V, E, \Phi$ represent the vertex, edge, and edge weight, respectively, and the specific definitions are as above. As shown in the figure below, this project uses the Canberra city center map as the system map then simulates the status by combining the actual traffic flow data. The red vertex in the figure represents the position $p_i$ in the model, and the blue edge represents that the position $p_i$ is directly connected to $p_j$, that is, $P\left(p_j\middle| p_i\right)\neq0$. We establish different transition probabilities $\Phi_{ij}$ for different edges according to the traffic flow. At vertex such as 1 to 9 on the main road, there will be a higher probability of going straight and a lower probability of stopping. Take node 1 as an example,  $\Phi_{1,2}&gt;\Phi_{1,70}&gt;\Phi_{1,1}$. For nodes that are not on the main road, such as node 66, the probability of driving in each direction is roughly the same, and there is also a certain probability of parking. The full transition probability table designed in this paper is attached in the appendix.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image1.png"></p><center>Fig.1 The connection between positions in the simulated system.</center><h2 id="vehicle-position-measurement"><a href="#vehicle-position-measurement" class="headerlink" title="vehicle position measurement"></a>vehicle position measurement</h2><p>Let the observation result of the vehicle at a certain position $x$ be $y_x$, where $y,x \in V$. The vehicle may have different observations at this location, and the probability of observing different positions can be expressed as the following probability. $P\left(y&#x3D;p_j\middle| x&#x3D;p_i\right)$, where $\sum_{p_j}^{p_j\in V}{P\left(y&#x3D;p_j\middle| x&#x3D;p_i\right)}&#x3D;1.$</p><p>This project uses designed discrete observation probabilities then add Gaussian noise to simulate real observations. Let the preset discrete observation probability be $P_c$, and the superimposed Gaussian noise be $P_{gaussian}$. </p><p>In this project, different observation probabilities are designed according to different road conditions. Among them, the probability between the nodes directly connected to the node is not 0, and the observation probability of the node cannot directly connect to the current node is 0. Since this project believes that the sensor itself has high measurement accuracy, the probability of correct observation is much greater than the probability of incorrect observation, namely.</p><p>$$<br>P\left(y&#x3D;p_i\middle| x&#x3D;p_i\right)\gg P\left(y\neq p_i\middle| x&#x3D;p_i\right)<br>$$</p><p>On average $P\left(y&#x3D;p_i\middle| x&#x3D;p_i\right)\approx0.7$. The final observation probability of the vehicle still needs to add Gaussian noise on the basis of the discrete probability described above to simulate the noise situation in the observation, then normalize it so that the probability sum is 1. The Gaussian noise superimposed in this project is $\mu&#x3D;p_i,\delta&#x3D;1$. The final observation probability is as follows:<br>$$<br>P\left(y&#x3D;p_j\middle| x&#x3D;p_i\right)<br>$$</p><p>$$<br>&#x3D;\left(P_c\left(y&#x3D;p_j\middle| x&#x3D;p_i\right)+P_{gaussian}\left(p_j;p_i\right)\right)\times\delta<br>$$</p><p>$$<br>P_{gaussian}\left(p_j;p_i\right)&#x3D;\frac{1}{\sqrt{2\pi}}exp{\left(-\frac{\left(p_j-p_i\right)^2}{2}\right)}<br>$$</p><p>where $\delta$ is the normalization coefficient. </p><p>$$<br>\delta&#x3D;1+\sum_{p_j}^{p_j\in V}{P_{gaussian}\left(p_j;p_i\right)}<br>$$</p><h1 id="PROPOSED-INFERENCE-ALGORITHM"><a href="#PROPOSED-INFERENCE-ALGORITHM" class="headerlink" title="PROPOSED INFERENCE ALGORITHM"></a>PROPOSED INFERENCE ALGORITHM</h1><p>HMM is an unobservable motion sequence randomly generated by a hidden Markov chain. We use HMM filter and HMM smoother for visual place recognition. In this way, we could use time sequence of the images and the high relationship between the time and position due to the limited movement [3]. The mathematical details of HMM filter and HMM smoother are shown below.</p><h2 id="HMM-filter"><a href="#HMM-filter" class="headerlink" title="HMM filter"></a>HMM filter</h2><p>he vector ${\hat{X}}_k\in R^n$ is defined as the filter estimate, which represents the conditional probability mass function of $X_k$ given $y_1,y_2,\ldots,y_k$:<br>$$<br>{\hat{X}}_k&#x3D;\left[\begin{matrix}p\left(X_k&#x3D;1\middle| y_1,y_2,\ldots,y_k\right)\<br> p\left(X_k&#x3D;2\middle| y_1,y_2,\ldots,y_k\right)\<br>  \vdots\<br>   p\left(X_k&#x3D;n\middle| y_1,y_2,\ldots,y_k\right)\<br>   \end{matrix} \right]<br>$$</p><p>The matrix $A\in R^{n\times n}$ is defined as the transition probability matrix:</p><p>$$<br>A&#x3D;\left[\begin{matrix}p\left(X_k&#x3D;1\middle| X_{k-1}&#x3D;1\right)&amp;\cdots&amp;p\left(X_k&#x3D;1\middle| X_{k-1}&#x3D;n\right)\ \vdots&amp;\ddots&amp;\vdots\ p\left(X_k&#x3D;n\middle| X_{k-1}&#x3D;1\right)&amp;\cdots&amp;p\left(X_k&#x3D;n\middle| X_{k-1}&#x3D;n\right)\ \end{matrix}\right]<br>$$<br>Diagonal matrix $B(y_k)\in R^{n\times n}$ is defined with likelihoods for measurement $y_k$ on its diagonal:</p><p>$$<br>B\left(y_k\right)&#x3D;\left[\begin{matrix}p\left(y_k\middle| X_{k-1}&#x3D;1\right)&amp;\cdots&amp;0\ \vdots&amp;\ddots&amp;\vdots\ 0&amp;\cdots&amp;p\left(y_k\middle| X_{k-1}&#x3D;n\right)\ \end{matrix}\right]<br>$$</p><p>Then we could written the HMM filter as follows:</p><p>$$<br>{\hat{X}}_k&#x3D;N_k^{-1}B\left(y_k\right) A{\hat{X}} _{k-1}<br>$$</p><p>where $A{\hat{X}}_{k-1}$ represents the “prediction step”,  $N_k^{-1}B\left(y_k\right)$ represents the “update step”, and $N_k\in R$ normalizes to ensure ${\hat{X}}_k$ is a probability mass function, i.e., </p><p>$$<br>N_k&#x3D;\sum_{i&#x3D;1}^{n}{V(i)} with  V&#x3D;B(y_k)A{\hat{X}}_{k-1}<br>$$</p><h2 id="HMM-smoother"><a href="#HMM-smoother" class="headerlink" title="HMM smoother"></a>HMM smoother</h2><p>The first step for HMM smoother called Forward Pass. In this step, we have to calculate the unnormalized filter estimate. The details are as follows.</p><ul><li>The vector is defined as the unnormalized filter estimate:</li></ul><p>$$<br>\alpha_k&#x3D;\left[\begin{matrix}p\left(X_k&#x3D;1,y_1,y_2,\ldots,y_k\right)\ p\left(X_k&#x3D;2,y_1,y_2,\ldots,y_k\right)\ \vdots\ p\left(X_k&#x3D;n,y_1,y_2,\ldots,y_k\right)\ \end{matrix}\right]<br>$$</p><ul><li>When k change from 1 to T, compute the unnormalized filter estimate:<br>$$<br>\alpha_k&#x3D;B\left(y_k\right)A\alpha_{k-1}<br>$$</li></ul><p>with$\alpha_0&#x3D;\pi_0$</p><p>The second step called Backward Pass. In this step, we have to calculate the unnormalized backward filter estimate. The details are as follows.</p><ul><li><p>The vector $\beta_k\in R^n$ is defined as the unnormalized backward filter estimate:<br>$$<br>\beta_k&#x3D;\left[\begin{matrix}p\left(X_k&#x3D;1,y_{k+1},y_{k+2},\ldots,y_T\right)\ p\left(X_k&#x3D;2,y_{k+1},y_{k+2},\ldots,y_T\right)\ \vdots\ p\left(X_k&#x3D;n,y_{k+1},y_{k+2},\ldots,y_T\right)\ \end{matrix}\right]<br>$$</p></li><li><p>When k change from T to 1, compute the unnormalized backward filter estimate:<br>$$<br>\beta_{k-1}&#x3D;A^\prime B\left(y_k\right)\beta_k<br>$$</p></li></ul><p>where $\beta_T&#x3D;1$ representing the vector of ones, and $ A^\prime$ represents the transpose of A.</p><p>The final step called Multiply and Normalize. In this step, we have to calculate the smoother estimate, which represents the final result. The details are as follows.</p><ul><li><p>The vector $ \gamma_k\in R^n$ is defined as the smoother estimate:<br>$$<br>\gamma_k&#x3D;\left[\begin{matrix}p\left(X_k&#x3D;1\middle| y_1,y_2,\ldots,y_T\right)\ p\left(X_k&#x3D;2\middle| y_1,y_2,\ldots,y_T\right)\ \vdots\ p\left(X_k&#x3D;n\middle| y_1,y_2,\ldots,y_T\right)\ \end{matrix}\right]<br>$$</p></li><li><p>When k change from 0 to T, computer and normalize via elementwise multiplication:<br>$$\gamma_k\left(x_k\right)&#x3D;\frac{\alpha_k\left(x_k\right)\beta_k\left(x_k\right)}{\sum{\alpha_k\left(x_k\right)\beta_k\left(x_k\right)}}$$</p></li></ul><h1 id="Simulation-Results"><a href="#Simulation-Results" class="headerlink" title="Simulation Results"></a>Simulation Results</h1><p>We selected 105 traffic intersections in Canberra central, and found the current location of cars through HMM filter and HMM smoother model. To make comparison, we set the length of the state sequence to be generated to 50. It was required to design an evaluation method. In this simulation, we used accuracy.</p><p>$$<br>accuracy&#x3D;\frac{Number\ of\ correct\ estimated\ states}{Number\ of\ all\ states}<br>$$</p><p>The simulation results are shown below.</p><h2 id="Initial-state-5"><a href="#Initial-state-5" class="headerlink" title="Initial state &#x3D; 5"></a>Initial state &#x3D; 5</h2><p>We started experiment from setting initial state as 5 and did the following experiments.</p><h3 id="Initial-state-5-Sigma-1"><a href="#Initial-state-5-Sigma-1" class="headerlink" title="Initial state&#x3D;5, Sigma &#x3D; 1"></a>Initial state&#x3D;5, Sigma &#x3D; 1</h3><p>Firstly, we set the covariance of Gaussian Variance as 1. The HMM filter result can be seen in the image below.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image3.png"></p><center>Fig.2 Filter simulation: Initial state=5, sigma=1</center><p>The accuracy of HMM filter is 0.76.</p><p>The result of HMM smoother can be seen in the image below.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image4.png"></p><center>Fig.3 Smoother simulation: Initial state=5, sigma=1</center><p>The accuracy of HMM Smoother is 0.88.</p><p>The image below shows the performance of filter and smoother when initial state is 5 and sigma is 1.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image5.png"></p><center>Fig.4 Comparison: Initial state=5, sigma=1</center><h3 id="Initial-state-5-Sigma-2"><a href="#Initial-state-5-Sigma-2" class="headerlink" title="Initial state&#x3D;5, Sigma &#x3D; 2"></a>Initial state&#x3D;5, Sigma &#x3D; 2</h3><p>When setting the covariance of Gaussian noise is 2, the result of HMM filter can be seen in the image below.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image6.png"></p><center>Fig.5 Filter simulation: Initial state=5, sigma=2</center><p>The accuracy of HMM filter when sigma equals 2 is 0.68.</p><p>The result of HMM smoother can be seen in the image below.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image7.png"></p><center>Fig.6 Smoother simulation: Initial state=5, sigma=2</center><p>The accuracy of HMM smoother is 0.82.</p><p>The image below shows the performance of filter and smoother when initial state is 5 and sigma is 2.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image8.png"></p><center>Fig.7 Comparison: Initial state=5, sigma=2</center><h2 id="Initial-state-90"><a href="#Initial-state-90" class="headerlink" title="Initial state &#x3D; 90"></a>Initial state &#x3D; 90</h2><p>Then we set the initial state as 90, sigma &#x3D; 1</p><p>Similarly, we set the covariance of Gaussian Variance as 1. The HMM filter result can be seen in the image below.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image9.png"></p><center>Fig.8 Filter simulation: Initial state=90, sigma=1</center><p>The accuracy of HMM filter in this assumption is 0.76.</p><p>The result of HMM smoother can be seen below.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image10.png"></p><center>Fig.9 Smoother simulation: Initial state=90, sigma=1</center><p>The accuracy of HMM smoother in this assumption is 0.82.</p><p>The image below shows the performance of filter and smoother when initial state is 90 and sigma is 1.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image11.png"></p><center>Fig.10 Comparison: Initial state=90, sigma=1</center><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>We record the accuracy in the figure above in the following table.</p><p>Table 1. The accuracy of HMM Filter and HMM Smoother</p><table><thead><tr><th></th><th><strong>HMM filter accuracy</strong></th><th><strong>HMM smoother accuracy</strong></th></tr></thead><tbody><tr><td>Initial state&#x3D;5 Sigma &#x3D; 1</td><td>76%</td><td>88%</td></tr><tr><td>Initial state&#x3D;5 Sigma &#x3D; 2</td><td>68%</td><td>82%</td></tr><tr><td>Initial state&#x3D;90 Sigma &#x3D; 1</td><td>76%</td><td>82%</td></tr></tbody></table><p>It could be drawn the following conclusions.</p><p>Firstly, it can be found that at the beginning, both the filter and smoother show a good performance. Then it can be seen that the smoother validates a more accurate estimations of the state. We could see that the error between the true and estimated state of the HMM smother is less than the error of the HMM filter. Especially at the end of the states, the results of the smoother are more consistent with the real state.</p><p>Due to the HMM smoother considered not only the past measurements of the autonomous vehicle, but also the future states of the vehicle. In other words, through backward pass, more knowledge is considered into the model when estimating the current state, which will lead a better estimation, while the filter can only estimate the state by using the past knowledge. Thus, it is reasonable that as the time went by, the advantages of the smoother over the filter become more and more obvious.</p><p>However, the smoother will meet more limitations in practice. In practical scenarios, it is difficult to obtain a large number of subsequent measurements of the state to be estimated. Thus, to use the smoother in practice, it is required more sensors on the vehicle and a good fusion of the sensors.</p><p>Secondly, the added Gaussian noise when generated measurements have also made affects in HMM filter and HMM smoother. It could be found that the higher the variance of the noise, the worse the results of the filter and smoother.</p><p>Thirdly, for the states where the mismatch happened, the confusion matrix affected the HMM filter and smoother. In practice, it is the accuracy of the sensor. Due to the errors in sensors when capture the places, the algorithm cannot obtain absolutely accurate measurements as the input, which will lead mismatches in the simulations results. What’s more, Bayesian algorithm is based on possibilities. If the prior belief or likelihood are inaccurate, the result will be bound to a mismatch. For this point, the algorithm like HMM smoother that introduces more knowledge will have an even greater advantage. Especially in the use of autonomous driving which requires extreme security and reliability, HMM smoother will be a better choice.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this paper, HMM filter and HMM smoother were used for visual position recognition. By comparing the state observation results under different initial positions, we found that the HMM smoother had better performance. By comparing different gaussian noise, we found that the higher the noise variance, the worse the results of filter and smoother. Besides, after the theoretical analysis, we thought that the errorswhich led to the difference between the real states and the simulation resultsare the accuracy of the sensor. Thus, In order to improve the accuracy of position recognition, we put forward the followingconclusions:firstly, HMM smoother performs a better performance with more limitations.Secondly, the sensors which used to do measurements played an important role in predictions. Improving the performance of the sensors will be an essential solution if the prediction algorithmdoesn’t work well.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>S. Lowry, N. Sunderhauf, P. Newman, J. J. Leonard, D. Cox, P. Corke, and M. J. Milford, “Visual place recognition: A survey,” IEEE Transactions on Robotics, vol. 32, no. 1, pp. 1–19, 2016.</li><li>Z. Zeng, J. Zhang, X. Wang, Y. Chen, and C. Zhu, “Place recognition: An overview of Vision Perspective,” Applied Sciences, vol. 8, no. 11, p. 2257, 2018.</li><li>D. Doan, Y. Latif, T.-J. Chin, Y. Liu, T.-T. Do, and I. Reid, “Scalable place recognition under appearance change for autonomous driving,” 2019 IEEE&#x2F;CVF International Conference on Computer Vision (ICCV), 2019.</li></ol><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="A-The-transition-probability-table"><a href="#A-The-transition-probability-table" class="headerlink" title="A.The transition probability table"></a>A.The transition probability table</h2><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image12.png"></p><p><strong>Figure</strong>  <strong>A.</strong> the full transition matrix, since the matrix has 105 cols and 105 rows, it can only be presented as a figure. This figure has 105x105 pixels, each pixel represents one of the elements in the matrix. The brightness of pixels represents the probability of that element. The lighter pixel will have a larger probability. The sum of each cols are equal to one.</p><h2 id="B-The-observation-matrix"><a href="#B-The-observation-matrix" class="headerlink" title="B.The observation matrix"></a>B.The observation matrix</h2><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/image13.png"></p><p><strong>Figure B</strong> The full observation matrix. This is a 105x105 figure, where each pixel represents one of the elements in observation matrix, the definition of brightness is the same as transition matrix figure. The average value of diagonal elements is 0.7.</p><h1 id="PDF-Version-Download"><a href="#PDF-Version-Download" class="headerlink" title="PDF Version Download"></a>PDF Version Download</h1><p>The PDF version of this article can be downloaded from the following link:</p><p><a href="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/visual_place_recog/Report.pdf">Download Here</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Visual-Place-Recognition-via-HMM-Filter-and-Smoother&quot;&gt;&lt;a href=&quot;#Visual-Place-Recognition-via-HMM-Filter-and-Smoother&quot;</summary>
        
      
    
    
    
    
    <category term="Computer Vision" scheme="https://blog.zzshub.cn/tags/Computer-Vision/"/>
    
    <category term="State Estimation" scheme="https://blog.zzshub.cn/tags/State-Estimation/"/>
    
  </entry>
  
  <entry>
    <title>EasyMVS -- A Simple Multi-View Stereo lib</title>
    <link href="https://blog.zzshub.cn/2022/10/13/EasyMVS/"/>
    <id>https://blog.zzshub.cn/2022/10/13/EasyMVS/</id>
    <published>2022-10-13T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EasyMVS-A-Simple-Multi-View-Stereo-lib"><a href="#EasyMVS-A-Simple-Multi-View-Stereo-lib" class="headerlink" title="EasyMVS: A Simple Multi-View Stereo lib"></a>EasyMVS: A Simple Multi-View Stereo lib</h1><p>EasyMVS is a simple SFM(Structure From Motion) and MVS(Multi-View Stereo) project, which aims to perform 3D reconstruction tasks quickly and concisely with existing algorithms for Monocular, Stereo, RGBD cameras. This project currently supports OpenCV pinhole cameras but can be easily extended to other types of cameras, such as fish-eye cameras. </p><p><img src="/./image/EasyMVS/PipelineSimple.svg"></p><center> overview of the EasyMVS 3D reconstruction pipeline </center><hr><h1 id="THIS-PROJECT-IS-NOT-FINISHED-YET-CANNOT-ACHIEVE-DESIRED-TASKS-AT-CURRENT-STAGE"><a href="#THIS-PROJECT-IS-NOT-FINISHED-YET-CANNOT-ACHIEVE-DESIRED-TASKS-AT-CURRENT-STAGE" class="headerlink" title="THIS PROJECT IS NOT FINISHED YET, CANNOT ACHIEVE DESIRED TASKS AT CURRENT STAGE!"></a>THIS PROJECT IS NOT FINISHED YET, CANNOT ACHIEVE DESIRED TASKS AT CURRENT STAGE!</h1><hr><h1 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h1><p>We have tested the library on Windows 11 with MSVC v143, but it should be easy to compile on other platforms such as Linux or MacOS. <strong>We strongly recommend users use Vcpkg to manage the following libs.</strong> <a href="https://vcpkg.io/">Vcpkg</a></p><h2 id="C-17-Compilers"><a href="#C-17-Compilers" class="headerlink" title="C++17 Compilers"></a>C++17 Compilers</h2><p>We use c++17 standard to leverage the performance. Compilers that support C++17 standard can be found in the following link. <a href="https://en.cppreference.com/w/cpp/compiler_support">C++ compiler support</a></p><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p>This project put Qt as the center position for communication between each sub-tasks and thread management. Thanks to Qt’s signal-slot features, a pipelined workflow can be easily implemented with low coupling. We use Qt for visualization as well. This project requires Qt5 or Qt6. Download and install instructions can be found at <a href="https://download.qt.io/">https://download.qt.io/</a></p><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><p>We use OpenCV to manipulate images and features. Download and install instructions can be found at: <a href="http://opencv.org/">http://opencv.org</a>. Required at least 4.0. Tested with OpenCV 4.5.1.</p><h2 id="Eigen-3-and-Sophus"><a href="#Eigen-3-and-Sophus" class="headerlink" title="Eigen 3 and Sophus"></a>Eigen 3 and Sophus</h2><p>We use Eigen and Sophus for better matrices operations. Download and install instructions for Eigen can be found at: <a href="http://eigen.tuxfamily.org/">http://eigen.tuxfamily.org</a>. Required at least 3.1.0. Install instructions for Sophus can be found at: <a href="https://github.com/strasdat/Sophus">https://github.com/strasdat/Sophus</a></p><h2 id="DBoW2"><a href="#DBoW2" class="headerlink" title="DBoW2"></a>DBoW2</h2><p>This project uses the standard version of the DBoW2 library to perform place recognition. Download and install instructions can be found at: <a href="https://github.com/dorian3d/DBoW2">https://github.com/dorian3d/DBoW2</a></p><h2 id="PCL"><a href="#PCL" class="headerlink" title="PCL"></a>PCL</h2><p>This project uses PCL for point-cloud processing such as filtering and surface reconstruction. Download and install instructions can be found at: <a href="https://pointclouds.org/">https://pointclouds.org/</a> <strong>To support Point Cloud visualization with Qt, PCL has to be built from source code with Qt Options on. However, we strongly recommend users use Vcpkg to manage this and other libs. vcpkg can automatically build the PCL with correct configurations by simply typing the following command.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install pcl[qt,vtk,visualization]</span><br></pre></td></tr></table></figure><h2 id="Ceres"><a href="#Ceres" class="headerlink" title="Ceres"></a>Ceres</h2><p>This project uses ceres for optimization tasks, such as bundle adjustment. Download and instructions can be found at: <a href="http://www.ceres-solver.org/">http://www.ceres-solver.org/</a></p><h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><ul><li><a href="https://github.com/nlohmann/json">nlohmann_json</a> &gt;&#x3D;3.10.5 for json file read and write. </li><li><a href="https://github.com/p-ranav/argparse">argparse</a> &gt;&#x3D; 2.2 for parsing from the command line.</li></ul><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>Some demos are listed in the app folder, including training your own BoW database from image sets, performing structure from motion from picture input and constructing the sparse map, or reading images from a video and storing data in the specially designed JSON format. Details of applications can be found in the <code>./app</code> folder.</p><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p>this project designed a series of data structures including <code>Frames</code>, <code>Mappoints</code>, <code>Maps</code> to leverage the 3D reconstruction process. The details of how each data structure works are shown in the <a href="https://blog.zzshub.cn/EasyMVS/md__class_definition_draft.html">Data Structure</a> document. More information could also be obtained from each class’s pages.</p><h1 id="Workflow-and-Pipeline"><a href="#Workflow-and-Pipeline" class="headerlink" title="Workflow and Pipeline"></a>Workflow and Pipeline</h1><p>Similar to many existing SFM projects, this project uses pipeline-based workflow as well. We designed at most 11 sub-tasks from image acquisition to 3D mesh texturing (not all sub-tasks are required for different applications) in the pipeline. This pipeline is implemented based on Qt’s signal-slot framework, each sub-tasks has a “Triggered” slot and a “finished” signal. Sub-tasks will run in each sub-tasks “Triggered” slot when this sub-task is triggered with input, and when the tasks are accomplished the “finished” signal will emit with output. This “finished” signal and output can be used as a call and input data for another sub-task. Thanks to the simple and flexible signal slot connection and disconnection method provided by Qt, the whole pipeline can be easily rearranged for different applications. Plus, the “MovetoThreads” method introduced by Qt Thread gives us a chance to allocate sub-tasks to different threads flexibly, thereby achieving parallel computing for the pipeline. More information on workflow is shown in the <a href="https://blog.zzshub.cn/EasyMVS/md__pipeline.html">Pipeline and Workflow</a> document. Detailed information could also be obtained from each class’s pages.</p><h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p><strong>Author</strong><br><a href="https://blog.zzshub.cn/">Zishun Zhou</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;EasyMVS-A-Simple-Multi-View-Stereo-lib&quot;&gt;&lt;a href=&quot;#EasyMVS-A-Simple-Multi-View-Stereo-lib&quot; class=&quot;headerlink&quot; title=&quot;EasyMVS: A</summary>
        
      
    
    
    
    
    <category term="SLAM" scheme="https://blog.zzshub.cn/tags/SLAM/"/>
    
    <category term="Computer Vision" scheme="https://blog.zzshub.cn/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>Python 软件注册信息生成器</title>
    <link href="https://blog.zzshub.cn/2021/05/13/Python-Register/"/>
    <id>https://blog.zzshub.cn/2021/05/13/Python-Register/</id>
    <published>2021-05-13T15:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件注册信息生成器"><a href="#软件注册信息生成器" class="headerlink" title="软件注册信息生成器"></a>软件注册信息生成器</h1><blockquote><p>最近一个项目由于需要防止在多台电脑上使用，也为了防止用户无限期使用，于是简单做了一个注册器。由于用户电脑不能联网，因此就不能做联网验证，所以其实用户也很容易破解。</p></blockquote><blockquote><p>开源地址: <a href="https://github.com/ZzzzzzS/Python-Register">点击这里</a></p></blockquote><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><ul><li>使用前请使用<code>pip install pycryptodome</code>命令按照软件包</li><li>使用<strong>DecryptModule.py</strong>模块进行解密运算，该模块运行在用户的计算机中。</li><li>使用<strong>EncryptModule.py</strong> 进行加密运算，该模块仅需运行在LICENSE管理员的计算机中。</li></ul><h2 id="LICENSE签发过程"><a href="#LICENSE签发过程" class="headerlink" title="LICENSE签发过程"></a>LICENSE签发过程</h2><ul><li>首先生成加密解密用的密钥对，命令如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 ./EncryptModule.py -k LICENSE</span><br><span class="line"></span><br><span class="line"><span class="comment">#将得到 LICENSE-Decrypt.key 和 LICENSE-Encrypy.key 两个文件，分别用于解密和加密</span></span><br></pre></td></tr></table></figure><ul><li>第二步根据用户机器的唯一识别码，过期时间，和加密密钥产生LICENSE文件，命令如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python ./EncryptModule.py -g </span><br><span class="line"></span><br><span class="line">Input Private Key File Name:</span><br><span class="line">LICENSE-Encrypt.key <span class="comment"># 输入加密密钥的完整名称</span></span><br><span class="line"></span><br><span class="line">Input Fingerprint Name: <span class="comment"># 输入用户提供的设备ID（解密模块找不到密钥时会自动提供）</span></span><br><span class="line">123456</span><br><span class="line"></span><br><span class="line">Input ExpireTime (e.g. 2021/07/07): <span class="comment"># 输入期望的过期时间，格式为yyyy/mm/DD</span></span><br><span class="line">2021/07/07</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>第三步，将生成的<code>LICENSE.txt</code>和<code>LICENSE-Decrypt.key</code>发送给用户，放在软件的同级文件夹下</li></ul><h2 id="LICENSE校验过程"><a href="#LICENSE校验过程" class="headerlink" title="LICENSE校验过程"></a>LICENSE校验过程</h2><p><strong>使用DecryptModule中的LicenseChecker类来判断LICENSE是否有效</strong></p><p>例程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = LicenseChecker(<span class="string">&quot;LICENSE.txt&quot;</span>, <span class="string">&quot;key-Decrypt.key&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.CheckLicenseAvailable())</span><br></pre></td></tr></table></figure><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><ul><li><p>获取用户电脑的识别码，根据用户的唯一识别码和预设的过期时间加密计算出LICENSE.txt</p></li><li><p>用户打开软件时根据LICENSE.txt 解密出识别码和过期时间，根据识别码和过期时间判断是否换电脑和是否过期</p></li></ul><h1 id="标识符的选择"><a href="#标识符的选择" class="headerlink" title="标识符的选择"></a>标识符的选择</h1><p>识别码可以选择网卡的MAC地址，但是考虑到用户计算机上可能没有网卡，因此该方法失效。因此在Windows端选择计算机序列号uuid，在Linux端使用Machine-id</p><h2 id="Linux端标识符"><a href="#Linux端标识符" class="headerlink" title="Linux端标识符"></a>Linux端标识符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/lib/dbus/machine-id <span class="comment"># 不需要root权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /sys/class/dmi/id/board_serial <span class="comment">#需要root权限</span></span><br><span class="line"><span class="built_in">cat</span> /sys/class/dmi/id/product_uuid</span><br></pre></td></tr></table></figure><h2 id="Windows端标识符"><a href="#Windows端标识符" class="headerlink" title="Windows端标识符"></a>Windows端标识符</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic csproduct get UUID <span class="comment">#不需要管理员权限</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;软件注册信息生成器&quot;&gt;&lt;a href=&quot;#软件注册信息生成器&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="python" scheme="https://blog.zzshub.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>安装黑苹果并启用secure boot</title>
    <link href="https://blog.zzshub.cn/2020/10/22/ROGhacintosh/"/>
    <id>https://blog.zzshub.cn/2020/10/22/ROGhacintosh/</id>
    <published>2020-10-22T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在ASUS-ROG枪神3上安装黑苹果并启用secure-boot"><a href="#在ASUS-ROG枪神3上安装黑苹果并启用secure-boot" class="headerlink" title="在ASUS ROG枪神3上安装黑苹果并启用secure boot"></a>在ASUS ROG枪神3上安装黑苹果并启用secure boot</h1><blockquote><p>最近瞎折腾黑苹果，其实装黑苹果现在倒是挺简单，去 ~~~gayhub~~~ github上找EFI，再去找个系统镜像，并做个启动盘，改下EFI就差不多行了。如果实在有搞不定的硬件，现在有各种渠道找人来远程做一下也挺方便。但是我发现有关secure boot的资料太少了，而且这些方法我用着都或多或少有问题，没法完全成功，因此在这里记录一下我安装的步骤，也算是提供一种不同的解决方案吧。</p></blockquote><h1 id="安装黑苹果"><a href="#安装黑苹果" class="headerlink" title="安装黑苹果"></a>安装黑苹果</h1><p>安装过程网上资料很多，这里简单记录一些注意事项和安装工具。</p><ul><li><p><font color=#ff0000 size=3><strong>注意Windows如果开启了bitlocker请一定要找到还原密钥再进行操作，不然会导致bitlocker被锁住！！！</strong></font> </p></li><li><p>注意安装前需要在bios中关闭secure boot</p></li><li><p>Mac硬盘刻录工具transmac，下载地址：<a href="https://www.acutesystems.com/scrtm.htm">https://www.acutesystems.com/scrtm.htm</a> 有15天试用期，不需要破解，反正就用一下，下次要用重新安装一下就好，本人极度鄙视破解软件等盗窃知识产权的行为！</p></li><li><p>黑果小兵的博客，<a href="https://blog.daliansky.net/">https://blog.daliansky.net</a>，里面有各种黑苹果的教程，EFI文件以及镜像，非常好用</p></li><li><p>枪神3的EFI文件，下载地址：<a href="https://github.com/DongLinghe/ROG-SCAR-III-Hackintosh-EFI">https://github.com/DongLinghe/ROG-SCAR-III-Hackintosh-EFI</a>，支持macOS 10.15.3 bug: WiFi（可以通过更换网卡修复）独立显卡（无解） 就目前来讲完美，键盘无法调节亮度的话就在设置里改快捷键，可以看看这个项目的Issues里有说。其它机型的EFI去黑果小兵的博客或者 ~~~gayhub~~~ github找</p></li></ul><h1 id="让黑苹果也能用上secure-boot"><a href="#让黑苹果也能用上secure-boot" class="headerlink" title="让黑苹果也能用上secure boot"></a>让黑苹果也能用上secure boot</h1><blockquote><p>刚才简单记录了一下黑苹果的安装，下面进入正题——secure boot</p></blockquote><h2 id="secure-boot是什么以及为什么需要secure-boot"><a href="#secure-boot是什么以及为什么需要secure-boot" class="headerlink" title="secure boot是什么以及为什么需要secure boot"></a>secure boot是什么以及为什么需要secure boot</h2><p>UEFI安全引导（Secure Boot）的核心职能就是利用数字签名来确认EFI驱动程序或者应用程序是否是受信任的。[1]</p><p>这个东西的大概意思就是说对系统的bootloader进行限制，只有经过签名认证的系统才能被启动，这样可以有效防止很多恶意程序的运行。比如在Windows boot manager启动以前就偷偷插入一段恶意程序的bootloader，然后再启动Windows boot manager，由于启动顺序早于操作系统，所以权限很高，操作系统也很难防御，并且启动过程隐蔽，用户也很难发现，这样会带来很大的安全问题，因此我们需要secure boot来让只被允许的bootloader启动。</p><h2 id="为什么黑苹果和secure-boot会有关系"><a href="#为什么黑苹果和secure-boot会有关系" class="headerlink" title="为什么黑苹果和secure boot会有关系"></a>为什么黑苹果和secure boot会有关系</h2><p>由前文所述，secure boot只允许受过签名的boot loader启动。UEFI 规定，主板出厂的时候，可以内置一些可靠的公钥。然后，任何想要在这块主板上加载的操作系统或者硬件驱动程序，都必须通过这些公钥的认证。也就是说，这些软件必须用对应的私钥签署过，否则主板拒绝加载。[2]常用的操作系统都有签名，但是我们的黑苹果没有，因此就需要自己插入一个公钥然后用自己的签名，或者找一个签了名的prebootloader来启动bootloader。</p><p>虽然关闭secure boot就能正常使用黑苹果，但是部分机型关闭secure boot后启动界面就会变成很难看的大红色(surface系列)，并且出于安全方面的考虑，也必须要打开secure boot</p><h2 id="让secure-boot支持黑苹果"><a href="#让secure-boot支持黑苹果" class="headerlink" title="让secure boot支持黑苹果"></a>让secure boot支持黑苹果</h2><p>由前文所述，有两种方式来支持。这里选择的是第二种，也就是利用已经签名的bootloader来load黑苹果的boot loader。这里使用了 ~~~gayhub~~~ github上找的<a href="https://github.com/ValdikSS/Super-UEFIinSecureBoot-Disk">Super-UEFIinSecureBoot-Disk</a>项目。</p><p>抄一段它的核心功能：</p><blockquote><p>disk is fully functional with UEFI Secure Boot mode activated. It can launch any operating system or .efi file, even with untrusted, invalid or missing signature.</p></blockquote><p>根据这个项目的描述，我们需要用它提供的一个镜像做启动盘，然后这个启动盘会自动添加一个公钥进UEFI，在然后我们用这个启动盘里的EFI文件夹下的boot文件夹替换黑苹果的boot文件，最后再将clover文件夹下的bootx64.efi改名为grubx64_real.efi并复制到boot文件夹下，就好了。最后在UEFI中打开secure boot也能用了。</p><p><strong>但实际上它提供的启动盘并不能在我的电脑上启动(能启动的可以参考这个项目的文档，不能启动的看我操作)。</strong>这个启动盘干的工作就是往UEFI里注册了一个公钥，我们自己来手动注册也可以，步骤如下。</p><ul><li><p>首先制作启动盘，制作工具和镜像链接在后文有提到，制作完成后如下图所示。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/media/image/2601694036151687.jpg" alt="2601694036151687"></p><p>其中<code>ENROLL_THIS_KEY_IN_MOKMANAGER.cer</code>就是需要注册的公钥文件。</p></li><li><p>之后进入UEFI设置，注意不同机型可能存在差异，在secure-&gt;secure boot选项卡中选择 <code>key exchange keys</code></p></li></ul><p><img src="https://zzshubimage-1253829354.cosbj.myqcloud.com/media/image/03698316002590052.jpg" alt="03698316002590052"></p><ul><li>选择<code>Append</code>添加证书</li></ul><p><img src="https://zzshubimage-1253829354.cosbj.myqcloud.com/media/image/014435539452277268.jpg" alt="014435539452277268"></p><ul><li>选择<code>No</code>从外部设备添加</li></ul><p><img src="https://zzshubimage-1253829354.cosbj.myqcloud.com/media/image/07049956718966244.jpg" alt="07049956718966244"></p><ul><li>找到启动盘，并添加<code>ENROLL_THIS_KEY_IN_MOKMANAGER.cer</code></li></ul><p><img src="https://zzshubimage-1253829354.cosbj.myqcloud.com/media/image/40736526710036935.jpg" alt="40736526710036935"></p><p><img src="https://zzshubimage-1253829354.cosbj.myqcloud.com/media/image/9272594442544191.jpg" alt="9272594442544191"></p><p>好了，到这里为止公钥就添加好了，之后的步骤就是和项目里所述的相同了。</p><ul><li><p>将启动盘<code>/EFI/boot/</code>中的所有文件复制到黑苹果的<code>/EFI/boot/</code>中</p></li><li><p>将黑苹果<code>/EFI/clover/bootx64.efi</code>文件复制到黑苹果的<code>/EFI/boot/</code>中并改名为<code>grubx64_real.efi</code></p></li><li><p>在UEFI中打开secure boot，并可以正常进入黑苹果系统。</p></li></ul><h1 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h1><p>镜像文件：<a href="https://github.com/ValdikSS/Super-UEFIinSecureBoot-Disk/releases/download/3/Super-UEFIinSecureBoot-Disk_minimal_v3.zip">https://github.com/ValdikSS/Super-UEFIinSecureBoot-Disk/releases/download/3/Super-UEFIinSecureBoot-Disk_minimal_v3.zip</a></p><p>启动盘写入工具：<a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><p>[1] 作者：老狼<br>链接：<a href="https://zhuanlan.zhihu.com/p/25279889">https://zhuanlan.zhihu.com/p/25279889</a><br>来源：知乎</p></li><li><p>[2] 作者: Bugprogrammer<br>链接: <a href="https://www.bugprogrammer.me/2019/07/06/clover-with-secure-boot.html">https://www.bugprogrammer.me/2019/07/06/clover-with-secure-boot.html</a><br>来源: Bugprogrammer的博客</p></li></ul><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;在ASUS-ROG枪神3上安装黑苹果并启用secure-boot&quot;&gt;&lt;a href=&quot;#在ASUS-ROG枪神3上安装黑苹果并启用secure-boot&quot; class=&quot;headerlink&quot; title=&quot;在ASUS ROG枪神3上安装黑苹果并启用secure</summary>
        
      
    
    
    
    
    <category term="Hacintosh" scheme="https://blog.zzshub.cn/tags/Hacintosh/"/>
    
  </entry>
  
  <entry>
    <title>使用VSCode开发Cortex-M系列芯片</title>
    <link href="https://blog.zzshub.cn/2020/10/04/VscodeCortexM/"/>
    <id>https://blog.zzshub.cn/2020/10/04/VscodeCortexM/</id>
    <published>2020-10-04T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用VSCode开发Cortex-M系列芯片"><a href="#使用VSCode开发Cortex-M系列芯片" class="headerlink" title="使用VSCode开发Cortex-M系列芯片"></a>使用VSCode开发Cortex-M系列芯片</h1><blockquote><p>最近实在是受不了那些基于eclipse的IDE来开发arm了，界面太丑，而且自动补全功能不好用，于是准备使用vscode加上一系列的开源工具链来开发。其实也可以使用VisualGDB+Visual Studio来开发，但是我觉得还是太重了。</p></blockquote><blockquote><p><strong>2023&#x2F;08&#x2F;12更新，现在ST官方推出了vscode的插件了，可以直接开发STM32了，具体内容详见文末更新章节</strong></p></blockquote><h1 id="使用的工具"><a href="#使用的工具" class="headerlink" title="使用的工具"></a>使用的工具</h1><ul><li>Visual Studio Code</li><li>Cmake</li><li>GNU Arm Embedded Toolchain</li><li>OpenOCD</li><li>Cmake tool(VSC的插件)</li><li>Cortex-Debug(VSC的插件)</li></ul><h1 id="硬件介绍"><a href="#硬件介绍" class="headerlink" title="硬件介绍"></a>硬件介绍</h1><p>这里我使用的是NXP的<a href="https://www.nxp.com/design/development-boards/freedom-development-boards/mcu-boards/freedom-development-platform-for-the-kinetis-kl02-family:FRDM-KL02Z">FRDM-KL02Z</a>开发板，这个开发板使用板载的OpenSDA调试器来调试，自带的OpenSDA支持三种调试接口，分别是PEMicro，CMSIS-DAP，JLink。此外，它还支持将bin文件直接拖拽进虚拟出来的储存设备的方式来下载程序。使用不同的调试接口需要给OpenSDA刷入不同的固件，关于固件的详细信息可以参考<a href="https://www.nxp.com/design/microcontrollers-developer-resources/ides-for-kinetis-mcus/opensda-serial-and-debug-adapter:OPENSDA">NXP的网站</a>。</p><p>我在这里使用的是CMSIS-DAP的接口，主要是因为PEMicro和Jlink的GDBServer不好找(不开源，不想用盗版等原因)。</p><p>关于SDK，这里我使用的NXP的MCUXpresso。用MCUXpresso Config Tools能够生成适用于各种开发平台的工程，这里使用的是gcc工具链，它自动使用cmake来管理工程。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/VSCodeCortexM/xpresso.png"></p><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Xpresso=&gt;operation: 生成CMake工程</span><br><span class="line">Config=&gt;operation: 在VSC中配置Cmake</span><br><span class="line">Build=&gt;operation: 编译</span><br><span class="line">ConfigDebug=&gt;operation: 配置调试器</span><br><span class="line">Debug=&gt;operation: 调试</span><br><span class="line"></span><br><span class="line">Xpresso-&gt;Config-&gt;Build-&gt;ConfigDebug-&gt;Debug</span><br></pre></td></tr></table></figure><p>由此可见过程可以分为编译和下载调试两部分。编译部分使用CMake+GNU toolchain来生成elf文件。下载调试部分使用GNU toolchain中的GDB来调试，使用OpenOCD来做GDBServer。</p><h1 id="配置CMake"><a href="#配置CMake" class="headerlink" title="配置CMake"></a>配置CMake</h1><p>由MCUXpresso生成的工程自带<code>CMakeLists.txt</code>和<code>toolchain file</code>，我们只需要指定<code>toolchain file</code>给vsc的cmake插件就可以自动配置必要的编译环境了，我最开始还走了一些弯路，想着手动配置编译器。根据<a href="https://vector-of-bool.github.io/docs/vscode-cmake-tools/kits.html?highlight=toolchain">CMake的文档</a>：<strong>在<code>.vscode</code>文件夹中创建<code>cmake-kits.json</code>文件，并输入以下内容</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//cmake-kits.json</span></span><br><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arm-gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;toolchainFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/armgcc.cmake&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>然后还需要指定<code>generator</code>的类型，在工程的<code>.vscode/settings.json</code>中指定<code>MinGW Makefiles</code>。由于这个<code>toolchain file</code>中使用了<code>ARMGCC_DIR</code>这个变量，所以要么在系统的环境变量中添加，要么在<code>settings.json</code>中一并添加。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//settings.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cmake.generator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MinGW Makefiles&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cmake.environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ARMGCC_DIR&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\9 2020-q2-update\\&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;C_Cpp.default.configurationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ms-vscode.cmake-tools&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>之后在选择<code>cmake configuration</code>的时候就会出现刚刚添加的选项，选择这个选项就好了，<strong>不要自己在<code>settings.json</code>中配置编译器，prefix，args等等！</strong><br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/VSCodeCortexM/cmake.png"></p><p>完成上述配置之后，应该直接编译就能生成<code>.elf</code>文件了。上述操作等效于以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_TOOLCHAIN_FILE=&quot;armgcc.cmake&quot; -G &quot;MinGW Makefiles&quot; -DCMAKE_BUILD_TYPE=debug  .</span><br><span class="line">mingw32-make</span><br></pre></td></tr></table></figure><h1 id="配置调试"><a href="#配置调试" class="headerlink" title="配置调试"></a>配置调试</h1><p>关于Cortex-M系列的调试，这里也是用的GDB+GDBServer的模式，GDB对应的GNU工具链中的GDB，使用OpenOCD作为GDBServer。其实本可以在<code>task.json</code>中手动配置并启动OpenOCD，然后在<code>launch.json</code>中配置并启动GDB来下载调试，但是这样过程有些繁琐。好在我发现了<code>Cortex-Debug</code>这个插件，可以帮助我们完成上诉操作。由上述所述，调试配置包含启动OpenOCD和启动GDB两个部分，首先需要在全局<code>settings.json</code>中指定<code>Cortex-Debug</code>需要的GDB和openOCD的位置。之后创建<code>launch.json</code>输入以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//launch.jsom</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Cortex Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;executable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./build/Debug/hello_world.elf&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cortex-debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;servertype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;openocd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;configFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;interface/cmsis-dap.cfg&quot;</span><span class="punctuation">,</span><span class="string">&quot;target/klx.cfg&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;searchDir&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;C:\\ProgramFiles\\OpenOCD\\share\\openocd\\scripts&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;runToMain&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可能不好理解的是<code>servertype</code>,<code>configFiles</code>和<code>searchDir</code>三个字段。这都是启动openOCD相关的指令，等效命令行为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openocd.exe -s &quot;C:\ProgramFiles\OpenOCD\share\openocd\scripts&quot; -f interface/cmsis-dap.cfg -f target/klx.cfg</span><br></pre></td></tr></table></figure><p>openocd是使用tcl脚本语言来工作的。<code>-f</code>后面的两个参数分别指定了使用的调试接口和芯片类型，由于没有对应的文件这里kl02z使用klx.cfg;<code>-s</code>参数指定了搜索这些tcl脚本的位置，其实就是openocd的安装目录。</p><p>之后直接启动调试，就能自动下载并开始调试了。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/VSCodeCortexM/debug.png"></p><h1 id="2023-08-12更新"><a href="#2023-08-12更新" class="headerlink" title="2023&#x2F;08&#x2F;12更新"></a>2023&#x2F;08&#x2F;12更新</h1><p>现在STM32官方提供了vscode的支持，可以直接使用官方的插件进行开发了。可以下载使用<a href="https://marketplace.visualstudio.com/items?itemName=stmicroelectronics.stm32-vscode-extension">STM32 VS Code Extension</a> 来绕过上述过程，注意仅限STM32系列。NXP也提供了类似的插件，但是我没有使用过，可以自行尝试<a href="https://marketplace.visualstudio.com/items?itemName=NXPSemiconductors.mcuxpresso">MCUXpresso for VS Code</a>。</p><p>但值得注意的是这个插件需要依赖STM32CubeIDE或者STM32CubeCLT，然而在插件中将这些工具的安装目录给写死了，所以推荐将这些工具安装在默认位置，否则可能会出现找不到工具链的情况。</p><p>如果强迫症发作一定要修改安装目录，那么在后续的开发和调试过程中需要手动修改一些配置文件，这里给出一些参考：</p><ul><li><p>修改工程目录下<code>cmake</code>文件夹中(该文件夹由插件自动生成)的<code>gcc-arm-none-eabi.cmake</code>文件，将其中的<code>WINDOWS_ST_CLT_PATH</code>变量修改为自己的安装目录。例如 <code>set(WINDOWS_ST_CLT_PATH &quot;C:/ProgramFiles/STM32CubeCLT/GNU-tools-for-STM32/bin/&quot;)</code>。</p></li><li><p>修改<code>launch.json</code>中的<code>miDebuggerPath</code>，<code>debugServerPath</code>为自己的可执行文件，修改<code>debugServerArgs</code>中的<code>--stm32cubeprogrammer-path</code>参数为自己的安装目录。</p></li></ul><p>如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/ProgramFiles/STM32CubeCLT/GNU-tools-for-STM32/bin/arm-none-eabi-gdb.exe&quot;</span><span class="punctuation">,</span> <span class="comment">//这里修改为自己的安装目录</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:3333&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;debugServerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/ProgramFiles/STM32CubeCLT/STLink-gdb-server/bin/ST-LINK_gdbserver.exe&quot;</span><span class="punctuation">,</span> <span class="comment">//这里修改为自己的安装目录</span></span><br><span class="line">      <span class="attr">&quot;debugServerArgs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;--stm32cubeprogrammer-path C:/ProgramFiles/STM32CubeCLT/STM32CubeProgrammer/bin --swd --port-number 3333&quot;</span><span class="punctuation">,</span> <span class="comment">//这里修改为自己的安装目录</span></span><br><span class="line">      <span class="attr">&quot;serverStarted&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Waiting for connection on port .*\\.\\.\\.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtConnect&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;postRemoteConnectCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;load build/debug/build/test2.elf&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;engineLogging&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Build&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果出现<code>Error in initializing ST-LINK device.Reason: ST-LINK firmware upgrade required. Please upgrade the ST-LINK firmware using the upgrade tool.</code>错误，可能是需要升级ST-LINK固件，可以参考<a href="https://community.st.com/t5/boards-and-hardware-tools-mcus/error-in-initializing-st-link-device-reason-st-link-firmware/td-p/234661">这里</a>。</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;使用VSCode开发Cortex-M系列芯片&quot;&gt;&lt;a href=&quot;#使用VSCode开发Cortex-M系列芯片&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="kinetis" scheme="https://blog.zzshub.cn/tags/kinetis/"/>
    
    <category term="VSCode" scheme="https://blog.zzshub.cn/tags/VSCode/"/>
    
    <category term="GCC" scheme="https://blog.zzshub.cn/tags/GCC/"/>
    
  </entry>
  
  <entry>
    <title>Docker for Windows 使用初探</title>
    <link href="https://blog.zzshub.cn/2020/01/29/docker/"/>
    <id>https://blog.zzshub.cn/2020/01/29/docker/</id>
    <published>2020-01-28T16:00:23.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直以来都听说docker功能十分强大，最近闲来无事终于稍微研究了一下，确实是一个强大的工具。昨晚利用docker部署了一个webdav服务器，几分钟就弄好了，如果使用传统方法我可能甚至会搞一晚上，还容易把系统搞的一地鸡毛。利用docker可以做到开箱即用，非常方便。</p></blockquote><h1 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h1><p>Docker 包括三个基本概念:</p><ul><li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>仓库（Repository）：仓库可看着一个代码控制中心，用来保存镜像。</li></ul><p>容器与镜像的关系类似于面向对象编程中的对象与类。</p><table><thead><tr><th>docker</th><th>面向对象</th></tr></thead><tbody><tr><td>容器</td><td>对象</td></tr><tr><td>镜像</td><td>类</td></tr></tbody></table><p>以下是docker for Windows的大致结构图，对用户来说我们只需要管最上面的image和container两层即可。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/docker/%E7%BB%98%E5%9B%BE2.png"></p><h1 id="在Windows上安装docker"><a href="#在Windows上安装docker" class="headerlink" title="在Windows上安装docker"></a>在Windows上安装docker</h1><p>关于在Windows上安装docker的具体过程官方已经给出详细过程，本文就不再赘述，这里主要补充一些我在安装过程中遇到的问题。docker的安装详细步骤参见<a href="https://hub.docker.com/?overlay=onboarding">docker官网</a>(可能需要注册docker账户来查看)</p><ul><li>docker需要hyper-v服务<br>和在Linux上能直接运行Linux的docker容器不同，如果在Windows上要运行Linux容器就需要使用虚拟机来提供一个Linux的内核环境。Windows的docker使用的是Windows专业版自带的hyper-v虚拟机(貌似家庭版可以强行打开hyper-v)。所以安装docker以前需要打开Windows的hyper-v功能，若还需要Windows的docker容器就还需要打开Windows的Container功能，这些功能都可以在<code>控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能</code>中找到。安装过程中可能需要重新启动计算机。</li></ul><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/docker/hyperv.png"></p><ul><li>hypervisor冲突问题<br>在目前的计算机上一般只能存在一个hypervisor，所以使用hyper-v之前需要卸载VMware的全部服务(貌似有强行让docker运行在VMware上的方法)，个人认为hyper-v还挺好用的，还可以和Windows自带的应用程序防护，内核防护等功能配合使用，为系统提供额外的安全防护功能。</li></ul><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/docker/6F53DBC5-037D-417B-A01A-3D9E6AD3D5B2.PNG"></p><p>hyper-v是典型的type1型虚拟机</p><ul><li>建议在官网安装新版docker<br>最开始随便找了一个版本的docker安装上，但是重启电脑之后所有已经建立好的容器都无法打开，原因未知，重新安装最新版docker之后问题解决。</li></ul><h1 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h1><p>关于镜像的获取可以访问<a href="https://hub.docker.com/">docker hub的官方网站</a>，这里不仅有镜像的下载方法，也有容器的简单使用说明。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/docker/webdav.png"></p><p>上图是<a href="https://hub.docker.com/r/idelsink/webdav">webdav</a>镜像的主页.</p><p>以下是docker和镜像管理相关的命令</p><table><thead><tr><th>操作</th><th>命令</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td>搜索镜像</td><td>docker search [搜索的镜像]</td><td>docker search webdav</td><td></td></tr><tr><td>拉取镜像</td><td>docker pull [镜像名称]:[版本号]</td><td>docker pull idelsink&#x2F;webdav</td><td>若不指定版本号就自动获取最新的版本</td></tr><tr><td>查看本地镜像</td><td>docker images</td><td></td><td></td></tr><tr><td>删除本地仓库</td><td>docker rmi [镜像名称]</td><td>docker rmi ubuntu</td><td>可以同时删除多个镜像</td></tr><tr><td>登录到docker hub</td><td>docker login</td><td></td><td>开启两步验证后需要输入设置的token而不是密码</td></tr></tbody></table><h1 id="创建和运行容器"><a href="#创建和运行容器" class="headerlink" title="创建和运行容器"></a>创建和运行容器</h1><p>获取镜像之后就可以利用镜像运行容器了，运行容器相关的命令如下</p><table><thead><tr><th>操作</th><th>命令</th><th>参数</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>创建容器 <strong>[1]</strong></td><td>docker create [参数] [要使用的镜像] [要运行的指令] [要执行的命令的附加参数]</td><td></td><td>docker create ubuntu bash</td><td></td></tr><tr><td>创建并运行容器</td><td>docker run [参数] [要使用的镜像] [要运行的指令] [要执行的命令的附加参数]</td><td></td><td>docker run ubuntu bash</td><td>新建并运行Ubuntu镜像的容器，启动时执行bash命令</td></tr><tr><td></td><td></td><td>-it</td><td>docker run -it ubuntu bash</td><td>运行交互式的容器，相当于前台启动这个容器里的bash终端 <strong>[2]</strong></td></tr><tr><td></td><td></td><td>-d</td><td>docker run -d  idelsink&#x2F;webdav</td><td>后台启动容器，容器启动后直接在后台运行，不占用前台终端，并返回容器的ID</td></tr><tr><td></td><td></td><td>-p [容器中的端口]:[本机的端口]</td><td>docker run -d -p 80:80 idelsink&#x2F;webdav</td><td>将容器中的80端口映射到本机的80端口，这样就能访问容器中的80端口了。</td></tr><tr><td></td><td></td><td>-v [本机地址]:[容器内的地址]</td><td>docker run -v C:\Users:&#x2F;mnt&#x2F;C -d -p 80:80 idelsink&#x2F;webdav</td><td>将本机的文件路径挂载到容器内指定的位置，这里是将<code>C:\Users</code>挂载到<code>/mnt/C</code>位置下 <strong>[3]</strong> <strong>[4]</strong></td></tr><tr><td></td><td></td><td>-w [容器内的地址]</td><td>docker run -w &#x2F;home -it ubuntu bash</td><td>指定容器的工作路径，相当于启动容器时所在的文件位置</td></tr><tr><td></td><td></td><td>–name</td><td>docker run -v <path to location>:&#x2F;webdav -p 80:80 –name&#x3D;webdav -d idelsink&#x2F;webdav</td><td>指定容器的名称，这里是指定容器名称为webdav</td></tr></tbody></table><p><strong>注意事项</strong></p><ul><li><p>容器在创建之后就无法修改挂载地址和端口号等，所以创建的时候一定要仔细考虑</p></li><li><p>事实上 -it是-i 和-t两个命令，分别是 在新容器内指定一个伪终端或终端 和 允许你对容器内的标准输入 (STDIN) 进行交互，通常连在一起使用。</p></li><li><p>需要注意的是<code>-v</code>需要紧跟在<code>docker run</code>后面，否则会挂载不上</p></li><li><p>使用挂载前需要在docker setting中打开文件共享功能</p></li></ul><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/docker/fileshare.png"></p><h1 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h1><table><thead><tr><th>操作</th><th>命令</th><th>参数</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>执行命令</td><td>docker exec [参数] [容器名称] [命令] [要执行的命令的附加参数]</td><td></td><td>docker exec blog hexo g</td><td>在blog容器中执行<code>hexo g</code>命令</td></tr><tr><td></td><td></td><td>-it</td><td>docker exec -it blog bash</td><td>运行交互式的容器</td></tr><tr><td></td><td></td><td>-d</td><td>docker exec -d blog hexo s</td><td>后台运行容器</td></tr><tr><td></td><td></td><td>-e</td><td></td><td>附加环境参数</td></tr></tbody></table><h1 id="管理容器"><a href="#管理容器" class="headerlink" title="管理容器"></a>管理容器</h1><table><thead><tr><th>操作</th><th>命令</th><th>参数</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>启动容器</td><td>docker start [容器名称]</td><td></td><td>docker start blog</td><td>启动blog容器</td></tr><tr><td>停止容器</td><td>docker stop [容器名称]</td><td></td><td>docker stop blog</td><td></td></tr><tr><td>强行停止容器</td><td>docker kill [容器名称]</td><td></td><td>docker kill blog</td><td></td></tr><tr><td>重启容器</td><td>docker restart [容器名称]</td><td></td><td>docker restart blog</td><td></td></tr><tr><td>删除容器</td><td>docker rm [容器名称]</td><td></td><td>docker rm ubuntu</td><td></td></tr><tr><td>查看正在运行的容器</td><td>docker ps</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td>-a</td><td></td><td>查看最近运行过还没有删除的容器(包括正在运行的容器)</td></tr><tr><td>容器改名</td><td>docker rename [旧名称] [新名称]</td><td></td><td>docker rename nostalgic_feynman blog</td><td></td></tr></tbody></table><p>在也可以使用最新版docker自带的dashboard来图形化的控制docker，但这个其实不是很好用。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/docker/dashboard1.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/docker/dashboard2.png"></p><blockquote><p>其它docker命令可参阅<a href="https://www.runoob.com/docker/docker-command-manual.html">这里</a>或者<a href="https://docs.docker.com/docker-hub/">docker官网网站</a></p></blockquote><h1 id="在WSL中使用使用docker"><a href="#在WSL中使用使用docker" class="headerlink" title="在WSL中使用使用docker"></a>在WSL中使用使用docker</h1><p>目前wsl中无法运行docker engine(据说也可以运行，没研究)，所以在wsl中运行docker实际上是利用wsl远程连接到本机的docker上来运行的，和直接在power shell中运行没有区别。</p><ul><li>首先需要在docker setting中打开此选项</li></ul><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/docker/wsl.png"></p><ul><li><p>其次在wsl中安装docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure></li><li><p>最后配置wsl的环境<br>将此命令加入到用户的环境变量中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST=tcp://127.0.0.1:2375</span><br></pre></td></tr></table></figure><p>到这里应该就能在wsl中使用docker了</p></li></ul><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/docker/wsldockertest.png"></p><h1 id="在AWSLWSL2中使用docker"><a href="#在AWSLWSL2中使用docker" class="headerlink" title="在AWSLWSL2中使用docker"></a>在<del>AWSL</del>WSL2中使用docker</h1><p>最新版docker已经支持在 <del>AWSL(Advanced Windows Subsystem for Linux)</del> WSL2(Windows Subsystem for Linux 2)中使用docker，目前这是一个实验性功能，需要在Windows 10 build 19018以上系统中才能使用。目前系统条件所限暂时没有研究，awsl就完事了。</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直以来都听说docker功能十分强大，最近闲来无事终于稍微研究了一下，确实是一个强大的工具。昨晚利用docker部署了一个webdav服务器，几分钟就弄好了，如果使用传统方法我可能甚至会搞一晚上，还容易把系统搞的一地鸡毛。利用docker可以做到</summary>
        
      
    
    
    
    
    <category term="docker" scheme="https://blog.zzshub.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>基于Swerling目标模型的雷达信号检测</title>
    <link href="https://blog.zzshub.cn/2020/01/28/Swerling/"/>
    <id>https://blog.zzshub.cn/2020/01/28/Swerling/</id>
    <published>2020-01-28T14:00:23.000Z</published>
    <updated>2024-07-02T05:07:11.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>雷达散射截面积(RCS)是表征雷达散射雷达信号强弱的物理量，随着雷达入射角的改变而起伏变化，起伏的RCS导致雷达检测概率、链路损耗均发生改变，为了准确地表述RCS的起伏特性，人们建立了RCS分布的统计模型，最为典型的是非起伏模型和Swerling起伏模型。</p></blockquote><h1 id="设计任务和要求"><a href="#设计任务和要求" class="headerlink" title="设计任务和要求"></a>设计任务和要求</h1><p>产生不同类型的目标模型数据，按照虚警概率要求，对不同信噪比时的检测性能进行仿真，并分析仿真结果，给出结论。<br>设雷达为平方律检波，检波后进行10个脉冲的非相参积累然后进行信号检测。要求产生Swerling0~IV型目标信号，设噪声为高斯白噪声，要求对信噪比SNR在[-10dB:1dB:10dB]变化范围内分别进行至少$ {10}^5 $次蒙特卡洛仿真，虚警概率为$ {10}^{-6} $。根据仿真结果画出检测性能曲线（横坐标为SNR,信噪比按照1dB为步长而变化，纵坐标为检测概率Pd）。</p><h1 id="5类Swerling模型"><a href="#5类Swerling模型" class="headerlink" title="5类Swerling模型"></a>5类Swerling模型</h1><ul><li><p>Swerling0型：非起伏目标，雷达截面积$ \sigma $ 是个固定值。</p></li><li><p>SwerlingI型：目标回波幅度在一次扫描内恒定，在扫描与扫描间独立，称为慢起伏目标。回波服从瑞利分布。</p></li><li><p>SwerlingII型：目标回波幅度在脉冲与脉冲间独立，称为快起伏目标。其回波振幅也服从瑞利分布。</p></li><li><p>SwerlingIII型：慢起伏目标，回波振幅服从莱斯分布。</p></li><li><p>SwerlingIV型：快起伏目标，回波振幅也服从莱斯分布。</p></li></ul><p>Swerling1、2型适用于由大量近似相等单元散射体组成的复杂目标，虽理论上要求独立散射体的数量很大，实际上只需要四五个即可。<br>Swerling3、4型适用于由一个较大反射体和许多小反射体合成的目标，或者一个大的反射体在方位上有小变化的目标。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Swerling/swerling.png"></p><p>上图是5种Swerling模型分布函数的图像</p><h1 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h1><h2 id="蒙特卡洛仿真"><a href="#蒙特卡洛仿真" class="headerlink" title="蒙特卡洛仿真"></a>蒙特卡洛仿真</h2><p>以概率和统计理论方法为基础的一种计算方法，是使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。将所求解的问题同一定的概率模型相联系，用电子计算机实现统计模拟或抽样，以获得问题的近似解。</p><h2 id="x-2-分布"><a href="#x-2-分布" class="headerlink" title="$ x^2 $分布"></a>$ x^2 $分布</h2><p>若n个相互独立的随机变量$ \xi_1,\xi_2\ldots\ldots\xi_n $，均服从标准正态分布（也称独立同分布于标准正态分布），则这n个服从标准正态分布的随机变量的平方和构成一新的随机变量，其分布规律称为卡方分布（chi-square distribution）。</p><p>$$ f\left(x\right)&#x3D;\frac{1}{2^\frac{n}{2}\Gamma\left(\frac{n}{2}\right)}e^{-\frac{x}{2}}x^{\frac{n}{2}-1},x&gt;0 $$</p><p>其中$\Gamma\left(s\right)$是Gamma函数$\Gamma\left(s\right)&#x3D;\int_{0}^{\infty}{t^se^{-t}}dt$</p><h2 id="瑞利分布"><a href="#瑞利分布" class="headerlink" title="瑞利分布"></a>瑞利分布</h2><p>瑞利分布（Rayleigh Distribution）:当一个随机二维向量的两个分量呈独立的、有着相同的方差的正态分布时，这个向量的模呈瑞利分布。</p><p>$$ f\left(x\right)&#x3D;\frac{x}{\sigma^2}e^{-\frac{x^2}{2\sigma^2}},x&gt;0 $$</p><h2 id="莱斯分布"><a href="#莱斯分布" class="headerlink" title="莱斯分布"></a>莱斯分布</h2><p>莱斯分布实际上可以理解为主信号与服从瑞利分布的多径信号分量的和。概率密度函数公式中，R即为正弦（余弦）信号加窄带高斯随机信号的包络，参数A是主信号幅度的峰值，$ \sigma^2 $是多径信号分量的功率，$ I_0 $是修正的0阶第一类贝塞尔函数。</p><p>$$ P\left(R\right)&#x3D;\frac{R}{\sigma^2}e^{\left(-\frac{R^2+A^2}{2\sigma^2}\right)}\cdot I_0\left(\frac{RA}{\sigma^2}\right) $$</p><h1 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h1><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/Swerling/all.bmp"></p><blockquote><p>这是仿真次数为100000次的结果，曲线光滑，但是运行速度慢，降低仿真次数可加快运行速度但将导致曲线不平滑</p></blockquote><p>综合以上仿真分析，说明目标起伏及起伏快慢均会对目标检测性能造成影响。当需要较高检测概率时，起伏目标需要更大的SNR，而非起伏目标需要较小的SNR，并且慢起伏目标比快起伏目标需要更大的SNR。这是因为慢起伏目标SwerlingI和III型目标的回波幅度从一个脉冲到下一个脉冲是相关的，当检测门限大于第一个脉冲振幅时，后面的脉冲振幅也将小于检测门限，除非目标信噪比变大，否则无法被检测到。而对于快起伏目标（SwerlingII和IV型目标），其回波幅度从一个脉冲到下一个脉冲是不相关的，间隔脉冲的振幅各不相同，因此只要有一个脉冲的振幅超过检测门限目标就可被检测到，并不需要提高目标信噪比。并且，如果脉冲积累个数够多，快起伏目标的检测概率是多个脉冲积累个数下检测概率的平均值。</p><h1 id="工程源码"><a href="#工程源码" class="headerlink" title="工程源码"></a>工程源码</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line">Np = <span class="number">10</span>;<span class="comment">%非相参积累的次数</span></span><br><span class="line">Pfa = <span class="number">1e-6</span>;<span class="comment">%虚警概率</span></span><br><span class="line">Vt = gammaincinv(<span class="number">1</span>-Pfa,Np);<span class="comment">%求门限</span></span><br><span class="line">Mc_number=<span class="number">10000</span>;</span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%定义中间变量以及存储矩阵</span></span><br><span class="line">X0 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np); X1 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np); X2 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np);X3 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np);X4 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np); <span class="comment">%加噪声后的信号</span></span><br><span class="line">X0sum = <span class="built_in">zeros</span>(<span class="number">21</span>,Mc_number);X1sum = <span class="built_in">zeros</span>(<span class="number">21</span>,Mc_number);X2sum = <span class="built_in">zeros</span>(<span class="number">21</span>,Mc_number);X3sum = <span class="built_in">zeros</span>(<span class="number">21</span>,<span class="number">1</span>);X4sum = <span class="built_in">zeros</span>(<span class="number">21</span>,Mc_number); <span class="comment">%检测出的次数</span></span><br><span class="line">S0 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np);S1 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np);S2 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np);S3 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np);S4 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np); <span class="comment">%信号幅度加相位</span></span><br><span class="line">A0 = <span class="built_in">zeros</span>(<span class="number">21</span>,<span class="number">1</span>);A1 = <span class="built_in">zeros</span>(<span class="number">21</span>,<span class="number">1</span>);A2 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np);A3 = <span class="built_in">zeros</span>(<span class="number">21</span>,<span class="number">1</span>);A4 = <span class="built_in">zeros</span>(<span class="number">21</span>,Np); <span class="comment">%信号幅度</span></span><br><span class="line"></span><br><span class="line">Sum0=<span class="built_in">zeros</span>(<span class="number">21</span>,Mc_number); Sum1=<span class="built_in">zeros</span>(<span class="number">21</span>,Mc_number); Sum2=<span class="built_in">zeros</span>(<span class="number">21</span>,Mc_number); Sum3=<span class="built_in">zeros</span>(<span class="number">21</span>,Mc_number); Sum4=<span class="built_in">zeros</span>(<span class="number">21</span>,Mc_number);</span><br><span class="line">Pd0=<span class="built_in">zeros</span>(<span class="number">21</span>,<span class="number">1</span>); Pd1=<span class="built_in">zeros</span>(<span class="number">21</span>,<span class="number">1</span>); Pd2=<span class="built_in">zeros</span>(<span class="number">21</span>,<span class="number">1</span>); Pd3=<span class="built_in">zeros</span>(<span class="number">21</span>,<span class="number">1</span>); Pd4=<span class="built_in">zeros</span>(<span class="number">21</span>,<span class="number">1</span>);<span class="comment">%检测概率</span></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">%蒙特卡洛循环，</span></span><br><span class="line"><span class="keyword">for</span> Mc = <span class="number">1</span>:Mc_number<span class="comment">%循环次数为100000 非常耗时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Num = <span class="number">0</span>:<span class="number">20</span></span><br><span class="line">    SNR = Num<span class="number">-10</span>;<span class="comment">% 信噪比</span></span><br><span class="line">    <span class="comment">%----------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">%设定噪声功率</span></span><br><span class="line">    sigs1 = <span class="built_in">sqrt</span>((<span class="number">10</span>^(SNR/<span class="number">10</span>)));<span class="comment">%db转化为幅度</span></span><br><span class="line">    <span class="comment">%-----------------------------------------------</span></span><br><span class="line">    <span class="comment">%Swerling 0</span></span><br><span class="line">    A0(Num+<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">sqrt</span>(<span class="number">1</span>*(<span class="number">10</span>^(SNR/<span class="number">10</span>)));<span class="comment">% 幅度</span></span><br><span class="line">    S0(Num+<span class="number">1</span>,:) = A0(Num+<span class="number">1</span>,<span class="number">1</span>)*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*<span class="built_in">rand</span>(<span class="number">1</span>,Np));<span class="comment">%信号（包含幅度和相位的）</span></span><br><span class="line">    X0(Num+<span class="number">1</span>,:) = <span class="built_in">abs</span>(awgn(S0(Num+<span class="number">1</span>,:),SNR,<span class="string">&#x27;measured&#x27;</span>)).^<span class="number">2</span>;<span class="comment">%包含噪声，符合信噪比的信号加噪声  幅度 接受以dBW为单位的输入信号功率值</span></span><br><span class="line">    X0sum(Num+<span class="number">1</span>,Mc) = sum(X0(Num+<span class="number">1</span>,:));<span class="comment">% X0  检测出信号总计 </span></span><br><span class="line">    <span class="keyword">if</span> X0sum(Num+<span class="number">1</span>,Mc) &gt;= Vt</span><br><span class="line">        Sum0(Num+<span class="number">1</span>,Mc) = <span class="number">1</span>;<span class="comment">%  第几次仿真  检测出了信号  为1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%------------------------------------------------</span></span><br><span class="line">    <span class="comment">%Swerling 1</span></span><br><span class="line">    <span class="comment">%randn 标准正态</span></span><br><span class="line">    <span class="comment">%rand 0-1均匀随机</span></span><br><span class="line">    <span class="comment">%awgn 加高斯信号</span></span><br><span class="line">    A1(Num+<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">sqrt</span>(((<span class="built_in">sqrt</span>(<span class="number">1</span>/<span class="number">2</span>)*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>))^<span class="number">2</span>)+((<span class="built_in">sqrt</span>(<span class="number">1</span>/<span class="number">2</span>)*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>))^<span class="number">2</span>));</span><br><span class="line">    S1(Num+<span class="number">1</span>,:) = A1(Num+<span class="number">1</span>,<span class="number">1</span>)*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*<span class="built_in">rand</span>(<span class="number">1</span>,Np));</span><br><span class="line">    X1(Num+<span class="number">1</span>,:) = <span class="built_in">abs</span>(awgn(S1(Num+<span class="number">1</span>,:),SNR,<span class="string">&#x27;measured&#x27;</span>)).^<span class="number">2</span>;</span><br><span class="line">    X1sum(Num+<span class="number">1</span>,Mc) = sum(X1(Num+<span class="number">1</span>,:));</span><br><span class="line">    <span class="keyword">if</span> X1sum(Num+<span class="number">1</span>,Mc) &gt;= Vt</span><br><span class="line">        Sum1(Num+<span class="number">1</span>,Mc) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%------------------------------------------------</span></span><br><span class="line">    <span class="comment">%Swerling 2</span></span><br><span class="line">    A2(Num+<span class="number">1</span>,:) = <span class="built_in">sqrt</span>(((<span class="built_in">sqrt</span>(<span class="number">1</span>/<span class="number">2</span>)*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>,Np)).^<span class="number">2</span>)+((<span class="built_in">sqrt</span>(<span class="number">1</span>/<span class="number">2</span>)*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>,Np)).^<span class="number">2</span>));</span><br><span class="line">    S2(Num+<span class="number">1</span>,:) = A2(Num+<span class="number">1</span>,:).*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*<span class="built_in">rand</span>(<span class="number">1</span>,Np));</span><br><span class="line">    X2(Num+<span class="number">1</span>,:) = <span class="built_in">abs</span>(awgn(S2(Num+<span class="number">1</span>,:),SNR,<span class="string">&#x27;measured&#x27;</span>)).^<span class="number">2</span>;</span><br><span class="line">    X2sum(Num+<span class="number">1</span>,Mc) = sum(X2(Num+<span class="number">1</span>,:));</span><br><span class="line">    <span class="keyword">if</span> X2sum(Num+<span class="number">1</span>,Mc) &gt;= Vt</span><br><span class="line">        Sum2(Num+<span class="number">1</span>,Mc) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%-------------------------------------------------</span></span><br><span class="line">    <span class="comment">%Swerling 3</span></span><br><span class="line">    A3(Num+<span class="number">1</span>,<span class="number">1</span>) =  <span class="built_in">sqrt</span>(((<span class="number">0.5</span>*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>))^<span class="number">2</span>)+((<span class="number">0.5</span>*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>))^<span class="number">2</span>)+((<span class="number">0.5</span>*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>))^<span class="number">2</span>)+((<span class="number">0.5</span>*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>))^<span class="number">2</span>));</span><br><span class="line">    S3(Num+<span class="number">1</span>,:) =  A3(Num+<span class="number">1</span>,<span class="number">1</span>)*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*<span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">    X3(Num+<span class="number">1</span>,:) = <span class="built_in">abs</span>(awgn(S3(Num+<span class="number">1</span>,:),SNR,<span class="string">&#x27;measured&#x27;</span>)).^<span class="number">2</span>;</span><br><span class="line">    X3sum(Num+<span class="number">1</span>,:) = sum(X3(Num+<span class="number">1</span>,:));</span><br><span class="line">    <span class="keyword">if</span> X3sum(Num+<span class="number">1</span>,:) &gt;= Vt </span><br><span class="line">        Sum3(Num+<span class="number">1</span>,Mc) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%--------------------------------------------------</span></span><br><span class="line">    <span class="comment">%Swerling 4</span></span><br><span class="line">    A4(Num+<span class="number">1</span>,:) = <span class="built_in">sqrt</span>(((<span class="number">0.5</span>*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>,Np)).^<span class="number">2</span>)+((<span class="number">0.5</span>*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>,Np)).^<span class="number">2</span>)+((<span class="number">0.5</span>*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>,Np)).^<span class="number">2</span>)+((<span class="number">0.5</span>*sigs1*<span class="built_in">randn</span>(<span class="number">1</span>,Np)).^<span class="number">2</span>));</span><br><span class="line">    S4(Num+<span class="number">1</span>,:) = A4(Num+<span class="number">1</span>,:).*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*<span class="built_in">rand</span>(<span class="number">1</span>,Np));</span><br><span class="line">    X4(Num+<span class="number">1</span>,:) = <span class="built_in">abs</span>(awgn(S4(Num+<span class="number">1</span>,:),SNR,<span class="string">&#x27;measured&#x27;</span>)).^<span class="number">2</span>;</span><br><span class="line">    X4sum(Num+<span class="number">1</span>,Mc) = sum(X4(Num+<span class="number">1</span>,:));</span><br><span class="line">    <span class="keyword">if</span> X4sum(Num+<span class="number">1</span>,Mc) &gt;= Vt</span><br><span class="line">        Sum4(Num+<span class="number">1</span>,Mc) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">0</span>:<span class="number">20</span></span><br><span class="line">Pd0(<span class="built_in">i</span>+<span class="number">1</span>,:) = sum(Sum0(<span class="built_in">i</span>+<span class="number">1</span>,:))./(Mc<span class="number">-1</span>);</span><br><span class="line">Pd1(<span class="built_in">i</span>+<span class="number">1</span>,:) = sum(Sum1(<span class="built_in">i</span>+<span class="number">1</span>,:))./(Mc<span class="number">-1</span>);</span><br><span class="line">Pd2(<span class="built_in">i</span>+<span class="number">1</span>,:) = sum(Sum2(<span class="built_in">i</span>+<span class="number">1</span>,:))./(Mc<span class="number">-1</span>);</span><br><span class="line">Pd3(<span class="built_in">i</span>+<span class="number">1</span>,:) = sum(Sum3(<span class="built_in">i</span>+<span class="number">1</span>,:))./(Mc<span class="number">-1</span>);</span><br><span class="line">Pd4(<span class="built_in">i</span>+<span class="number">1</span>,:) = sum(Sum4(<span class="built_in">i</span>+<span class="number">1</span>,:))./(Mc<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%profile view</span></span><br><span class="line">xx=<span class="number">-10</span>:<span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>((<span class="number">-10</span>:<span class="number">10</span>),Pd0);</span><br><span class="line">xlabel(<span class="string">&#x27;SNR/dB&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Pd&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Swerling 0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>((<span class="number">-10</span>:<span class="number">10</span>),Pd1);</span><br><span class="line">xlabel(<span class="string">&#x27;SNR/dB&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Pd&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Swerling 1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>((<span class="number">-10</span>:<span class="number">10</span>),Pd2);</span><br><span class="line">xlabel(<span class="string">&#x27;SNR/dB&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Pd&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Swerling 2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>((<span class="number">-10</span>:<span class="number">10</span>),Pd3);</span><br><span class="line">xlabel(<span class="string">&#x27;SNR/dB&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Pd&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Swerling 3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">plot</span>((<span class="number">-10</span>:<span class="number">10</span>),Pd4);</span><br><span class="line">xlabel(<span class="string">&#x27;SNR/dB&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Pd&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Swerling 4&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(xx,Pd1,<span class="string">&#x27;b*&#x27;</span>,xx,Pd2,<span class="string">&#x27;b-&#x27;</span>,xx,Pd3,<span class="string">&#x27;b--&#x27;</span>,xx,Pd0,<span class="string">&#x27;b:&#x27;</span>,xx,Pd4,<span class="string">&#x27;b-.&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Swerling 1&#x27;</span>,<span class="string">&#x27;Swerling 2&#x27;</span>,<span class="string">&#x27;Swerling3&#x27;</span>,<span class="string">&#x27;Swerling 0&#x27;</span>,<span class="string">&#x27;Swerling 4&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]杨瀚涛.网络协同雷达对Swerling型目标的检测研究[J].国外电子测量技术,2017,36(05):107-110.<br>[2]徐喜安. 单脉冲雷达系统的建模与仿真研究[D].电子科技大学,2006.<br>[3]李皓. 基于单脉冲雷达的多目标检测方法与仿真[D].北京理工大学,2016.<br>[4]丁鹭飞. 雷达原理.电子工业出版社.2009,3.<br>[5]楼顺天. 基于MATLAB的系统分析与设计——信号处理.西安电子科技大学出版社.1998,9.<br>[6]MATLAB Simulations for Radar Systems Design.2004</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;雷达散射截面积(RCS)是表征雷达散射雷达信号强弱的物理量，随着雷达入射角的改变而起伏变化，起伏的RCS导致雷达检测概率、链路损耗均发生改变，为了准确地表述RCS的起伏特性，人们建立了RCS分布的统计模型，最为典型的是非起伏模型和Swerling起</summary>
        
      
    
    
    
    
    <category term="数字信号处理" scheme="https://blog.zzshub.cn/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    <category term="雷达原理" scheme="https://blog.zzshub.cn/tags/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>FPGA函数发生器设计</title>
    <link href="https://blog.zzshub.cn/2020/01/27/FPGA_DDS/"/>
    <id>https://blog.zzshub.cn/2020/01/27/FPGA_DDS/</id>
    <published>2020-01-26T16:11:34.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FPGA函数发生器设计"><a href="#FPGA函数发生器设计" class="headerlink" title="FPGA函数发生器设计"></a>FPGA函数发生器设计</h1><blockquote><p>随着现在工业和科技的不断提高，传统的三极管等分离元件式模拟信号发生器频率稳定性低、可靠性差的特点，已经不可能满足实际应用的需要，所以就必须制作频率稳定性、精确度更高的信号发生器解决这些问题。传统的信号发生器技术对科学的发展带来了很多，而且随着集成电路技术和数字信号处理的发展，直接数字频率合成技术（DDS）已开始被广泛的用于信号发生器的发生和制作当中。</p></blockquote><blockquote><p>基于现场可编程门阵列器件的高速、高可靠性和现场可编程等优点，本技术已开始广泛应用于数字集成电路设计、数字信号处理、通信等不同的科技领域。利用直接数字频率合成技术FPGA设计的函数信号发生器具有以下优点：</p><ul><li>输出相位噪声低；</li><li>频率切换速度快；</li><li>可以产生任意波形；</li><li>全数字化实现，便于集成，体积小，重量轻；</li><li>灵活的接口和控制方式；</li><li>比专用芯片功耗也低</li></ul></blockquote><h2 id="工程源码"><a href="#工程源码" class="headerlink" title="工程源码"></a>工程源码</h2><p><a href="https://github.com/ZzzzzzS/FPGA_DDS">转到github</a></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>DDS(direct digital synthesizer)是在一组存储器单元中按照信号波形数据点的 输出次序存储了将要输出波形的数据，在控制电路的协调控制下，以一定的速率，周而 复始地将波形数据依次发送给 D&#x2F;A 转换器转换成相应的模拟信号。由于用硬件电路取代 了计算机的控制，信号输出稳定度高。如需更新输出信号，不必改动任何线路和元器件， 只需改写存储器中的波形数据即可。更主要的是，可以将微处理器从信号输出的负担中解脱出来。工作流程图如下：</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/FPGADDS/chart.png"></p><p>基于对函数信号发生器的几种实现方式的了解，本文选择方便调频的直接频率合成 DDS 技术来实现函数信号发生器。 DDS 的核心就是相位累加器，利用它来产生信号递增的相位信息，整个 DDS 系统在 统一的参考时钟下工作，每个时钟周期相位累加器作加法运算一次。加法运算的步进越大，相应合成的相位值变化越快，输出信号的频率也就越高</p><h2 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h2><p>函数发生器分为以下模块：</p><ul><li><p>按键模块：<br>通过控制按键，改变频率，相位，占空比。</p></li><li><p>频率控制模块：<br>通过按键模块传来的改变频率的信息，产生相应的频率控制字，传给波形生成模块。</p></li><li><p>相位控制模块：<br>通过按键模块传来的改变相位的信息，产生相应的相位控制字，传给波形生成模块。</p></li><li><p>三角波模块<br>根据时钟信号，生成三角波</p></li><li><p>正弦波模块<br>根据时钟信号，生成正弦波</p></li><li><p>方波模块<br>  根据时钟信号，生成方波</p></li><li><p>PWM波模块<br>  根据时钟信号，生成PWM波</p></li><li><p>波形控制模块：<br>  通过波形选择，控制输出信号的波形。</p></li><li><p>数码管显示模块：<br>  把频率显示到数码管上。</p></li></ul><p>所有模块如图所示：</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/FPGADDS/module.png"></p><h2 id="仿真效果"><a href="#仿真效果" class="headerlink" title="仿真效果"></a>仿真效果</h2><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/FPGADDS/result.png"></p><h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><h3 id="频率控制字的理解"><a href="#频率控制字的理解" class="headerlink" title="频率控制字的理解"></a>频率控制字的理解</h3><p> 对频率控制字的理解出现了偏差，最初计划对时钟进行分频来控制波形的频率。根据书上的公式，我们发现可以改变频率控制字来改变输出频率。频率控制字： $f_{out}&#x3D;\frac{B\left[31..0\right]}{2^{32}}f_{clk} $  通过改变频率控制字的步进来改变频率步进的大小。</p><h3 id="ROM-空间不够"><a href="#ROM-空间不够" class="headerlink" title="ROM 空间不够"></a>ROM 空间不够</h3><p>原因：.mif 文件的采样深度太深，数据太多，导致 ROM 空间不够。</p><h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h3><ul><li>按键按下时数码管上显示的频率一直在改变，松开按键时频率回到初值</li></ul><p> 我们怀疑是按键未消抖。编写按键消抖，采用了积分延时消抖的方法。</p><ul><li>按键消抖后没变化</li></ul><p> 成功对按键进行了消抖，但按键按下时数码管上显示的频率一直在改变，松开按键时频率回到初值。我么认为 if else 生成的RTL电路太复杂，尝试改成用case描述。</p><ul><li>把 if else 改成了 case，简化了RTL电路</li></ul><p> 改成了 case 后，松开按键时频率不会回到初值。但按键按下时数码管上显示的频率仍然一直在改变。经电路分析，我们猜想可能是电路没有触发器的生成，导致在按键按下时，不能做到对按键的下降沿进行检测</p><h3 id="如何避免生成锁存器"><a href="#如何避免生成锁存器" class="headerlink" title="如何避免生成锁存器"></a>如何避免生成锁存器</h3><p> 虽然 always 块里的敏感列表是对下降沿进行检测，但是生成的电路中并没有检测边缘。我们猜测是没有生成触发器的缘故。锁存器最大的危害在于不能过滤毛刺（使能信号有效时，输出状态可能随输入多次变化，产生空翻）。这对于下一级电路是极其危险的。<br> 避免产生锁存器的方法： </p><ul><li>给输出变量赋初值</li><li>增加的else语句，使得逻辑完备。</li><li>时序逻辑电路不会产生锁存器</li></ul><p>我们进行了上述操作，成功避免生成了锁存器，但是仍然不能生成触发器。通过网上查找资料，我们发现网上的写法普遍是检测按键后由程序生成一个下降沿，在always块里对该下降沿进行检测。</p><h3 id="把按键电平转换为脉冲"><a href="#把按键电平转换为脉冲" class="headerlink" title="把按键电平转换为脉冲"></a>把按键电平转换为脉冲</h3><ul><li><p>使用一个模块，在模块内记录按键的上一个电平的情况，与本次电平进行逻辑操作：<code>assign buttonout=~((key_temp)&amp;&amp;(!buttonin)); </code>该操作使得仅在按键按下的时候有一个脉冲。</p></li><li><p>由于assign buttonout仅是一个单脉冲，顾FPGA可能会将该脉冲视为噪声，故需要电平优化：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wire [2:0]PushButton/* synthesis keep=&quot;1&quot; */;</span><br><span class="line">wire [2:0]PushButtonafter/* synthesis keep=&quot;1&quot; */; </span><br></pre></td></tr></table></figure><p>电平优化后，按键基本正常</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>在两周之前，我们虽然学过EDA这门课、知道Quartus ii、学过Verilog HDL，可是基本不会用，通过两周的课程设计，我们可以进行编程设计，收获颇丰。实践是检验真理的唯一标准，我们这次设计的内容就是在Quartus ii环境中，利用Verilog HDL 语言设计出函数发生器，还要与硬件相结合，把程序加载到芯片上，观察真正的效果。所以，在整个设计学习过程中，我们对EDA这门课有了更深层次的了解，在编写程序的过程中也加深了对Verilog HDL 语言的了解及运用能力。在设计过程中，困难重重，从开始的茫然，到后来的渐渐熟悉，再到最后的设计成型，我们都在一直努力解决问题，一个模块一个模块的考虑再到最后把它们整合在一起，最终完成了这次设计。</p><p>为期两周的FPGA课程设计已经结束，从挑选课设题目，查阅资料，到研究出总体设计，详细设计，再到最后的编程上机调试，修改程序，完善程序，收获颇多。锻炼了自己独立发现问题、分析问题和通过查看相关资料来解决问题的能力，使自己扩大了知识面，提高了知识水平。借助仿真软件，不仅可以把课堂中所学到的知识，直接加以运用，而且还可以把各个分离的知识组合为一个整体，真正做到理论联系实际的重要性，使自己在专业知识和动手能力上有了很大的提高。</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;FPGA函数发生器设计&quot;&gt;&lt;a href=&quot;#FPGA函数发生器设计&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="FPGA" scheme="https://blog.zzshub.cn/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>简易图像拼接原理初探</title>
    <link href="https://blog.zzshub.cn/2019/07/16/imageadd/"/>
    <id>https://blog.zzshub.cn/2019/07/16/imageadd/</id>
    <published>2019-07-16T15:00:23.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简易图像拼接原理初探"><a href="#简易图像拼接原理初探" class="headerlink" title="简易图像拼接原理初探"></a>简易图像拼接原理初探</h1><blockquote><p>今天突然高产，一天写了两篇博客，可能是博客修好之后有些激动吧。废话不多说，进入正题图像拼接。</p></blockquote><p>首先放一张效果图：</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/imageadd/xiaoguo.png"></p><p>这张图是两张图拼接而成，看看能找到拼接缝吗</p><h1 id="图像拼接整体思路"><a href="#图像拼接整体思路" class="headerlink" title="图像拼接整体思路"></a>图像拼接整体思路</h1><p>整个图像拼接过程首先读入图像后使用fast检测算法识别图像中的特征点，然后计算特征点的向量获取到一个128位长的向量，随后通过对所有向量的逐个匹配计算出匹配的特征点并挑选出距离最短的前N个点作为最佳匹配点，以上识别过程就结束。接下来进行拼接过程，通过计算最佳匹配点可以获取到仿射变换矩阵，利用仿射变换矩阵可以计算出仿射变换后图像的顶点以及图像本身。之后将仿射变换后的图像和另一张待拼接的图像拼接起来即可，拼接后的拼接缝处理利用重叠区域加权平均的思想来处理。以下是整个图像拼接的流程图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">in=&gt;inputoutput: 采集图像</span><br><span class="line">fast=&gt;operation: fast算法获取特征点</span><br><span class="line">vector=&gt;operation: 计算特征向量</span><br><span class="line">match=&gt;operation: 计算匹配点</span><br><span class="line">best=&gt;operation: 选取最佳匹配点</span><br><span class="line">homo=&gt;operation: 计算仿射变换矩阵</span><br><span class="line">point=&gt;operation: 计算变换后图像的顶点</span><br><span class="line">imagetrans=&gt;operation: 计算变换后的图像</span><br><span class="line">stich=&gt;operation: 将变换后的图像和原图像拼接</span><br><span class="line">opti=&gt;operation: 加权平均处理拼接缝</span><br><span class="line">next=&gt;condition: 是否拼接下一张图像</span><br><span class="line">out=&gt;inputoutput: 输出图像</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">st-&gt;in-&gt;fast-&gt;vector-&gt;match-&gt;best-&gt;homo-&gt;point-&gt;imagetrans-&gt;stich-&gt;opti-&gt;next</span><br><span class="line">next(yes,right)-&gt;in</span><br><span class="line">next(no)-&gt;out-&gt;e</span><br></pre></td></tr></table></figure><h1 id="FAST算法提取特征点"><a href="#FAST算法提取特征点" class="headerlink" title="FAST算法提取特征点"></a>FAST算法提取特征点</h1><p>FAST的提出者Rosten等将FAST角点定义为：若某像素与其周围邻域内足够多的像素点相差较大，则该像素可能是角点。<br>核心思想如下：该算法的基本原理是使用圆周长为16个像素点来判定其圆心像素P是否为角点。在圆周上按顺时针方向从1到16的顺序对圆周像素点进行编号。如果在圆周上有N个连续的像素的亮度都比圆心像素的亮度Ip加上阈值t还要亮，或者比圆心像素的亮度减去阈值还要暗，则圆心像素被称为角点。<br>详细计算方法如下:</p><ul><li><p>选择某个像素$p$其像素值为$I_p$以$p$为圆心，半径为三个像素确定一个圆，圆上有16个像素点记作$P_1,P_2,P_3\ldots P_{16}$</p></li><li><p>确定一个阈值记作t</p></li><li><p>让圆上的n个连续的像素的像素值与p的像素值做差，若这些差值的绝对值都比$I_\sigma+t$大或者都比$I_\sigma-t$小则像素$p$为角点。现在我们令n&#x3D;12（经验数据）。接下来是实现这一步的具体步骤（前人经验所得）。</p></li><li><p>分别计算$P_1$与$P_\sigma$的像素值与$I_\sigma$的差，若差值的绝对值都比大$I_\sigma+t$或都比$I_\sigma-t$小，则进入下一步判断，否则P点被丢弃</p></li><li><p>分别计算$p_1$，$p_2$，$p_3$，$p_4$四个点像素值与$I_\sigma$的差值，若有个点的差值的绝对值都比$I_\sigma+t$大或都比$I_\sigma-t$小，则进入下一步判断，否则$P$点被丢弃</p></li><li><p>对圆上16个像素点的像素值分别与$I_\sigma$做差，若有n个像素点的差值的绝对值都比$I_\sigma+t$大或都比$I_\sigma-t$小，则$p$点为角点</p></li></ul><p>在OpenCV中利用fast检测子计算特征点的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ptr&lt;FastFeatureDetector&gt; detector = FastFeatureDetector::<span class="built_in">create</span>(); <span class="comment">//fast检测子</span></span><br><span class="line">vector&lt;cv::KeyPoint&gt; KeyPoint1, KeyPoint2; <span class="comment">//特征点</span></span><br><span class="line">detector-&gt;<span class="built_in">detect</span>(img1, KeyPoint1); <span class="comment">//计算特征点</span></span><br><span class="line"><span class="built_in">drawKeypoints</span>(img1, KeyPoint1, KeyPointImage1);<span class="comment">//画特征点</span></span><br></pre></td></tr></table></figure><p>效果如图所示：</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/imageadd/key.png"></p><h1 id="计算特征点的特征向量"><a href="#计算特征点的特征向量" class="headerlink" title="计算特征点的特征向量"></a>计算特征点的特征向量</h1><p>在获取到特征点后下一步就需要判断特征点的方向即特征点的向量，为下一步匹配特征点做准备。详细的计算方法如下：</p><ul><li><p>将关键点周围的像素旋转到一个统一的方向，以保证方向不变性。</p></li><li><p>将这些像素分成$4\times4$的小块。</p></li><li><p>对每个格子进行分析，将格子中的像素计算梯度，映射到8个方向上，对于每一个格子，可以得到一个8维的向量，对于一个关键点周围16个格子，则得到了$16\times8&#x3D;128$维的向量，这就是一个关键点特征向量。</p></li></ul><p>$$m\left(x,y\right)&#x3D;\sqrt{\left(L\left(x+1,t\right)-L\left(x-1,y\right)\right)^2+\left(L\left(x,y+1\right)-L\left(x,y-1\right)\right)^2}$$<br>$$\theta&#x3D;\alpha tan^2\left(\left(L\left(x,y+1\right)-L\left(x,y-1\right)\right)&#x2F;\left(L\left(x+1,y\right)-L\left(x-1,y\right)\right)\right)$$</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/imageadd/1.jpg"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/imageadd/12.jpg"></p><p>在OpenCV中计算特征点的特征向量的代码如下，由于OpenCV中没有专门针对fast算法的特征向量提取算法，所以我使用了sift算法中的特征向量展开子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ptr&lt;SiftDescriptorExtractor&gt; extractor = SiftDescriptorExtractor::<span class="built_in">create</span>();<span class="comment">//展开子</span></span><br><span class="line">Mat KeyVector1, KeyVector2; <span class="comment">//展开的特征向量</span></span><br><span class="line">extractor-&gt;<span class="built_in">compute</span>(img1, KeyPoint1, KeyVector1); <span class="comment">//计算特征点的特征向量</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;vector&quot;</span>, KeyVector1);</span><br></pre></td></tr></table></figure><p>特征点的向量如下图所示：</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/imageadd/vec.png"></p><h1 id="匹配特征点与获取最佳特征点"><a href="#匹配特征点与获取最佳特征点" class="headerlink" title="匹配特征点与获取最佳特征点"></a>匹配特征点与获取最佳特征点</h1><p>首先进行特征点的匹配，特征点的匹配使用的BruteForce方法，也就是蛮力匹配器，顾名思义，它的工作原理是：在第一幅图像上选取一个关键点，然后依次与第二幅图像的每个关键点进行（描述符）距离测试，最后返回距离最近的关键点。获取到所有匹配的特征点后计算所有特征点在图像中的距离，并计算距离最短的特征点。之后取出距离在最短距离特征点长度两倍以内（经验数据）的特征点，将这些特征点视为最佳特征点。</p><p>在OpenCV中匹配特征点和计算最佳特征点的部分代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ptr&lt;DescriptorMatcher&gt;matcher=DescriptorMatcher::<span class="built_in">create</span>(DescriptorMatcher::MatcherType::BRUTEFORCE); <span class="comment">//创建暴力匹配器</span></span><br><span class="line">matcher-&gt;<span class="built_in">match</span>(KeyVector2, KeyVector1, match); <span class="comment">//计算匹配点</span></span><br><span class="line"><span class="type">double</span> Max_dist = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> Min_dist = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; img1.rows; i++) <span class="comment">//找到距离最短的匹配点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> dist = match[i].distance;</span><br><span class="line"><span class="keyword">if</span> (dist &lt; Min_dist)Min_dist = dist;</span><br><span class="line"><span class="keyword">if</span> (dist &gt; Max_dist)Max_dist = dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; img1.rows; i++) <span class="comment">//利用最小距离法寻找优秀的匹配点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (match[i].distance &lt; <span class="number">2</span> * Min_dist)</span><br><span class="line">GoodMatch.<span class="built_in">push_back</span>(match[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配的特征点如下图所示:</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/imageadd/match.png"></p><h1 id="计算仿射变换矩阵"><a href="#计算仿射变换矩阵" class="headerlink" title="计算仿射变换矩阵"></a>计算仿射变换矩阵</h1><p>仿射变换是几何中的一个概念。仿射变换是一个从实射影平面到射影平面的可逆变换，直线在该变换下仍映射为直线。它是一对透视投影的组合。它描述了当观察者视角改变时，被观察物体的感知位置会发生何种变化。射影变换并不保持大小和角度，但会保持重合关系和交比。对于图像1中的$a\left(x_1,y_1\right)$点和图像2中的$b\left(u_1,v_1\right)$点，通过仿射变换矩阵变换关系如下：$\mathbf{a}&#x3D;H\mathbf{b}$，其中H就是仿射变换矩阵。由于图像中的变换都是线性变换，所以对图像中的所有点都有以下公式：<br>$$<br>\left[\begin{matrix}x\\y\\1\\\end{matrix}\right]&#x3D;\left[\begin{matrix}h_{00}&amp;h_{01}&amp;h_{02}\\h_{10}&amp;h_{11}&amp;h_{12}\\h_{20}&amp;h_{21}&amp;h_{22}\\\end{matrix}\right]\left[\begin{matrix}u\\v\\1\\\end{matrix}\right]<br>$$<br>所以可以通过特征点的匹配关系来找到矩阵H，随后通过矩阵H就能将图像变换到另一幅待拼接图像的平面上。在OpenCV中图像寻找矩阵H使用的是RANSAC算法，即随机抽样一致算法(RANdom SAmple Consensus)。下面介绍RANSAC算法的基本原理：<br>OpenCV中滤除误匹配对采用RANSAC算法寻找一个最佳单应性矩阵H，矩阵大小为$3\times3$。RANSAC目的是找到最优的参数矩阵使得满足该矩阵的数据点个数最多，通常令$h33&#x3D;1$来归一化矩阵。由于单应性矩阵有8个未知参数，至少需要8个线性方程求解，对应到点位置信息上，一组点对可以列出两个方程，则至少包含4组匹配点对。RANSAC算法从匹配数据集中随机抽出4个样本并保证这4个样本之间不共线，计算出单应性矩阵，然后利用这个模型测试所有数据，并计算满足这个模型数据点的个数与投影误差(即代价函数)，若此模型为最优模型，则对应的代价函数最小。</p><p>$$\sum_{i&#x3D;1}^{n}\left(x_i-\frac{h_{11}u_i+h_{12}v_i+h_{13}}{h_{31}u_i+h_{32}v_i+h_{33}}\right)^2+\left(y_i-\frac{h_{21}v_i+h_{22}v_i+h_{23}}{h_{31}u_i+h_{32}v_i+h_{33}}\right)^2$$</p><p>RANSAC算法步骤： </p><ul><li>随机从数据集中随机抽出4个样本数据 (此4个样本之间不能共线)(包含(x,y)坐标，所以只需要4个点)，计算出变换矩阵H，记为模型M</li><li>计算数据集中所有数据与模型M的投影误差，若误差小于阈值，加入内点集 I </li><li>如果当前内点集 I 元素个数大于最优内点集 $I_{best}$,则更新$I_{best} &#x3D; I$，同时更新迭代次数k</li><li>如果迭代次数大于k,则退出; 否则迭代次数加1，并重复上述步骤</li></ul><p>在OpenCV中仿射变换矩阵计算的部分代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat homo = <span class="built_in">findHomography</span>(imagePoints2, imagePoints1, RANSAC);<span class="comment">//计算仿射变换矩阵</span></span><br></pre></td></tr></table></figure><p>计算出的矩阵如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0.4186871730549565, -4.990085725145821, 289.5264601465362;</span><br><span class="line"> 0.1069861123385652, -1.271675931782899, 74.27924188037302;</span><br><span class="line"> 0.001537765942528251, -0.01747550792504644, 0.9999999999999999]</span><br></pre></td></tr></table></figure><p>由于浮点是精度问题可以看出有一定误差</p><h1 id="图像顶点计算与图像变换"><a href="#图像顶点计算与图像变换" class="headerlink" title="图像顶点计算与图像变换"></a>图像顶点计算与图像变换</h1><p>获取到仿射变换矩阵之后只需要进行仿射变换就能得到所需的图像，由于OpenCV中矩阵无法自由的伸缩大小，所以需要先计算图像的顶点来确定变换后图像的大小，之后再进行图像的变换。由之前的仿射变换公式可以得出顶点的变换公式如下。同理，图像的变换公式也类似：</p><p>$$<br>\left[\begin{matrix}变换后顶点坐标x\\变换后顶点坐标y\\1\\\end{matrix}\right]&#x3D;\left[\begin{matrix}h_{00}&amp;h_{01}&amp;h_{02}\\h_{10}&amp;h_{11}&amp;h_{12}\\0&amp;0&amp;1\\\end{matrix}\right]\left[\begin{matrix}变换前顶点坐标x\\变换前顶点坐标y\\1\\\end{matrix}\right]<br>$$</p><p>在OpenCV中图像变换和顶点计算的部分代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左下角(0,src.rows,1)顶点计算</span></span><br><span class="line">v2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">v2[<span class="number">1</span>] = src.rows;</span><br><span class="line">v2[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">V2 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v2);  <span class="comment">//列向量</span></span><br><span class="line">V1 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v1);  <span class="comment">//列向量</span></span><br><span class="line">V1 = H * V2;</span><br><span class="line">corners.left_bottom.x = v1[<span class="number">0</span>] / v1[<span class="number">2</span>];</span><br><span class="line">corners.left_bottom.y = v1[<span class="number">1</span>] / v1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//变换图像</span></span><br><span class="line"><span class="built_in">warpPerspective</span>(img2, imageTransform1, homo, <span class="built_in">Size</span>(<span class="built_in">MAX</span>(<span class="built_in">MIN</span>(corners.right_top.x, corners.right_bottom.x), <span class="built_in">MIN</span>(corners.left_top.x, corners.left_bottom.x)), img1.rows);</span><br></pre></td></tr></table></figure><p>效果如下:</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/imageadd/trans.png"></p><h1 id="图像拼接与拼接缝处理"><a href="#图像拼接与拼接缝处理" class="headerlink" title="图像拼接与拼接缝处理"></a>图像拼接与拼接缝处理</h1><p>到目前为止，将变换后的图像和另一张图像直接拷贝到一个矩阵里即可实现，但是这将导致拼接部分产生接缝。我处理拼接缝的方式是首先计算重叠的区域，在重叠的区域内对两幅图像加权求和。</p><p>在OpenCV中拼接与拼接缝处理的部分代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行图像拼接</span></span><br><span class="line">imageTransform1.<span class="built_in">copyTo</span>(<span class="built_in">FinalImage</span>(<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, imageTransform1.cols, imageTransform1.rows)));</span><br><span class="line">img1.<span class="built_in">copyTo</span>(<span class="built_in">FinalImage</span>(<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, img1.cols, img1.rows)));</span><br><span class="line"><span class="type">int</span> start=<span class="built_in">MIN</span>(corners.left_top.x,corners.left_bottom.x);<span class="comment">//开始位置，即重叠区域的左边界  </span></span><br><span class="line"><span class="type">double</span> processWidth = (img1.cols - start);<span class="comment">//重叠区域的宽度  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = start; j &lt; cols; j++)</span><br><span class="line">&#123; </span><br><span class="line">alpha = (processWidth - (j - start)) / processWidth;<span class="comment">//计算权值</span></span><br><span class="line">d[j * <span class="number">3</span>] = p[j * <span class="number">3</span>] * alpha + t[j * <span class="number">3</span>] * (<span class="number">1</span> - alpha);<span class="comment">//图像三通道一起加权</span></span><br><span class="line">d[j * <span class="number">3</span> + <span class="number">1</span>] = p[j * <span class="number">3</span> + <span class="number">1</span>] * alpha + t[j * <span class="number">3</span> + <span class="number">1</span>] * (<span class="number">1</span> - alpha);</span><br><span class="line">d[j * <span class="number">3</span> + <span class="number">2</span>] = p[j * <span class="number">3</span> + <span class="number">2</span>] * alpha + t[j * <span class="number">3</span> + <span class="number">2</span>] * (<span class="number">1</span> - alpha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/imageadd/xiaoguo.png"></p><h1 id="工程源码"><a href="#工程源码" class="headerlink" title="工程源码"></a>工程源码</h1><p>整个图像拼接的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/xfeatures2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ImageStitching.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv::xfeatures2d;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">Point2f left_top;</span><br><span class="line">Point2f left_bottom;</span><br><span class="line">Point2f right_top;</span><br><span class="line">Point2f right_bottom;</span><br><span class="line">&#125;<span class="type">four_corners_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">four_corners_t</span> corners;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算顶点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CalcCorners</span><span class="params">(<span class="type">const</span> Mat&amp; H, <span class="type">const</span> Mat&amp; src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> v2[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;<span class="comment">//左上角</span></span><br><span class="line"><span class="type">double</span> v1[<span class="number">3</span>];<span class="comment">//变换后的坐标值</span></span><br><span class="line">Mat V2 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v2);  <span class="comment">//列向量</span></span><br><span class="line">Mat V1 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v1);  <span class="comment">//列向量</span></span><br><span class="line"></span><br><span class="line">V1 = H * V2;</span><br><span class="line"><span class="comment">//左上角(0,0,1)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;V2: &quot;</span> &lt;&lt; V2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;V1: &quot;</span> &lt;&lt; V1 &lt;&lt; endl;</span><br><span class="line">corners.left_top.x = v1[<span class="number">0</span>] / v1[<span class="number">2</span>];</span><br><span class="line">corners.left_top.y = v1[<span class="number">1</span>] / v1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//左下角(0,src.rows,1)</span></span><br><span class="line">v2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">v2[<span class="number">1</span>] = src.rows;</span><br><span class="line">v2[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">V2 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v2);  <span class="comment">//列向量</span></span><br><span class="line">V1 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v1);  <span class="comment">//列向量</span></span><br><span class="line">V1 = H * V2;</span><br><span class="line">corners.left_bottom.x = v1[<span class="number">0</span>] / v1[<span class="number">2</span>];</span><br><span class="line">corners.left_bottom.y = v1[<span class="number">1</span>] / v1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//右上角(src.cols,0,1)</span></span><br><span class="line">v2[<span class="number">0</span>] = src.cols;</span><br><span class="line">v2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">v2[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">V2 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v2);  <span class="comment">//列向量</span></span><br><span class="line">V1 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v1);  <span class="comment">//列向量</span></span><br><span class="line">V1 = H * V2;</span><br><span class="line">corners.right_top.x = v1[<span class="number">0</span>] / v1[<span class="number">2</span>];</span><br><span class="line">corners.right_top.y = v1[<span class="number">1</span>] / v1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//右下角(src.cols,src.rows,1)</span></span><br><span class="line">v2[<span class="number">0</span>] = src.cols;</span><br><span class="line">v2[<span class="number">1</span>] = src.rows;</span><br><span class="line">v2[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">V2 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v2);  <span class="comment">//列向量</span></span><br><span class="line">V1 = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">1</span>, CV_64FC1, v1);  <span class="comment">//列向量</span></span><br><span class="line">V1 = H * V2;</span><br><span class="line">corners.right_bottom.x = v1[<span class="number">0</span>] / v1[<span class="number">2</span>];</span><br><span class="line">corners.right_bottom.y = v1[<span class="number">1</span>] / v1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化两图的连接处，使得拼接自然</span></span><br><span class="line"><span class="comment">//使用渐入渐出的拼接方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OptimizeSeam</span><span class="params">(Mat&amp; img1, Mat&amp; trans, Mat&amp; dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> start = <span class="built_in">MIN</span>(corners.left_top.x, corners.left_bottom.x);<span class="comment">//开始位置，即重叠区域的左边界  </span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> processWidth = (img1.cols - start);<span class="comment">//重叠区域的宽度  </span></span><br><span class="line"><span class="type">int</span> rows = dst.rows;</span><br><span class="line"><span class="type">int</span> cols = img1.cols; <span class="comment">//注意，是列数*通道数</span></span><br><span class="line"><span class="type">double</span> alpha = <span class="number">1</span>;<span class="comment">//img1中像素的权重  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">uchar* p = img1.<span class="built_in">ptr</span>&lt;uchar&gt;(i);  <span class="comment">//获取第i行的首地址</span></span><br><span class="line">uchar* t = trans.<span class="built_in">ptr</span>&lt;uchar&gt;(i);</span><br><span class="line">uchar* d = dst.<span class="built_in">ptr</span>&lt;uchar&gt;(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = start; j &lt; cols; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果遇到图像trans中无像素的黑点，则完全拷贝img1中的数据</span></span><br><span class="line"><span class="keyword">if</span> (t[j * <span class="number">3</span>] == <span class="number">0</span> &amp;&amp; t[j * <span class="number">3</span> + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; t[j * <span class="number">3</span> + <span class="number">2</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[j * <span class="number">3</span>] == <span class="number">0</span> &amp;&amp; p[j * <span class="number">3</span> + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; p[j * <span class="number">3</span> + <span class="number">2</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">alpha = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//img1中像素的权重，与当前处理点距重叠区域左边界的距离成正比，实验证明，这种方法确实好  </span></span><br><span class="line">alpha = (processWidth - (j - start)) / processWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d[j * <span class="number">3</span>] = p[j * <span class="number">3</span>] * alpha + t[j * <span class="number">3</span>] * (<span class="number">1</span> - alpha);</span><br><span class="line">d[j * <span class="number">3</span> + <span class="number">1</span>] = p[j * <span class="number">3</span> + <span class="number">1</span>] * alpha + t[j * <span class="number">3</span> + <span class="number">1</span>] * (<span class="number">1</span> - alpha);</span><br><span class="line">d[j * <span class="number">3</span> + <span class="number">2</span>] = p[j * <span class="number">3</span> + <span class="number">2</span>] * alpha + t[j * <span class="number">3</span> + <span class="number">2</span>] * (<span class="number">1</span> - alpha);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">ImageStitching</span><span class="params">( Mat&amp; img1, Mat&amp; img2,<span class="type">bool</span> isDebug=<span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat KeyPointImage1, KeyPointImage2;</span><br><span class="line"><span class="comment">//Ptr&lt;SurfFeatureDetector&gt; detector = SurfFeatureDetector::create(); //surf检测子</span></span><br><span class="line"><span class="comment">//Ptr&lt;HarrisLaplaceFeatureDetector&gt; detector = HarrisLaplaceFeatureDetector::create();//harris检测子</span></span><br><span class="line">Ptr&lt;FastFeatureDetector&gt; detector = FastFeatureDetector::<span class="built_in">create</span>(); <span class="comment">//fast检测子</span></span><br><span class="line"></span><br><span class="line">Ptr&lt;SiftDescriptorExtractor&gt; extractor = SiftDescriptorExtractor::<span class="built_in">create</span>(); <span class="comment">//sift展开子，opencv只有这个展开子</span></span><br><span class="line"></span><br><span class="line">vector&lt;cv::KeyPoint&gt; KeyPoint1, KeyPoint2; <span class="comment">//特征点</span></span><br><span class="line"></span><br><span class="line">Mat KeyVector1, KeyVector2; <span class="comment">//展开的特征向量</span></span><br><span class="line"></span><br><span class="line">detector-&gt;<span class="built_in">detect</span>(img1, KeyPoint1); <span class="comment">//计算特征点</span></span><br><span class="line">detector-&gt;<span class="built_in">detect</span>(img2, KeyPoint2);<span class="comment">//计算特征点</span></span><br><span class="line">extractor-&gt;<span class="built_in">compute</span>(img1, KeyPoint1, KeyVector1); <span class="comment">//计算特征点的向量</span></span><br><span class="line">extractor-&gt;<span class="built_in">compute</span>(img2, KeyPoint2, KeyVector2);<span class="comment">//计算特征点的向量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">drawKeypoints</span>(img1, KeyPoint1, KeyPointImage1);<span class="comment">//画特征点</span></span><br><span class="line"><span class="built_in">drawKeypoints</span>(img2, KeyPoint2, KeyPointImage2);<span class="comment">//画特征点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDebug)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;KeyPointImage1&quot;</span>, KeyPointImage1);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;KeyPointImage2&quot;</span>, KeyPointImage2);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;vector&quot;</span>, KeyVector1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建暴力匹配器</span></span><br><span class="line">Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::<span class="built_in">create</span>(DescriptorMatcher::MatcherType::BRUTEFORCE);</span><br><span class="line"></span><br><span class="line">vector&lt;DMatch&gt; match, GoodMatch; <span class="comment">//匹配的点和优秀的匹配点</span></span><br><span class="line"></span><br><span class="line">matcher-&gt;<span class="built_in">match</span>(KeyVector2, KeyVector1, match); <span class="comment">//计算匹配点</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Max_dist = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> Min_dist = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; img1.rows; i++) <span class="comment">//找到距离最短的匹配点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> dist = match[i].distance;</span><br><span class="line"><span class="keyword">if</span> (dist &lt; Min_dist)Min_dist = dist;</span><br><span class="line"><span class="keyword">if</span> (dist &gt; Max_dist)Max_dist = dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; img1.rows; i++) <span class="comment">//利用最小距离法寻找优秀的匹配点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (match[i].distance &lt; <span class="number">2</span> * Min_dist)</span><br><span class="line">GoodMatch.<span class="built_in">push_back</span>(match[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDebug)</span><br><span class="line">&#123;</span><br><span class="line">Mat ImageMatch;</span><br><span class="line"><span class="built_in">drawMatches</span>(img1, KeyPoint1, img2, KeyPoint2, GoodMatch, ImageMatch);<span class="comment">//画出匹配的图</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;ImageMatch&quot;</span>, ImageMatch);</span><br><span class="line"><span class="built_in">waitKey</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特征点特征转换</span></span><br><span class="line">vector&lt;Point2f&gt; imagePoints1, imagePoints2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; GoodMatch.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">imagePoints2.<span class="built_in">push_back</span>(KeyPoint2[GoodMatch[i].queryIdx].pt); <span class="comment">//顺序增大</span></span><br><span class="line">imagePoints1.<span class="built_in">push_back</span>(KeyPoint1[GoodMatch[i].trainIdx].pt);  <span class="comment">//跳变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat homo = <span class="built_in">findHomography</span>(imagePoints2, imagePoints1, RANSAC);<span class="comment">//计算单应性矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CalcCorners</span>(homo, img2); <span class="comment">//计算转换后的图片的顶点</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; homo &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;顶点坐标&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; corners.right_top &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; corners.right_bottom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; corners.left_top &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; corners.left_bottom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Mat imageTransform1;<span class="comment">//透视变换后的图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变换图像</span></span><br><span class="line"><span class="built_in">warpPerspective</span>(img2, imageTransform1, homo, <span class="built_in">Size</span>(<span class="built_in">MAX</span>(<span class="built_in">MIN</span>(corners.right_top.x, corners.right_bottom.x), <span class="built_in">MIN</span>(corners.left_top.x, corners.left_bottom.x)), img1.rows));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDebug)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;imageTransform&quot;</span>, imageTransform1);</span><br><span class="line">cout &lt;&lt; imageTransform1.<span class="built_in">size</span>();</span><br><span class="line">cout &lt;&lt; img2.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">waitKey</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">FinalImage</span><span class="params">(imageTransform1.rows, imageTransform1.cols, CV_8UC3)</span></span>; <span class="comment">//最终图像的矩阵</span></span><br><span class="line">FinalImage.<span class="built_in">setTo</span>(<span class="number">0</span>);<span class="comment">//初始清零</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进行图像拼接</span></span><br><span class="line">imageTransform1.<span class="built_in">copyTo</span>(<span class="built_in">FinalImage</span>(<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, imageTransform1.cols, imageTransform1.rows)));</span><br><span class="line">img1.<span class="built_in">copyTo</span>(<span class="built_in">FinalImage</span>(<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, img1.cols, img1.rows)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDebug)</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;FinalImage&quot;</span>, FinalImage);</span><br><span class="line"></span><br><span class="line"><span class="built_in">OptimizeSeam</span>(img1, imageTransform1, FinalImage); <span class="comment">//拼接缝优化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FinalImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工程使用OpenCV4.1,Qt5.13,visual studio2019构建。工程下载地址如下：</p><p><a href="https://github.com/ZzzzzzS/imagestitch/releases/tag/1.0">https://github.com/ZzzzzzS/imagestitch/releases/tag/1.0</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次新学习了OpenCV在图像处理当中的应用。重新复习了C++和Qt相关的基本语法和框架，也体会到了C++语言性能上的优势和OpenCV强大的图像处理能力。</p><p>我学习到了很多数字图像处理方面的知识，学习到了很多课本以外的知识。尤其是在特征点检测方面，我了解到了很多很新很先进的算法，比如fast，sift，surf，harris，ORB算法等等。另外在图像变换方面我学习到了透视变换和仿射变换等变换，也加深了对矩阵和图像的理解。</p><p>在写这个程序的时候，我遇到了很多很大的困难，但最终都独立一一克服了。由于我使用的是最新版的OpenCV，最新版OpenCV移除了原本的各种检测子而只提供源码编译。所以在OpenCV环境的搭建上遇到了很大的困难。其次由于新版OpenCV修改了很多函数的用法，这导致和网络上的资料有很多不一样的地方，不过这通过一步一步的阅读官方的文档，最终独立写出了整个拼接算法。在克服了重重困难之后，这进一步提高了我的代码能力和对OpenCV的熟悉程度，同时也增强了我独立解决问题的能力。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>   Rafael C.G.数字图像处理(第三版).电子工业出版社,2017.5</li><li>   金大(臣尔).Qt5开发实战.人民邮电出版社,2015.9</li><li>   胡社教.基于相位相关的全景图像拼接.合肥工业大学学报(自然科学版),2007.1第30卷第1期</li><li>   Madcola. OpenCV探索之路（二十三）：特征检测和特征匹配方法汇总，<a href="https://www.cnblogs.com/skyfsm/p/7401523.html">https://www.cnblogs.com/skyfsm/p/7401523.html</a></li><li>   Madcola. OpenCV探索之路（二十四）图像拼接和图像融合技术, <a href="https://www.cnblogs.com/skyfsm/p/7411961.html">https://www.cnblogs.com/skyfsm/p/7411961.html</a></li><li>   Open Source Computer Vision.API Online documentation.4.10</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;简易图像拼接原理初探&quot;&gt;&lt;a href=&quot;#简易图像拼接原理初探&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="数字信号处理" scheme="https://blog.zzshub.cn/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>简易语音辨识原理初探</title>
    <link href="https://blog.zzshub.cn/2019/07/16/VoiceRecognition/"/>
    <id>https://blog.zzshub.cn/2019/07/16/VoiceRecognition/</id>
    <published>2019-07-16T14:00:23.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简易语音辨识原理初探"><a href="#简易语音辨识原理初探" class="headerlink" title="简易语音辨识原理初探"></a>简易语音辨识原理初探</h1><blockquote><p>很久没有写博客了，最近博客还因为各种原因故障了，反正现在修好了，不管了凑合用吧。最近学习了语音识别相关的一些知识，就在这里简单记录以下学习过程吧。</p></blockquote><h1 id="流程简介"><a href="#流程简介" class="headerlink" title="流程简介"></a>流程简介</h1><p>识别任何一个东西流程基本都是先获取这个东西的特征，之后再根据它的特征来判断这个东西的类别，语音识别也不例外。整个识别过程首先进行语音信号的采集，采集到语音信号之后获取信号的mfcc（Mel频率倒谱系数）参数，也就是语音信号的特征。随后采集到特征之后与和预先存入的语音模板进行匹配，也就是根据特征判断类别，匹配过程使用dtw（动态时间归整）算法。整个方案流程图如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">input=&gt;inputoutput: 采集语音信号</span><br><span class="line">mfcc=&gt;operation: 获取mfcc参数</span><br><span class="line">dtw=&gt;operation: dtw算法进行模板匹配</span><br><span class="line">out=&gt;inputoutput: 输出匹配的结果</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">st-&gt;input-&gt;mfcc-&gt;dtw-&gt;out-&gt;e</span><br></pre></td></tr></table></figure><p>其实核心就两部分</p><ul><li>mfcc参数提取</li><li>dtw模板匹配</li></ul><h1 id="mfcc参数提取"><a href="#mfcc参数提取" class="headerlink" title="mfcc参数提取"></a>mfcc参数提取</h1><p>我们现在知道了语音识别的第一步是获取到语音信号的特征，好在科学家们已经为我们找到一种很好描述语音特征的方法，于是就引出了mfcc这样一种可以描述不同语言特征的东西。<strong>mfcc(Mel Frequency Cepstral Coefficents)</strong> 翻译过来就是 <strong>梅尔频率倒谱系数</strong>。那么这是个啥，根据名字我想把它拆分成两部分，即梅尔频率和倒谱系数。</p><h2 id="倒谱系数是什么"><a href="#倒谱系数是什么" class="headerlink" title="倒谱系数是什么"></a>倒谱系数是什么</h2><p>倒谱是什么这个概念可能大家没有听说过，但学习过信号与系统都应该知道频谱是什么。首先我们来看一个频谱：</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/voicerecognition/fft.png"></p><p>图为数字”0”的短时傅里叶变换的频谱。这里又引入了一个概念叫短时傅里叶变换，它的意思是将一段长时间(比如2s)的语音信号进行拆分成一帧一帧的短时信号(这里使用的25ms)，再计算这一帧语音信号的频谱。长时间的傅里叶变换出来的频谱不同语言差异不大，毕竟时间一长数据一多就一不小心依概率收敛到一个差不多的频谱范围了，这样就没办法提取特征。只有短时间的频谱才有明显的差异，并且结合帧与帧之间的变化情况才能更好的获取特征。</p><p>此外，观察这张频谱图可以发现在特定位置有一些峰，并且这些峰之间的间隔还差不太多，也就是说这些峰有特定的频率分量。到这里就引入了频谱的频谱的概念，离我们想要的倒谱的距离越来越近了哈。在这里我们把这些峰叫做共振峰，由一个声音的基频和它的高次谐波的叠加，也正是因为谐波分量的幅值不同，从而产生了各种各样的音色。<strong>由于共振峰在频谱上十分明显，我们就想到把他提取出来，通过检测帧与帧之间共振峰的变化情况不就能找到一个语音的特征了吗？</strong> 我们要提取的不仅仅是共振峰的位置，还得提取它们转变的过程。所 以我们提取的是频谱的包络。这包络就是一条连接这些共振峰点的平滑曲线。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/voicerecognition/mfcc1.png"></p><p>那么我们如何提取这条曲线？我们可以将这条复杂的曲线分成两部分，包络和细节。从而可以写出表达式：$曲线&#x3D;包络\times细节$，通过对曲线求对数就可以得到新的表达式：$\log(曲线)&#x3D;\log(包络)+\log(细节)$好了这样我们就把一个乘性信号变成了一个加性信号。对这个加性信号做傅里叶变换再取它的低频分量，我们就成功的获取到了包络的频率，也就是共振峰的频率。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/voicerecognition/mfcc2.png"><br>好了到目前为止，我们获取到的这个频谱就被称之为 <strong>倒谱</strong> 它把乘性信号分离成了加性信号，而这整个过程我们称之为<strong>同态滤波</strong>。因为，做了两次fft得到了频域的频域，从另一个角度来说两次fft又相当与变换到了时域，所以输入输出信号都是时域，所以是同态。</p><p>由于我们只关系共振峰，也就是倒谱的低频分量，所以我们通常来说只取倒谱的前13个参数即可。最后再总结一遍流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time=&gt;inputoutput: 乘性时域信号</span><br><span class="line">DFT=&gt;operation: 信号频谱</span><br><span class="line">ln=&gt;operation: 对数变换</span><br><span class="line">IDFT=&gt;operation: 再次DFT</span><br><span class="line">out=&gt;inputoutput: 加性时域信号</span><br><span class="line">time-&gt;DFT-&gt;ln-&gt;IDFT-&gt;out</span><br></pre></td></tr></table></figure><p>$x(n)&#x3D;x_1(n)\ast x_2(n) \longrightarrow \hat x(n)&#x3D;\hat x_1(n)+ \hat x_2(n)$</p><h2 id="梅尔频率是什么"><a href="#梅尔频率是什么" class="headerlink" title="梅尔频率是什么"></a>梅尔频率是什么</h2><p>到这里我们又涉及到了另一个关键词–梅尔频率(Mel-Frequency)。对于人类听觉感知的实验表明，人类听觉的感知只聚焦在某些特定的区域，而不是整个频谱包络。人的听觉系统是一个特殊的非线性系统，它响应不同频率信号的灵敏度是不同的。在语音特征的提取上，人类听觉系统做 得非常好，它不仅能提取出语义信息, 而且能提取出说话人的个人特征，这些都是现有的语音识别系统所望尘莫及的。如果在语音识别系统中能模拟人类听觉感知处理特点，就有可能提高语音的识别率。在Mel频域内，人对音调的感知度为线性关系。举例来说，如果两段语音的Mel频率相差两倍，则人耳听起来两者的音调也相差两倍。</p><p>综上得出两点结论：</p><ul><li>人耳频率非线性</li><li>人耳对某些频率分量不敏感</li></ul><p>所以为了更好的模拟人耳，我们需要对声音信号做一些处理，对于非线性问题我们用梅尔频率来解决，对于不敏感问题我们就用带通滤波器组来解决，结合起来我们就有了<strong>梅尔滤波器组</strong>。<br>流程图如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in=&gt;inputoutput: 输入信号</span><br><span class="line">mel=&gt;operation: 变换到mel频率</span><br><span class="line">filter=&gt;operation: mel频率内带通滤波</span><br><span class="line">imel=&gt;operation: 变换到hz频率</span><br><span class="line">out=&gt;inputoutput: 输出信号</span><br><span class="line"></span><br><span class="line">in-&gt;mel-&gt;filter-&gt;imel-&gt;out</span><br></pre></td></tr></table></figure><p>Mel频率的公式如下：$$ Mel(f)&#x3D;2595\times\lg(1+\frac{f}{700})$$<br>或者$$Mel(f)&#x3D;1125\times\ln(1+\frac{f}{700})$$</p><p>Mel带通滤波器公式如下：<br>$$H_m(k)&#x3D;\begin{cases}<br> 0  &amp; k&lt;f(m-1) \\<br>  \frac{2(k-f(m-1))}{(f(m+1)-f(m-1))(f(m)-f(m-1))} &amp; f(m-1) \leq k\leq f(m) \\<br>   \frac{2(f(m+1)-k)}{(f(m+1)-f(m-1))(f(m)-f(m-1))} &amp; f(m) \leq k\leq f(m+1) \\<br>   0&amp; k \geq f(m+1)<br>   \end{cases}$$</p><p>Mel滤波器在hz频率如图所示：</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/voicerecognition/mel.png"></p><p>##完整的mfcc参数提取过程</p><p>说了这么多，最终结合起来流程图就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">time=&gt;inputoutput: 乘性时域信号</span><br><span class="line">f=&gt;operation: 预加重</span><br><span class="line">fen=&gt;operation: 分帧</span><br><span class="line">window=&gt;operation: 加窗</span><br><span class="line">DFT=&gt;operation: 信号频谱</span><br><span class="line">mel=&gt;operation: mel滤波器滤波</span><br><span class="line">ln=&gt;operation: 对数变换</span><br><span class="line">IDFT=&gt;operation: 再次DFT</span><br><span class="line">out=&gt;inputoutput: 加性时域信号</span><br><span class="line">time-&gt;f-&gt;fen-&gt;window-&gt;DFT-&gt;mel-&gt;ln-&gt;IDFT-&gt;out</span><br></pre></td></tr></table></figure><p>需要说明的是人说话高频分量往往不是很大，但是为了抓取特征就需要增强高频分量，即预加重。另外分帧之后加窗有利于帧间信号平稳过渡。最终得到的应该是一个长宽分别为mfcc参数维度(一般取13维)和帧个数的矩阵。</p><h2 id="mfcc参数提取部分python代码如下"><a href="#mfcc参数提取部分python代码如下" class="headerlink" title="mfcc参数提取部分python代码如下"></a>mfcc参数提取部分python代码如下</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> scipy.io.wavfile</span><br><span class="line"><span class="keyword">import</span> scipy.signal</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> dct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">melSpectrogram</span>(<span class="params">sample_rate,NFFT,nfilt</span>):</span><br><span class="line">    low_freq_mel = <span class="number">0</span></span><br><span class="line">    <span class="comment">#将频率转换为Mel</span></span><br><span class="line">    high_freq_mel = (<span class="number">2595</span> * numpy.log10(<span class="number">1</span> + (sample_rate / <span class="number">2</span>) / <span class="number">700</span>))</span><br><span class="line">    mel_points = numpy.linspace(low_freq_mel, high_freq_mel, nfilt + <span class="number">2</span>)  <span class="comment"># 生成在Mel频率的等间隔序列</span></span><br><span class="line">    hz_points = (<span class="number">700</span> * (<span class="number">10</span>**(mel_points / <span class="number">2595</span>) - <span class="number">1</span>))  <span class="comment"># 转换Mel频率转换为Hz频率</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bin</span> = numpy.floor((NFFT + <span class="number">1</span>) * hz_points / sample_rate) <span class="comment">#获取数字频率长度</span></span><br><span class="line"></span><br><span class="line">    fbank = numpy.zeros((nfilt, <span class="built_in">int</span>(numpy.floor(NFFT / <span class="number">2</span> + <span class="number">1</span>)))) <span class="comment">#生成全零矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nfilt + <span class="number">1</span>):</span><br><span class="line">        f_m_minus = <span class="built_in">int</span>(<span class="built_in">bin</span>[m - <span class="number">1</span>])   <span class="comment"># left</span></span><br><span class="line">        f_m = <span class="built_in">int</span>(<span class="built_in">bin</span>[m])             <span class="comment"># center</span></span><br><span class="line">        f_m_plus = <span class="built_in">int</span>(<span class="built_in">bin</span>[m + <span class="number">1</span>])    <span class="comment"># right</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(f_m_minus, f_m):</span><br><span class="line">            fbank[m - <span class="number">1</span>, k] = (k - <span class="built_in">bin</span>[m - <span class="number">1</span>]) / (<span class="built_in">bin</span>[m] - <span class="built_in">bin</span>[m - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(f_m, f_m_plus):</span><br><span class="line">            fbank[m - <span class="number">1</span>, k] = (<span class="built_in">bin</span>[m + <span class="number">1</span>] - k) / (<span class="built_in">bin</span>[m + <span class="number">1</span>] - <span class="built_in">bin</span>[m])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#plt.plot(fbank)</span></span><br><span class="line">    <span class="comment">#plt.show()</span></span><br><span class="line">    <span class="comment">#print(fbank.shape)</span></span><br><span class="line">    <span class="keyword">return</span> fbank</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mfcc</span>(<span class="params">audioin,fs</span>):</span><br><span class="line">    <span class="comment">#audio_filtered=scipy.signal.filtfilt([1,0.97],1,audioin)</span></span><br><span class="line">    AudioFiltered=numpy.append(audioin[<span class="number">0</span>], audioin[<span class="number">1</span>:] - <span class="number">0.97</span> * audioin[:-<span class="number">1</span>]) <span class="comment">#信号预加重</span></span><br><span class="line"></span><br><span class="line">    AudioLength=<span class="built_in">len</span>(AudioFiltered) <span class="comment">#信号长度</span></span><br><span class="line">    StepLength=<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="number">0.01</span>*fs)) <span class="comment">#步长</span></span><br><span class="line">    FrameLength=<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="number">0.025</span>*fs)) <span class="comment">#帧长度</span></span><br><span class="line">    FrameN=<span class="built_in">int</span>(numpy.ceil((AudioLength-FrameLength)/StepLength)) <span class="comment">#计算帧的个数</span></span><br><span class="line">    AudioLengthFixed=<span class="built_in">int</span>(StepLength*FrameN+FrameLength) <span class="comment">#计算可以被整除的信号长度</span></span><br><span class="line"></span><br><span class="line">    zeros=numpy.zeros(AudioLengthFixed-AudioLength)</span><br><span class="line">    AudioFilteredFixed=numpy.append(AudioFiltered,zeros) <span class="comment">#将信号的长度补零，使得信号能够被整除</span></span><br><span class="line"></span><br><span class="line">    indices=numpy.tile(numpy.arange(<span class="number">0</span>, FrameLength), (FrameN, <span class="number">1</span>)) + numpy.tile(numpy.arange(<span class="number">0</span>, FrameN * StepLength, StepLength), (FrameLength, <span class="number">1</span>)).T</span><br><span class="line">    indices=numpy.mat(indices).astype(numpy.int32,copy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    Frame=AudioFilteredFixed[indices]</span><br><span class="line"></span><br><span class="line">    Frame*=numpy.hamming(FrameLength) <span class="comment">#时域加窗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(Frame.shape)</span></span><br><span class="line"></span><br><span class="line">    NFFT=<span class="number">2048</span></span><br><span class="line">    FRAME=<span class="built_in">abs</span>(numpy.fft.rfft(Frame,NFFT)) <span class="comment">#逐帧计算fft</span></span><br><span class="line">    <span class="comment">#print(FRAME.shape)</span></span><br><span class="line">    <span class="comment">#plt.plot(FRAME[100])</span></span><br><span class="line">    <span class="comment">#plt.show()</span></span><br><span class="line">    FRAME=(<span class="number">1.0</span> / NFFT)*((FRAME)**<span class="number">2</span>) <span class="comment">#计算功率谱</span></span><br><span class="line">    fbank=melSpectrogram(fs,NFFT,<span class="number">24</span>) <span class="comment">#获取梅尔滤波器组参数</span></span><br><span class="line"></span><br><span class="line">    AudioMel=numpy.dot(FRAME,fbank.T) <span class="comment">#频域滤波</span></span><br><span class="line">    AudioMel=numpy.where(AudioMel==<span class="number">0</span>,numpy.finfo(<span class="built_in">float</span>).eps,AudioMel)<span class="comment">#防止log10(0)的情况</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    AudioMel=<span class="number">20</span>*numpy.log10(AudioMel) <span class="comment">#对数变换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#plt.plot(AudioMel)</span></span><br><span class="line">    <span class="comment">#plt.show()</span></span><br><span class="line">    <span class="comment">#print(AudioMel.shape)</span></span><br><span class="line">    </span><br><span class="line">    mfcc=dct(AudioMel)[:,<span class="number">1</span>:<span class="number">13</span>] <span class="comment">#dtc变换获取倒谱</span></span><br><span class="line">    <span class="comment">#plt.plot(mfcc.T)</span></span><br><span class="line">    <span class="comment">#plt.show()</span></span><br><span class="line">    <span class="comment">#print(AudioMel.shape)</span></span><br><span class="line">    <span class="keyword">return</span> mfcc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sample_rate,signal=scipy.io.wavfile.read(<span class="string">&#x27;0.wav&#x27;</span>)</span><br><span class="line">    mfcc(signal,sample_rate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="DTW算法模板匹配"><a href="#DTW算法模板匹配" class="headerlink" title="DTW算法模板匹配"></a>DTW算法模板匹配</h1><p>DTW算法即动态时间规整算法。对于语音识别我们很简单的想法就是逐帧计算输入信号和模板之间的欧式距离，之后再将每一帧的距离相加求得一个总的距离，如果距离小于某个阈值我们就能认为这两个信号很相似，就匹配成功。依次匹配多个模板，找到距离最短的模板就能识别一些关键字了。</p><p>$$ 总距离&#x3D;\sum^{所有的帧}_{i}{\sqrt{\sum_j^{维度}(模板_j-信号_j)^2}}$$</p><p><strong>但是！</strong> 想法虽然简单，不过考虑到人说话的快慢问题和语音信号长短问题，这样计算相似度往往不是很准确，甚至不同长度的信号根本无法计算相似度。比如下图所示信号，相似程度很高但是按照上面的算法却无法计算出来正确的相似度,而通过虚线对应关系计算出来的相似度才是正确的相似度。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/voicerecognition/dtw.png"><br><strong>通过将一个信号扭曲之后再和另一个信号计算相似程度</strong>就能解决问题。并且这里的信号扭曲也只能是局部的平移伸长或者缩短，但不能出现局部信号反转的情况。</p><p>那么怎样将信号扭曲呢。我们不妨假设信号$\vec a$长度为6，信号$\vec b$长度为4，逐个计算$\vec a$中每个元素和$\vec b$中每个元素的欧式距离，我们就能得到一个$6\times 4$的矩阵，如下所示：<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/voicerecognition/des.png"></p><p>其中[A,1]点代表$\vec a[1]$和$\vec b[1]$的距离，[D,3]点代表$\vec a[5]$和$\vec b[3]$的距离以此类推。左下角代表两个信号的起始点，右上角代表两个信号的终点。因为信号是在局部可以扭曲的，所以我们寻找最短距离就在某个点的邻域内寻找最短的距离。但又因为局部信号不能反转，所以我们只需要在某个点的上方，右方和右上方寻找最短距离即可。比如[C,2]点的下一个点的距离分别是7，4，2，这里我们取最小点2。从起始点依次求最短路径后就能得到一条蜿蜒的曲线，将这条曲线上左右的距离加起来就能得到总最短路径，也就是两个信号的相似程度。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/voicerecognition/des2.png"></p><p>当然了直接这样找距离会存在一些问题。因为这个找出来的距离高度依赖起始点的位置，但是如果这个两个信号相似的起始点不在一起这样找出来的距离不就不正确了吗？更好的方法是找出终点后再回溯回来，不过这样略微复杂，而且我发现不回溯其实识别效果也不错，所以我也没有进一步研究。</p><p>到目前为止我们就获得了两个信号之间的距离，多次进行模板匹配再取最小距离就能识别特定的关键字啦。</p><h2 id="DTW模板匹配部分python代码如下"><a href="#DTW模板匹配部分python代码如下" class="headerlink" title="DTW模板匹配部分python代码如下"></a>DTW模板匹配部分python代码如下</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mfcc <span class="keyword">import</span> mfcc</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> scipy.io.wavfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dtw</span>(<span class="params">t,r</span>):</span><br><span class="line">    n=<span class="built_in">len</span>(t) <span class="comment">#获取信号长度</span></span><br><span class="line">    m=<span class="built_in">len</span>(r)</span><br><span class="line">    d=numpy.zeros((n,m)) <span class="comment">#生成零矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            d[i,j]=numpy.linalg.norm(t[i,:]-r[j,:])</span><br><span class="line">    D=numpy.zeros((n,m))</span><br><span class="line"></span><br><span class="line">    D[<span class="number">0</span>,<span class="number">0</span>]=d[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    D[<span class="number">0</span>,<span class="number">1</span>]=d[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    D[<span class="number">1</span>,<span class="number">0</span>]=d[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>):</span><br><span class="line">            D[i+<span class="number">1</span>,j+<span class="number">1</span>]=<span class="built_in">min</span>((D[i+<span class="number">1</span>,j]+d[i+<span class="number">1</span>,j+<span class="number">1</span>]),(D[i,j+<span class="number">1</span>]+d[i+<span class="number">1</span>,j+<span class="number">1</span>]),(D[i,j]+d[i+<span class="number">1</span>,j+<span class="number">1</span>])) </span><br><span class="line">            <span class="comment">#print(D[i+1,j+1])</span></span><br><span class="line">        <span class="comment">#print(&#x27;aaas&#x27;)</span></span><br><span class="line">    <span class="comment">#numpy.set_printoptions(threshold = 1e6)</span></span><br><span class="line">    <span class="comment">#print(D)</span></span><br><span class="line">    <span class="keyword">return</span> D[-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="工程源码"><a href="#工程源码" class="headerlink" title="工程源码"></a>工程源码</h1><p>工程源码可以从本站下载：<a href="https://github.com/ZzzzzzS/Numbervoicerecognition/releases/tag/V1.0">https://github.com/ZzzzzzS/Numbervoicerecognition/releases/tag/V1.0</a></p><p>需要的包：numpy，scipy，pyaudio，PySide2等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>写到这里我已经没什么好说的了，但是还是要假装有个总结，来证明我又学到了什么新的东西。。。</p></blockquote><p>思考了很久确实不知道写啥了，就这样吧，the  end！</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>   胡航.语音信号处理.哈尔滨工业大学出版社,2009.7</li><li>   周志权等.数字信号处理.哈尔滨工业大学出版社,2012.12</li><li>   张学工.模式识别(第三版).清华大学出版社,2010.8</li><li>   金大(臣尔).Qt5开发实战.人民邮电出版社,2015.9</li><li>   IT-Sunshine.动态规划DTW算法的实现,<br><a href="https://blog.csdn.net/weixin_39338645/article/details/84063108">https://blog.csdn.net/weixin_39338645/article/details/84063108</a></li><li>   Zouxy09.语音信号处理之（四）梅尔频率倒谱系数（MFCC）,<br><a href="https://blog.csdn.net/zouxy09/article/details/9156785">https://blog.csdn.net/zouxy09/article/details/9156785</a></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;简易语音辨识原理初探&quot;&gt;&lt;a href=&quot;#简易语音辨识原理初探&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="数字信号处理" scheme="https://blog.zzshub.cn/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>利用相关函数进行元素识别的一个实验性观点</title>
    <link href="https://blog.zzshub.cn/2019/06/06/relevant/"/>
    <id>https://blog.zzshub.cn/2019/06/06/relevant/</id>
    <published>2019-06-06T14:00:23.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用相关函数进行元素识别的一个实验性观点"><a href="#利用相关函数进行元素识别的一个实验性观点" class="headerlink" title="利用相关函数进行元素识别的一个实验性观点"></a>利用相关函数进行元素识别的一个实验性观点</h1><blockquote><p>随着NXP智能车竞赛的发展，赛道元素种类越来越多(比如圆环)。在以往的比赛中我们一般采用特征识别的方法来检测这些赛道元素，这种方法缺点很明显，需要为不同的特征设计不同的识别方法。本文主要探讨利用相关函数的特性构建一个通用的识别方法。</p></blockquote><h1 id="流程简介"><a href="#流程简介" class="headerlink" title="流程简介"></a>流程简介</h1><p>本方法的大概流程：</p><ul><li>确定识别模板序列x</li><li>待检测的序列y</li><li>对x和y序列做傅里叶变换得到X和Y序列</li><li>对X序列就共轭序列得到X’序列</li><li>X’序列和Y序列逐项相乘获得频域相关序列R</li><li>对R序列进行傅里叶反变换得到时域相关序列r</li><li>检测r序列的值，若r大于设定的阈值即可认为识别成功</li></ul><h1 id="从相关系数到互相关函数"><a href="#从相关系数到互相关函数" class="headerlink" title="从相关系数到互相关函数"></a>从相关系数到互相关函数</h1><h2 id="相关系数的意义"><a href="#相关系数的意义" class="headerlink" title="相关系数的意义"></a>相关系数的意义</h2><p>好了我们从头的来理解这个方法，本方法的出发点是概率论中的协方差Cov和相关系数$\rho$. 首先回顾一下自相关的意义，我个人的表述是<strong>一个数列y能由另一个数列x线性表示(y&#x3D;ax+b)的程度，如果如果相关系数等于1那么y当中的每一个值都能由对应的x值来线性表示</strong>。对于协方差和相关系数的理解可以参考知乎上的这个回答<a href="https://www.zhihu.com/question/20852004?sort=created">https://www.zhihu.com/question/20852004?sort=created</a>, <strong>注意一定要理解清楚相关系数的概念，这是本方法的核心</strong>！顺便再插一句变量相关和独立的区别，变量相关指的是y能由x线性表示，即y&#x3D;ax+b。但独立指的是y完全和x没有关系，完全不能用x表示，即不能用$y&#x3D;ax+b,y&#x3D;ax^2$或者其他任何方式表示。</p><h2 id="相关系数的定义与相关函数"><a href="#相关系数的定义与相关函数" class="headerlink" title="相关系数的定义与相关函数"></a>相关系数的定义与相关函数</h2><p>好了，假设相关系数和协方差的意义我们已经了解清楚了。那么接下来请看协方差的公式：</p><p>$$ Cov&#x3D;E{[x(n)-E(x)][y(n)-E(y)]} &#x3D; 1&#x2F;N \sum_1^N{[x(n)-E(x)][y(n)-E(y)]} $$</p><p>Cov的大小就可表示序列的相关性</p><p>我们将相关性公式进行进一步简化得到：</p><p>$$ r&#x3D;\sum_1^N{[x(n)-E(x)][y(n)-E(y)]}$$</p><p>对于信号来说可以分为直流分量和交流分量，对于直流分量可由数学期望来表示，即E(x)。对于一般信号而言，我们只考虑信号的交流分量。所以表示相关性的公式就可以进一步简化：</p><p>$$ r&#x3D;\sum_1^N{[x(n)][y(n)]}$$</p><p>好了，到目前为止我们已经可以获得一个r，用来表示两个序列(信号)的相关性了。对于这个公式我再给出另外一种理解方式：相关运算从线性空间的角度看其实是内积运算，而两个向量的内积在线性空间中表示一个向量向另一个向量的投影，表示两个向量的相似程度，所以相关运算就体现了这种相似程度。</p><p><strong>于是我们检测赛道元素就只需要先确定一组特征，然后传感器采集回来的值一直按照上面的函数计算出一个r，只要r大于一个设定的阈值，就说明元素识别成功</strong>。但是很快就会发现问题，比如x&#x3D;{1,2,3,4,5,0,0},y&#x3D;{3,4,5,0,0,1,2}.那么按照上述的方法计算出来相关性就很差，但是实际上这两组序列其实是一样的，只是相位不同而已。要解决这个问题我们就需要进一步引入相关函数的定义：</p><p>$$r_{xy}(m)&#x3D;\sum_1^N{[x(n)][y(n-m)]}$$</p><p>这个函数的定义就是不断平移其中的一个序列，计算出不同相位条件下的相关性。好了这个相位差的问题看似是解决了。但是仔细计算就能发现如果两个序列很长那么计算量就会变得非常的巨大！一个序列如果长度为n，平移n次那么就需要进行$4n^2$次乘法加法计算！对于80长度的图像来说就需要25,600‬次计算，这恐怖的计算量完全无法接受！于是我们就进一步引入了相关的快速算法。</p><h1 id="相关，卷积与快速傅里叶变换"><a href="#相关，卷积与快速傅里叶变换" class="headerlink" title="相关，卷积与快速傅里叶变换"></a>相关，卷积与快速傅里叶变换</h1><p>这部分内容需要学习信号与系统，数字信号处理的课程才能够完全理解，如果实在无法理解可暂时跳过，直接看快速算法的步骤。</p><p>1.1 首先我们来看看卷积的定义：<br>$$X(m)\ast Y(m)&#x3D;\sum_1^N{[x(m)][y(n-m)]}$$<br>这个和相关函数长得好像是吧！</p><p>1.2 再看看相关的公式<br>$$r_{xy}(m)&#x3D;\sum_1^N{[x(n)][y(n-m)]}&#x3D;\sum_1^N{[x(n)][y(-(m-n))]}&#x3D;X(m)\ast Y(-m)$$<br>好了我们现在知道了卷积和相关就差一个负号。</p><p>2.1 对于学过信号与系统的同学们应该都知道时域卷积对于频域乘积，频域卷积对于时域乘积。那么既然相关运算和卷积长得如此相像，那么我们能不能把信号弄到频域去，这样一个简单的相乘就能解决卷积的复杂计算的问题了吗。所以我们现在得到了思路：</p><ul><li>x(n)和y(n)序列变换到频域获得X(n)和Y(n)序列</li><li>把Y(n)序列取共轭，即反转一下得到Y(-n)，</li><li>频域两个序列逐项相乘，得到频域相关函数R(n)</li><li>对R(n)进行反傅里叶变换得到时域相关函数r(n)</li><li>检测时域r(n)，判断是否满足相关的阈值</li></ul><p>3.1 于是现在的问题就变成了如何快速的求解序列的傅里叶变换，可能大家都听说过一个叫<strong>快速傅里叶变换FFT</strong>的算法。这个算法也不是很快就能讲清楚的，反正大家只要知道这个算法能够显著的减少傅里叶变换的计算量就行了，同时感谢cortex-M3系列内核内置的CMSIS-DSP算法库已经通过软硬件结合起来帮助我们完成了这个算法。总之，FFT和IFFT(逆FFT)都已实现。<br><a href="https://arm-software.github.io/CMSIS_5/DSP/html/group__ConvolutionExample.html">https://arm-software.github.io/CMSIS_5&#x2F;DSP&#x2F;html&#x2F;group__ConvolutionExample.html</a></p><h1 id="相关算法的具体步骤"><a href="#相关算法的具体步骤" class="headerlink" title="相关算法的具体步骤"></a>相关算法的具体步骤</h1><p>好了到目前为止这个算法就算是大概实现了，不过由于是取值都是离散过程，和连续函数还是有一些区别。整体流程如下：</p><ol><li>给定x(n)长度为N1，y(n)长度为N2</li><li>将x(n)与y(n)两个序列分别在末尾补0，让序列都变成长度为L的序列，其中$L\geq N1+N2-1$</li><li>对于长度为L点的x序列和y序列分别计算FFT得到X(k)和Y(k)序列</li><li>对Y(k)序列共轭得到$Y^*(k)$序列</li><li>计算$R_{xy}(k)&#x3D;X(k)Y^*(k)$</li><li>对$R_{xy}(k)$进行IFFT得到长度为L的$r_{xy}(m)$序列</li><li>计算阈值，判断相关，结束</li></ol><h1 id="matlab的实现代码-简易实现"><a href="#matlab的实现代码-简易实现" class="headerlink" title="matlab的实现代码(简易实现)"></a>matlab的实现代码(简易实现)</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>];<span class="comment">%待检测的输入序列</span></span><br><span class="line">y=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>];<span class="comment">%匹配特征序列</span></span><br><span class="line">X=fft(x,<span class="number">10</span>);<span class="comment">%做10点的fft计算，注意点数要求满足大于等于N1+N2-1</span></span><br><span class="line">Y=fft(y,<span class="number">10</span>);<span class="comment">%做10点的fft计算，注意点数要求满足大于等于N1+N2-1</span></span><br><span class="line">Y1=<span class="built_in">conj</span>(Y);<span class="comment">%对Y取共轭,频域都是复数</span></span><br><span class="line">R=X.*Y1;<span class="comment">%频域乘积运算</span></span><br><span class="line">r=ifft(R,<span class="number">10</span>)<span class="comment">%转换到时域输出相关函数</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r =</span><br><span class="line"></span><br><span class="line">   <span class="number">55.0000</span>   <span class="number">40.0000</span>   <span class="number">26.0000</span>   <span class="number">14.0000</span>    <span class="number">5.0000</span>    <span class="number">0.0000</span>    <span class="number">5.0000</span>   <span class="number">14.0000</span>   <span class="number">26.0000</span>   <span class="number">40.0000</span></span><br></pre></td></tr></table></figure><p>可以看到不同的相位情况下相关性不同，相差的值非常大，如果序列更长那么相关性会更好。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;利用相关函数进行元素识别的一个实验性观点&quot;&gt;&lt;a href=&quot;#利用相关函数进行元素识别的一个实验性观点&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="数字信号处理" scheme="https://blog.zzshub.cn/tags/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>废旧小主机改造路由器</title>
    <link href="https://blog.zzshub.cn/2019/01/16/MatherBoardRouter/"/>
    <id>https://blog.zzshub.cn/2019/01/16/MatherBoardRouter/</id>
    <published>2019-01-16T15:41:34.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="废旧小主机改造路由器-廉价的家用NAS解决方案"><a href="#废旧小主机改造路由器-廉价的家用NAS解决方案" class="headerlink" title="废旧小主机改造路由器,廉价的家用NAS解决方案"></a>废旧小主机改造路由器,廉价的家用NAS解决方案</h1><blockquote><p>好久没有写博客了，看了看上一篇还是去年9月份的事情。大三了学习压力好大，没什么时间研究技术方面的东西了。下学期还要开始考研，哎更没时间，估计博客又要好久不能更新了。</p></blockquote><p>最近喜欢上了逛闲鱼捡垃圾，捡到了一台110元的废旧小主机。电子垃圾真便宜，还真是三千预算进图吧，学校对面开网吧啊。一直想给之前用的路由器加些功能，可无奈毕竟是路由器算力跟不上，硬件供电也不行，还把我硬盘给搞坏了。把这次捡的这小主机改造成路由器岂不是美滋滋。改造，开干！<br>关于改造过程，因为篇幅有限，这篇博客只谈软件改造部分，关于硬件部分其实也没什么好说的，就是着重处理了一下散热，然后因为需要wifi就买了一块7260AC无线网卡插上，另外弄了两根6dB天线装上。<br>主机配置如下:</p><p>Intel Atom n270处理器(32位)<br>1GB DDR2L 内存<br>32GB 固态<br>Intel 7260AC双频无线网卡<br>4个USB2.0接口<br>一个百兆以太网口<br>另有SATA接口，IDE接口，串口，mini-PCIe，USB扩展排针等等一系列接口，看中这个主板也是因为接口比较丰富。</p><h1 id="装系统"><a href="#装系统" class="headerlink" title="装系统"></a>装系统</h1><p>关于系统，我最终选择了<code>Ubuntu 16.04.5 LTS Server</code>这个版本，然后自己安装了<strong>lxde</strong>桌面。几方面的原因，主要是主机算力还是不太够，不能支撑复杂的图形界面，只能用<strong>lxde</strong>这样的轻量化桌面才能运行，自己装桌面而没直接装<strong>lubuntu</strong>是因为它还是附带了很多不必要的组件，不够纯粹。安装过程跳过，注意下网卡的选择，有多张网卡时选择接入外网的网卡，对我来说就是接入校园网的网卡。另外可能需要设置网卡的IP，因为我校校园网是动态分配的IP，所以选择DHCP即可。安装完成后设置root密码<code>sudo passwd root</code>,给系统换软件源<code>vi /etc/apt/source.list </code>,以下是我更换的中国官方源，我个人还是喜欢用官方源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb cdrom:[Ubuntu 16.04.5 LTS _Xenial Xerus_ - Release i386 (20180731)]/ xenial main restricted</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See http://help.ubuntu.com/community/UpgradeNotes <span class="keyword">for</span> how to upgrade to</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">newer versions of the distribution.</span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Major bug fix updates produced after the final release of the</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># distribution.</span></span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-updates main restricted</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-updates main restricted</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># team. Also, please note that software in universe WILL NOT receive any</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># review or updates from the Ubuntu security team.</span></span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial universe</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial universe</span></span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-updates universe</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-updates universe</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># team, and may not be under a free licence. Please satisfy yourself as to</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># your rights to use the software. Also, please note that software in</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># multiverse WILL NOT receive any review or updates from the Ubuntu</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># security team.</span></span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial multiverse</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial multiverse</span></span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-updates multiverse</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-updates multiverse</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># N.B. software from this repository may not have been tested as</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># extensively as that contained in the main release, although it includes</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># newer versions of some applications which may provide useful features.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Also, please note that software in backports WILL NOT receive any review</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># or updates from the Ubuntu security team.</span></span></span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-backports main restricted universe multiverse</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Uncomment the following two lines to add software from Canonical&#x27;s</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># &#x27;partner&#x27; repository.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># This software is not part of Ubuntu, but is offered by Canonical and the</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># respective vendors as a service to Ubuntu users.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># deb http://archive.canonical.com/ubuntu xenial partner</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># deb-src http://archive.canonical.com/ubuntu xenial partner</span></span></span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu xenial-security main restricted</span><br></pre></td></tr></table></figure><p>之后执行<code>sudo apt-get update</code>更新缓存，<code>sudo apt-get upgrade</code></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/SharedScreenshot.jpg"></p><p>更新软件。好了到目前为止，一个命令行版本的ubuntu安装完成了。</p><h1 id="配置SSH，实现远程命令行控制主机"><a href="#配置SSH，实现远程命令行控制主机" class="headerlink" title="配置SSH，实现远程命令行控制主机"></a>配置SSH，实现远程命令行控制主机</h1><p>既然做服务器，肯定需要有远程控制主机的能力。</p><h2 id="安装ssh服务组件"><a href="#安装ssh服务组件" class="headerlink" title="安装ssh服务组件"></a>安装ssh服务组件</h2><p>执行<code>sudo apt-get install openssh-server</code>即可安装，安装完成后输入<code>service ssh status</code>查看ssh服务运行状态，服务没启动输入<code>service ssh start</code>来启动<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/%E6%89%B9%E6%B3%A8%202019-01-16%20133248.jpg"></p><h2 id="安装完成后配置，允许root用户远程登录"><a href="#安装完成后配置，允许root用户远程登录" class="headerlink" title="安装完成后配置，允许root用户远程登录"></a>安装完成后配置，允许root用户远程登录</h2><p>这部分可有可无，ssh协议为了安全，默认是禁止root超级管理员账户远程登录的，但是linux下很多操作需要使用到root权限，如果不用root登录就需要频繁的使用sudo命令，比较麻烦。</p><p>sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</p><p>把<code>PermitRootLogin no</code>修改为<code>PermitRootLogin yes</code></p><p>重启服务<code>sudo service ssh restart</code></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/%E6%89%B9%E6%B3%A8%202019-01-16%20133837.jpg"></p><h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><p>在开始之前需要确认好主机的ip和端口号(目前没讲到域名的问题所以需要确认好ip)。ssh协议默认使用22端口，ip输入<code>ifconfig</code>查看本机ip<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/%E6%89%B9%E6%B3%A8%202019-01-16%20134434.jpg"><br>可以看到本机ip为<strong>192.168.3.212</strong>。</p><p><strong>在Windows下使用putty访问</strong>，如图，输入ip，端口，用户名，密码，Go！！！开始你的远程控制小主机之旅吧。</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/%7BB31A6894-D382-4E39-8608-DD67D0978E62%7D.png.jpg"></p><p><strong>Windows10也可以使用WSL(windows subsystem for linux)来访问，参见<a href="https://zzzzzzs.github.io/2017/11/21/hiwifiRightWay/">hiwifi的正确打开方式</a></strong></p><h1 id="配置网络，实现路由器功能"><a href="#配置网络，实现路由器功能" class="headerlink" title="配置网络，实现路由器功能"></a>配置网络，实现路由器功能</h1><blockquote><p>说了这么多，这一部分才是本文的核心内容。</p></blockquote><p>这个小主机主要实现了一个有线局域网和一个无线局域网桥接连接到外网的功能。主要的思路是用</p><h1 id="配置网络打印机服务，实现局域网内打印"><a href="#配置网络打印机服务，实现局域网内打印" class="headerlink" title="配置网络打印机服务，实现局域网内打印"></a>配置网络打印机服务，实现局域网内打印</h1><p>说到Linux下的网络打印，<del>我就想起明年年初，中美合拍的西游记即将正式开机，我继续扮演美猴王孙悟空，我会用美猴王艺术形象努力创造一个正能量的形象，文体两开花，弘扬中华文化，希望大家能多多关注。</del> 就必须要提到<a href="https://www.cups.org/"><strong>CUPS</strong></a>。官方介绍如下：</p><blockquote><p>CUPS is the standards-based, open source printing system developed by Apple Inc. for macOS® and other UNIX®-like operating systems. CUPS uses the Internet Printing Protocol (IPP) to support printing to local and network printers.</p></blockquote><p>一开始做打印机服务的本想着应该先找驱动实现本地打印再想办法把打印机共享出去。结果发现了这么个好东西，把打印机驱动和打印机服务器直接做到一起了，免去了配置远程打印的过程。事实上，Linux下本机的打印也是通过本地回环localhost 127.0.0.1访问本地服务器，来实现的。这么一来，本机打印和局域网内打印的原理上都是一样的了。这个打印机服务使用通用协议IPP(Internet Printing Protocol)协议来与局域网内设备(包括小主机)通信，这样一来其他电脑&#x2F;手机也不用装驱动了，直接添加打印机打印就好。CUPS的另一方面就是能自动的从网上获取打印机的驱动安装到小主机上，这样也能免去找驱动的过程。</p><h2 id="安装CUPS"><a href="#安装CUPS" class="headerlink" title="安装CUPS"></a>安装CUPS</h2><p>一般Linux安装完成的时候都默认带了CUPS的，但是如果没有安装就需要我们手动安装了。执行以下命令 <code>sudo apt-get install CUPS</code>即可安装完成<br>执行<code>sudo service cups start</code>来启动服务<br>完成后用浏览器访问<a href="http://localhost:631/admin">http://localhost:631/admin</a>,如果出现界面了就证明安装成功。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/%7B2C197BE2-E904-49B3-BF66-F584685A77DB%7D.png.jpg"></p><h2 id="添加打印机"><a href="#添加打印机" class="headerlink" title="添加打印机"></a>添加打印机</h2><blockquote><p>关于添加打印机，网上有很多教程都是基于图形化桌面的，我想讲的是如何在CUPS提供的网页里设置打印机。</p></blockquote><p>如下图所示，在<strong>Administration</strong>选项卡选择<code>add printer</code><br><strong>注意：有对话框弹出来要求输入root用户名密码，如果没有弹出就换个浏览器试试，我的Chrome浏览器就无法弹出导致一直卡在那里，而edge就能输入</strong><br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/a.png.jpg"></p><p>如下图所示，进入后可看到打印机已经被发现，选中即可。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/b.jpg"></p><p>如下图所示，下一步确定打印机名称，位置啥的，这个随意填写就好，注意勾选共享打印机。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/c.jpg"></p><p>如下图所示，选择驱动，它一般默认推荐的驱动就能够使用，可以配置完成后打印一张测试页看看正不正常。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/d.jpg"></p><p>如下图所示，一些乱七八糟的打印参数，看着慢慢改吧，之前我的打印机老是卡纸，就是改了很多参数才慢慢正常的。<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/e.jpg"></p><p>选择默认设置，好了打印机设置完成！接下来就可以在<code>Printer</code>选项中管理打印机，查看打印队列或者打印测试页了。</p><h2 id="配置打印机共享和通过域名访问打印机"><a href="#配置打印机共享和通过域名访问打印机" class="headerlink" title="配置打印机共享和通过域名访问打印机"></a>配置打印机共享和通过域名访问打印机</h2><p>勾选如下所示的选项即可<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/f.jpg"></p><blockquote><p>域名的设置就有点麻烦了，估计也是为了安全，CUPS默认禁止使用域名的方式远程或者本地连接到打印机，初衷是好，但是对于使用动态ip的人来说就很不友好了。我研究了很久很久才搞出来，所以单独列出来。</p></blockquote><p>修改&#x2F;etc&#x2F;cups&#x2F;cupsd.conf文件<code>sudo vi  /etc/cups/cupsd.conf</code>，添加<code>ServerAlias *</code>即可。如下图所示<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/i.jpg"></p><h2 id="电脑和手机远程打印"><a href="#电脑和手机远程打印" class="headerlink" title="电脑和手机远程打印"></a>电脑和手机远程打印</h2><p>好了，到现在打印机共享就设置完成了，在Windows下添加网络打印机就好。<strong>打开设置-&gt;设备-&gt;打印机和扫描仪-&gt;添加打印机和扫描仪-&gt;我需要的打印机不在列表中，就会打开以下界面</strong><br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/g.jpg"></p><p>共享的打印机地址如图所示<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/MatherBoardRouter/h.jpg"></p><p>因为CUPS是Apple提供的，所以在iPhone上的设置就尤其的方便，直接在手机里点击打印，然后选择打印机就好了，无需任何设置</p><hr><h1 id="未完待续。。。。。。"><a href="#未完待续。。。。。。" class="headerlink" title="未完待续。。。。。。"></a>未完待续。。。。。。</h1>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;废旧小主机改造路由器-廉价的家用NAS解决方案&quot;&gt;&lt;a href=&quot;#废旧小主机改造路由器-廉价的家用NAS解决方案&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="Linux" scheme="https://blog.zzshub.cn/tags/Linux/"/>
    
    <category term="作品" scheme="https://blog.zzshub.cn/tags/%E4%BD%9C%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages开启全站https连接</title>
    <link href="https://blog.zzshub.cn/2018/09/17/fullhttps/"/>
    <id>https://blog.zzshub.cn/2018/09/17/fullhttps/</id>
    <published>2018-09-16T16:00:00.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好久没更新博客了,最近想写博客时发现travis-CI自动部署系统用不了了,本地也用不了了,问题还不一样.弄了小半个下午才弄好.应该是某个插件更新了导致的一些错误,再加上本地的python版本有问题,导致都没法用还显示错误不一样.别人的博客框架确实好用,但是除了问题震荡还是有点麻烦的.whatever,修好了就好了.</p></blockquote><h1 id="GitHub-Pages开启全站https安全连接"><a href="#GitHub-Pages开启全站https安全连接" class="headerlink" title="GitHub Pages开启全站https安全连接"></a>GitHub Pages开启全站https安全连接</h1><p>最近Chrome69版本发布修改了https的显示方式,于是我又了解了一下https,意识到我的博客还是用的http连接非常不安全怎么办啊,于是在最近全部升级成了https连接(其实就是强迫症犯了觉得那个小锁很好看也想要一个).</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%85%A8%E7%AB%99https/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p><blockquote><p>升级成https后的显示效果</p></blockquote><h1 id="开启GitHub-Pages强制https"><a href="#开启GitHub-Pages强制https" class="headerlink" title="开启GitHub Pages强制https"></a>开启GitHub Pages强制https</h1><p>全站https访问需要禁止http访问才有意义,这一步很简单,直接在项目的设置界面中的GitHub Pages那里打勾就好</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%85%A8%E7%AB%99https/%E8%8D%89%E5%9B%BE.png"></p><blockquote><p>貌似以前自定义域名开启https还很麻烦,<strong>但是</strong>现在GitHub升级了,一切都变得容易了起来.</p></blockquote><h1 id="全部资源使用https"><a href="#全部资源使用https" class="headerlink" title="全部资源使用https"></a>全部资源使用https</h1><p>完成上一步后打开网站发现使用https连接但是还是没有小绿锁.因为很多资源比如图片还是使用http连接加载的所以不能不能认为是安全的网站所以没有小锁.要实现有小锁就必须全部资源使用https连接才行.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%85%A8%E7%AB%99https/%E8%8D%89%E5%9B%BE2.png"></p><p>将全部图床图片等其他外链全部设置成https后小锁就出现了.</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实安全证书还有很多级别,仔细观察发现我的小锁图标和<a href="https://github.com/">GitHub</a>还是有区别的,GitHub采用的拓展的安全证书,更加安全.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;好久没更新博客了,最近想写博客时发现travis-CI自动部署系统用不了了,本地也用不了了,问题还不一样.弄了小半个下午才弄好.应该是某个插件更新了导致的一些错误,再加上本地的python版本有问题,导致都没法用还显示错误不一样.别人的博客框架确实</summary>
        
      
    
    
    
    
    <category term="github" scheme="https://blog.zzshub.cn/tags/github/"/>
    
    <category term="blog" scheme="https://blog.zzshub.cn/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>MCS51单片机常用寄存器及汇编指令梳理</title>
    <link href="https://blog.zzshub.cn/2018/05/21/MCS51/"/>
    <id>https://blog.zzshub.cn/2018/05/21/MCS51/</id>
    <published>2018-05-21T15:20:00.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MCS51单片机寄存器简介"><a href="#MCS51单片机寄存器简介" class="headerlink" title="MCS51单片机寄存器简介"></a>MCS51单片机寄存器简介</h1><blockquote><p>最近马上要考试51单片机了,借着这个机会梳理了一下51单片机的各个寄存器以及我个人常弄混淆的一些东西.</p></blockquote><h1 id="管脚"><a href="#管脚" class="headerlink" title="管脚"></a>管脚</h1><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>PSEN</td><td>ROM选通信号</td></tr><tr><td>EA</td><td>&#x3D;0 只访问片外ROM</td></tr><tr><td>ALE</td><td>地址锁存器信号</td></tr><tr><td>RESET</td><td>2机器周期高电平复位</td></tr><tr><td>XTAL1</td><td>crystal oscillator</td></tr></tbody></table><p> 一共40脚 32个IO 注意P1可以驱动4个LSTTL,其他为8个</p><h2 id="P3口第二功能"><a href="#P3口第二功能" class="headerlink" title="P3口第二功能"></a>P3口第二功能</h2><table><thead><tr><th>管脚</th><th>功能</th></tr></thead><tbody><tr><td>P3.0</td><td>RXD</td></tr><tr><td>P3.1</td><td>TXD</td></tr><tr><td>P3.2</td><td>INT0</td></tr><tr><td>P3.3</td><td>INT1</td></tr><tr><td>P3.4</td><td>T0</td></tr><tr><td>P3.5</td><td>T1</td></tr><tr><td>P3.6</td><td>WR</td></tr><tr><td>P3.7</td><td>RD</td></tr></tbody></table><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><table><thead><tr><th>地址</th><th>说明</th></tr></thead><tbody><tr><td>00H~07H</td><td>第0工作区</td></tr><tr><td>08H~0FH</td><td>第1工作区</td></tr><tr><td>……</td><td>…….</td></tr><tr><td>20H~2FH</td><td>可位寻址区</td></tr><tr><td>30H~7FH</td><td>用户RAM区</td></tr><tr><td>80H~FFH</td><td>SFR</td></tr></tbody></table><p>上电建议将SP改成60H避免冲突</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>内存中对应的位地址为 00H~7FH</li></ul><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p> 注意 SP复位值为07H(越过第0工作组寄存器区),IO复位是FFH,其他的都是0</p><h3 id="PCON-电源控制寄存器-不可位寻址"><a href="#PCON-电源控制寄存器-不可位寻址" class="headerlink" title="PCON 电源控制寄存器 (不可位寻址)"></a>PCON 电源控制寄存器 (不可位寻址)</h3><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>D0</td><td>IDL</td><td>空闲模式</td></tr><tr><td>D1</td><td>PD</td><td>掉电模式</td></tr><tr><td>D2</td><td>GF0</td><td>用户标志位</td></tr><tr><td>D3</td><td>GF1</td><td>用户标志位</td></tr><tr><td>D7</td><td>SMOD</td><td>波特率倍频</td></tr></tbody></table><h3 id="TCON-定时器控制寄存器-中断"><a href="#TCON-定时器控制寄存器-中断" class="headerlink" title="TCON 定时器控制寄存器&#x2F;中断"></a>TCON 定时器控制寄存器&#x2F;中断</h3><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>D0</td><td>IT0</td><td>外部中断0触发方式&#x3D;0电平触发</td></tr><tr><td>D1</td><td>IE0</td><td>外部中断0标志位,自动清0</td></tr><tr><td>D2</td><td>IT1</td><td></td></tr><tr><td>D3</td><td>IE1</td><td></td></tr><tr><td>D4</td><td>TR0</td><td>定时器计数允许位</td></tr><tr><td>D5</td><td>TF0</td><td>定时器溢出标志位,中断自动清0</td></tr><tr><td>D6</td><td>TR1</td><td></td></tr><tr><td>D7</td><td>TF1</td><td></td></tr></tbody></table><h3 id="TMOD-定时器工作方式寄存器-不可位寻址"><a href="#TMOD-定时器工作方式寄存器-不可位寻址" class="headerlink" title="TMOD 定时器工作方式寄存器 (不可位寻址)"></a>TMOD 定时器工作方式寄存器 (不可位寻址)</h3><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>D0</td><td>M0</td><td>工作方式选择</td></tr><tr><td>D1</td><td>M1</td><td>工作方式选择</td></tr><tr><td>D2</td><td>C&#x2F;$\overline{T}$</td><td>工作模式&#x3D;0定时器模式</td></tr><tr><td>D3</td><td>GATE</td><td>门控&#x3D;0 仅由$TR_x$控制</td></tr><tr><td>D4~D7</td><td>……</td><td>功能同上</td></tr></tbody></table><h3 id="AUXR-辅助寄存器-不可位寻址"><a href="#AUXR-辅助寄存器-不可位寻址" class="headerlink" title="AUXR 辅助寄存器(不可位寻址)"></a>AUXR 辅助寄存器(不可位寻址)</h3><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>D0</td><td>DISABLE</td><td>ALE脉冲寄存器 &#x3D;0 时刻发出脉冲</td></tr><tr><td>D3</td><td>DISTRO</td><td>看门狗 &#x3D;0开启看门狗</td></tr><tr><td>D4</td><td>WDILE</td><td>空闲看门狗 &#x3D;0 允许看门狗空闲计数</td></tr></tbody></table><h3 id="SCON-串口寄存器"><a href="#SCON-串口寄存器" class="headerlink" title="SCON 串口寄存器"></a>SCON 串口寄存器</h3><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>D0</td><td>RI</td><td>接收中断标志位</td></tr><tr><td>D1</td><td>TI</td><td>发送中断标志位</td></tr><tr><td>D2</td><td>RB8</td><td>接收的第9位</td></tr><tr><td>D3</td><td>TB8</td><td>发送的第9位</td></tr><tr><td>D4</td><td>REN</td><td>允许串口接收</td></tr><tr><td>D5</td><td>SM2</td><td>多机通信控制&#x3D;1,RB8&#x3D;1才中断请求</td></tr><tr><td>D6&#x2F;D7</td><td>SM1&#x2F;SM0</td><td>工作方式选择</td></tr></tbody></table><h3 id="AUXR1-辅助寄存器1-不可位寻址"><a href="#AUXR1-辅助寄存器1-不可位寻址" class="headerlink" title="AUXR1 辅助寄存器1(不可位寻址)"></a>AUXR1 辅助寄存器1(不可位寻址)</h3><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>D0</td><td>DPS</td><td>选择DPTR</td></tr></tbody></table><h3 id="IE-interrupt-enable-中断允许寄存器"><a href="#IE-interrupt-enable-中断允许寄存器" class="headerlink" title="IE (interrupt enable)中断允许寄存器"></a>IE (interrupt enable)中断允许寄存器</h3><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>D0</td><td>EX0</td><td>外部中断0允许位</td></tr><tr><td>D1</td><td>ET0</td><td>定时器0中断允许位</td></tr><tr><td>D2</td><td>EX1</td><td></td></tr><tr><td>D3</td><td>ET1</td><td></td></tr><tr><td>D4</td><td>ES</td><td>串口中断允许位</td></tr><tr><td>D5</td><td>ET2</td><td></td></tr><tr><td>D7</td><td>EA</td><td>全局中断允许位</td></tr></tbody></table><h3 id="IP-interrupt-priority-中断优先级寄存器"><a href="#IP-interrupt-priority-中断优先级寄存器" class="headerlink" title="IP (interrupt priority)中断优先级寄存器"></a>IP (interrupt priority)中断优先级寄存器</h3><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>D0</td><td>PX0</td><td></td></tr><tr><td>D1</td><td>PT0</td><td></td></tr><tr><td>D2</td><td>PX1</td><td></td></tr><tr><td>D3</td><td>PT1</td><td></td></tr><tr><td>D4</td><td>PS</td><td></td></tr><tr><td>D5</td><td>PT2</td><td></td></tr></tbody></table><h3 id="PSW-程序状态字寄存器"><a href="#PSW-程序状态字寄存器" class="headerlink" title="PSW 程序状态字寄存器"></a>PSW 程序状态字寄存器</h3><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>D0</td><td>P</td><td>Acc奇偶校验,偶为0</td></tr><tr><td>D2</td><td>OV</td><td>溢出标志位</td></tr><tr><td>D3&#x2F;D4</td><td>RS0&#x2F;RS1</td><td>工作组选择寄存器</td></tr><tr><td>D5</td><td>F0</td><td>用户标志位</td></tr><tr><td>D6</td><td>Ac</td><td>辅助进位标志位</td></tr><tr><td>D7</td><td>Cy或C</td><td>进位标志位或位累加器</td></tr></tbody></table><h1 id="低功耗"><a href="#低功耗" class="headerlink" title="低功耗"></a>低功耗</h1><p><strong>空闲模式</strong>:仅CPU停机,其他工作正常,WatchDog可以计数,可由中断退出<br><strong>掉电模式</strong>:振荡器停机,内存中值保留,Vcc可以下降到2V,WatchDog停止计数,外部中断唤醒</p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><ul><li>寄存器寻址(R0~R7 A B C DPTR)</li><li>直接寻址</li><li>寄存器间接寻址</li><li>基址+变址间接寻址</li><li>立即数寻址</li><li>相对寻址</li><li>位寻址</li></ul><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>以字母开头的数字量需要添加前导0</li><li>只有R0 R1能间接寻址</li><li>读引脚-&gt;读修改写</li><li>$符号表示跳转到标号</li></ul><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>MOVC</td><td>查表指令</td></tr><tr><td>MOVX</td><td>读取外部RAM</td></tr><tr><td>XCH</td><td>字节交换指令</td></tr><tr><td>XCHD</td><td>半字节交换指令</td></tr><tr><td>ADDC</td><td>带进位的加法指令</td></tr><tr><td>DA</td><td>十进制调整指令</td></tr><tr><td>SUBB</td><td>带借位的减法指令</td></tr><tr><td>MUL</td><td>乘法指令(高字节在B 低字节在A,乘积大于255,OV置1)</td></tr><tr><td>DIV</td><td>除法指令(A&#x2F;B&#x3D;A(商)……B(余数)),除数为0,OV置1</td></tr><tr><td>SWAP</td><td>A累加器半字节交换指令</td></tr><tr><td>LJMP</td><td>长跳转指令</td></tr><tr><td>SJMP</td><td>相对跳转(地址+偏移量+2)</td></tr><tr><td>JMP</td><td>间接跳转指令@A+DPTR,用于分支选择</td></tr><tr><td>DJNZ</td><td>减一不为零指令</td></tr><tr><td>LCALL</td><td>调用子程序指令,<strong>先低字节后高字节</strong></td></tr><tr><td>RET</td><td>子程序返回指令</td></tr><tr><td>RETI</td><td>中断子程序返回指令,清除了内部中断相关寄存器的状态</td></tr><tr><td>CLR</td><td>清零</td></tr><tr><td>ANL</td><td>逻辑与</td></tr><tr><td>ORL</td><td>逻辑或</td></tr><tr><td>XRL</td><td>逻辑异或</td></tr><tr><td>JZ</td><td>累加器为0跳转</td></tr><tr><td>JNZ</td><td>累加器不为0跳转</td></tr><tr><td>CJNE</td><td>比较不相等跳转</td></tr></tbody></table><table><thead><tr><th>位指令</th><th>说明</th></tr></thead><tbody><tr><td>SETB</td><td>置位</td></tr><tr><td>CLR</td><td>清零</td></tr><tr><td>CPL</td><td>取反</td></tr><tr><td>ANL</td><td>与</td></tr><tr><td>ORL</td><td>或</td></tr><tr><td>JC</td><td>C为1跳转</td></tr><tr><td>JNC</td><td>C为0跳转</td></tr></tbody></table><h2 id="汇编伪指令"><a href="#汇编伪指令" class="headerlink" title="汇编伪指令"></a>汇编伪指令</h2><table><thead><tr><th>伪指令</th><th>说明</th></tr></thead><tbody><tr><td>ORG</td><td>标记开始</td></tr><tr><td>END</td><td>结束汇编</td></tr><tr><td>EQU</td><td>相当于宏定义</td></tr><tr><td>DB</td><td>Define Byte</td></tr><tr><td>DW</td><td>Define Word</td></tr><tr><td>SDA</td><td>Define Bit</td></tr><tr><td>DS</td><td>Define Storage</td></tr></tbody></table><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>串口中断TI和RI需要软件清除</li><li>中断最小相应3周期 查询1+跳转2</li><li>中断最长相应8周期 RETI2+DIV4+跳转2</li><li>中断在压栈和出栈的时候需要现场保护关闭中断</li></ul><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>定时器工作方式0 TL5位 TH8位</li><li>计数器最大频率为晶振频率的1&#x2F;24,12MHz的最大为500KHz</li></ul><h2 id="初值计算"><a href="#初值计算" class="headerlink" title="初值计算"></a>初值计算</h2><h3 id="16位"><a href="#16位" class="headerlink" title="16位"></a>16位</h3><p>($2^{16}-x$)x(1&#x2F;主频)&#x3D;期望的时间</p><h3 id="计时时长"><a href="#计时时长" class="headerlink" title="计时时长"></a>计时时长</h3><p>以6MHz的晶振</p><ul><li>方式0:16.384ms</li><li>方式1: 131.072ms</li><li>方式2: 512$\mu$s</li></ul><h1 id="串口UART"><a href="#串口UART" class="headerlink" title="串口UART"></a>串口UART</h1><h2 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>方式0时RXD&#x3D;数据线 TXD&#x3D;时钟线</li><li>方式1接收一位采样3次</li></ul><h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><h3 id="方式1或3波特率"><a href="#方式1或3波特率" class="headerlink" title="方式1或3波特率"></a>方式1或3波特率</h3><p>bandrate&#x3D;$(2^{SMOD}&#x2F;32)\times$定时器T1的溢出速率<br>bandrate&#x3D;$(2^{SMOD}&#x2F;32)\times(f_{osc}&#x2F;12)&#x2F;(256-x)$ 8位自动重装</p><h3 id="方式0-2波特率"><a href="#方式0-2波特率" class="headerlink" title="方式0&#x2F;2波特率"></a>方式0&#x2F;2波特率</h3><p>bandrate&#x3D;$(2^{SMOD}&#x2F;64)\times f_{osc}$</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;MCS51单片机寄存器简介&quot;&gt;&lt;a href=&quot;#MCS51单片机寄存器简介&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="register" scheme="https://blog.zzshub.cn/tags/register/"/>
    
    <category term="MCS51" scheme="https://blog.zzshub.cn/tags/MCS51/"/>
    
  </entry>
  
  <entry>
    <title>kinetis KV58 DAC模块食用指南</title>
    <link href="https://blog.zzshub.cn/2018/05/19/DAC/"/>
    <id>https://blog.zzshub.cn/2018/05/19/DAC/</id>
    <published>2018-05-19T15:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kinetis-KV58-DAC模块食用指南"><a href="#kinetis-KV58-DAC模块食用指南" class="headerlink" title="kinetis KV58 DAC模块食用指南"></a>kinetis KV58 DAC模块食用指南</h1><blockquote><p>本文主要以KV58为例介绍kinetis系列微控制器的DAC模块的寄存器以及配置方法.</p></blockquote><h1 id="Kinetis-KV5x系列DAC特性简介"><a href="#Kinetis-KV5x系列DAC特性简介" class="headerlink" title="Kinetis KV5x系列DAC特性简介"></a>Kinetis KV5x系列DAC特性简介</h1><p>DAC全称Digital Analog Convertor 数模转换器,用于输出模拟信号.kinetis的DAC模块拥有以下特点:</p><ul><li>12bit输出</li><li>16深度支持DMA的FIFO缓冲器</li><li>DAC可作为外部管脚输出或者内部ADC的比较电压</li><li>4096级输出</li><li>双参考电压</li><li>停止模式可维持输出电压</li><li>支持DMA</li><li>可由PDB0 PDB1 XBARA_OUT15硬件触发转换</li></ul><h1 id="Kinetis-KV5x系列DAC结构图"><a href="#Kinetis-KV5x系列DAC结构图" class="headerlink" title="Kinetis KV5x系列DAC结构图"></a>Kinetis KV5x系列DAC结构图</h1><p>(摘自<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">KV5x Sub-Family Reference Manual Page 1075</a>)</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DAC/%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p><p>可以看出DAC的结构还是相对简单的.总体来说DAC有一个16深度的缓冲区可以配置成不同的模式(Ring Buffer,FIFO等)有一个转换指针*<em>Buffer Read Point</em>,该指针指向的数据就会由DAC输出.不论由硬件还是软件触发DAC转换的本质是移动这个指针使它指向不同的数据来输出不同的电压值,DAC输出的过程其实是静态的,并不是说仅仅在触发的那一瞬间输出,之后就不输出了.</p><h1 id="Kinetis-KV5x系列DAC寄存器列表"><a href="#Kinetis-KV5x系列DAC寄存器列表" class="headerlink" title="Kinetis KV5x系列DAC寄存器列表"></a>Kinetis KV5x系列DAC寄存器列表</h1><p>以下摘自官方定义头文件<strong>MKV58F24.h</strong>第3770~第3789行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   -- DAC Peripheral Access Layer</span></span><br><span class="line"><span class="comment">   ---------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup DAC_Peripheral_Access_Layer DAC Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** DAC - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span>                                         <span class="comment">/* offset: 0x0, array step: 0x2 */</span></span><br><span class="line">    __IO <span class="type">uint8_t</span> DATL;                               <span class="comment">/**&lt; DAC Data Low Register, array offset: 0x0, array step: 0x2 */</span></span><br><span class="line">    __IO <span class="type">uint8_t</span> DATH;                               <span class="comment">/**&lt; DAC Data High Register, array offset: 0x1, array step: 0x2 */</span></span><br><span class="line">  &#125; DAT[<span class="number">16</span>];</span><br><span class="line">  __IO <span class="type">uint8_t</span> SR;                                 <span class="comment">/**&lt; DAC Status Register, offset: 0x20 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> C0;                                 <span class="comment">/**&lt; DAC Control Register, offset: 0x21 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> C1;                                 <span class="comment">/**&lt; DAC Control Register 1, offset: 0x22 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> C2;                                 <span class="comment">/**&lt; DAC Control Register 2, offset: 0x23 */</span></span><br><span class="line">&#125; DAC_Type;</span><br></pre></td></tr></table></figure><p>简单说明一下,开头的结构体是FIFO缓冲区,12bit的数据分高4位和低8位存在两个不同的寄存器中.之后的SR寄存器主要标记DAC的状态.C0 C1 C2 寄存器主要控制DAC模块.</p><h1 id="Kinetis-KV5x系列DAC寄存器介绍"><a href="#Kinetis-KV5x系列DAC寄存器介绍" class="headerlink" title="Kinetis KV5x系列DAC寄存器介绍"></a>Kinetis KV5x系列DAC寄存器介绍</h1><h2 id="DAC-Data-Low-Register-DAC-Data-High-Registe"><a href="#DAC-Data-Low-Register-DAC-Data-High-Registe" class="headerlink" title="DAC Data Low Register &amp; DAC Data High Registe"></a>DAC Data Low Register &amp; DAC Data High Registe</h2><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DAC/FIFO.png"></p><p>如图所示低8位储存低8位数据,高4位储存高4位数据,最高4位写无效读为0.值得注意的是,当FIFO关闭时,第0位数据为DAC即将转换的数据,当FIFO打开时,由C2寄存器中<strong>Buffer ReadPoint</strong>指针指向的数据为即将转换的数据.</p><h2 id="DAC-Status-Register"><a href="#DAC-Status-Register" class="headerlink" title="DAC Status Register"></a>DAC Status Register</h2><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DAC/SR.png"></p><p>DAC状态寄存器,标记的状态如图所示,分别为:</p><ul><li>缓冲区不满</li><li>缓冲区满</li><li>缓冲区为空</li></ul><p>值得注意的是,这些寄存器表征DAC缓冲区的状态,是不需要我们进行写操作的,当状态发生变化时会自动由硬件清零或置1.</p><h2 id="DAC-Control-Register"><a href="#DAC-Control-Register" class="headerlink" title="DAC Control Register"></a>DAC Control Register</h2><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DAC/c0.png"></p><p>仅介绍部分我觉得难以理解的寄存器</p><table><thead><tr><th>寄存器名</th><th>说明</th></tr></thead><tbody><tr><td>DACTRGSEL</td><td>选择硬件或者软件触发方式</td></tr><tr><td>DACSWTRG</td><td>软件触发时向该位写1会触发一次转换,实质是向前移动指针一格</td></tr></tbody></table><h2 id="DAC-Control-Register-1"><a href="#DAC-Control-Register-1" class="headerlink" title="DAC Control Register 1"></a>DAC Control Register 1</h2><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DAC/C1.png"></p><p>仅介绍部分我觉得难以理解的寄存器</p><table><thead><tr><th>寄存器名</th><th>说明</th></tr></thead><tbody><tr><td>DMAEN</td><td>当DMA打开时,DMA请求来源于中断,此时原本的中断不会发生</td></tr><tr><td>DACBFWM</td><td>决定FIFO中还有多少数据时SR中DACBFWMF位置1,产设能够一次watermark中断</td></tr><tr><td>DACBFMD</td><td>选择Buffer工作模式,参见下文详细解释</td></tr></tbody></table><h2 id="DAC-Control-Register-2"><a href="#DAC-Control-Register-2" class="headerlink" title="DAC Control Register 2"></a>DAC Control Register 2</h2><table><thead><tr><th>寄存器名</th><th>说明</th></tr></thead><tbody><tr><td>DACBFRP</td><td>指向当前准备转换的数据</td></tr><tr><td>DACBFUP</td><td>设置DAC buffer长度或者FIFO模式中写数据地址</td></tr></tbody></table><h1 id="Kinetis-KV5x系列DAC数据缓冲区状态"><a href="#Kinetis-KV5x系列DAC数据缓冲区状态" class="headerlink" title="Kinetis KV5x系列DAC数据缓冲区状态"></a>Kinetis KV5x系列DAC数据缓冲区状态</h1><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>Buffer Normal mode</td><td>默认模式,缓冲区作为环形缓冲区</td></tr><tr><td>Buffer Swing mode</td><td>当到达上限时逐渐递减到0之后再增加</td></tr><tr><td>Buffer One-time Scan mode</td><td>指针一次性增加到顶就停止不在更细直到重新置0</td></tr><tr><td>FIFO Mode</td><td>缓冲区配置成FIFO</td></tr></tbody></table><h3 id="关于FIFO模式的特别说明"><a href="#关于FIFO模式的特别说明" class="headerlink" title="关于FIFO模式的特别说明:"></a>关于FIFO模式的特别说明:</h3><p>FIFO模式内部使用32bit数据模式,所以写FIFO时建议也使用32bit长度写入,注意当以32bit模式写入时必须要保证<strong>DACBFUP</strong>指针指向的地址为偶数.以下是官方对此的说明节选(摘自<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">KV5x Sub-Family Reference Manual Page 1081~1083</a>):</p><blockquote><p><strong>DACBFUP</strong>:In FIFO mode it is the FIFO write pointer. User cannot set Buffer Up limit in FIFO mode. In Normal mode its reset value is MAX. When IP is configured to FIFO mode, this register becomes Write_Pointer, and its value is initially set to equal READ_POINTER automatically, and the FIFO status is empty. It is writable and user can configure it to the same address to reset FIFO as empty.<br></br> In FIFO mode, the buffer is organized as a FIFO. For a valid write to any DACDATx, the data is put into the FIFO, and the write pointer is automatically incremented. The module is connected internally to a 32bit interface. For any 16bit or 8bit FIFO access, address bit[1] needs to be 0; otherwise, the write is ignored. For any 32bit FIFO access, the Write_Pointer needs to be an EVEN number; otherwise, the write is ignored.<br></br><strong>NOTE</strong>: A successful 32bit FIFO write will increase the write pointer by 2. Any write will cause the FIFO over-flow will be ignored, the cases includes: 1.FIFO is full, the write will be ignored. 2.FIFO is nearly full (FIFO_SIZE-1), 32bit write will be ignored.<br></br><strong>NOTE</strong>: For 8bit write, address bit[0] determine which byte lane will be written to the FIFO according to little endian alignment. Only both byte lanes are written will the write pointer increase. User need to make sure 8bit access happened in pair and both upper &amp; lower bytes are written. There is no requirement on which byte write first. In FIFO mode, there is no change to read access of DACDATx (from normal mode), read to DACDATx will return the DATA addressed by the access address to the data buffer, and both write pointer and read pointer in FIFO mode will NOT be changed by read access. FIFO write can be happened when DAC is not enabled for 1st data conversion enable. But FIFO mode need to work at buffer Enabled at DACC1[DACBFEN]. In FIFO mode, the DATA BUF will be organized as FIFO.</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;kinetis-KV58-DAC模块食用指南&quot;&gt;&lt;a href=&quot;#kinetis-KV58-DAC模块食用指南&quot; class=&quot;headerlink&quot; title=&quot;kinetis KV58 DAC模块食用指南&quot;&gt;&lt;/a&gt;kinetis KV58</summary>
        
      
    
    
    
    
    <category term="ARM" scheme="https://blog.zzshub.cn/tags/ARM/"/>
    
    <category term="kinetis" scheme="https://blog.zzshub.cn/tags/kinetis/"/>
    
    <category term="register" scheme="https://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>翻译 BLE低功耗蓝牙协议简介</title>
    <link href="https://blog.zzshub.cn/2018/05/19/TranslateBLE/"/>
    <id>https://blog.zzshub.cn/2018/05/19/TranslateBLE/</id>
    <published>2018-05-19T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="原文连接-https-doc-qt-io-qt-5-qtbluetooth-le-overview-html"><a href="#原文连接-https-doc-qt-io-qt-5-qtbluetooth-le-overview-html" class="headerlink" title="原文连接 https://doc.qt.io/qt-5/qtbluetooth-le-overview.html"></a>原文连接 <a href="https://doc.qt.io/qt-5/qtbluetooth-le-overview.html">https://doc.qt.io/qt-5/qtbluetooth-le-overview.html</a></h3></blockquote><h1 id="BLE低功耗蓝牙简介"><a href="#BLE低功耗蓝牙简介" class="headerlink" title="BLE低功耗蓝牙简介"></a>BLE低功耗蓝牙简介</h1><h2 id="什么是低功耗蓝牙"><a href="#什么是低功耗蓝牙" class="headerlink" title="什么是低功耗蓝牙"></a>什么是低功耗蓝牙</h2><p>低功耗蓝牙又被称为智能蓝牙(Bluetooth Smart),是一个于2011年提出的无线网络技术.与经典蓝牙(“classic”Bluetooth)一样工作在2.4GHz.它的主要特点正如其名字一样,低能量消耗.它提供了一种仅仅用一颗纽扣电池就工作几月甚至几年的可能性.该项技术作为蓝牙4.0技术的子协议被叫做Bluetooth Smart Ready Devices.它的主要技术特点如下:</p><ul><li>极低峰值,平均值功耗</li><li>可以使用纽扣电池驱动数年时间</li><li>低功耗</li><li>多网络互联</li><li>距离增强</li></ul><p>低功耗蓝牙使用了一种客户端-服务端(client-server)结构.服务端(外围设备)提供服务,例如温度,心率等,并广播它们.客户端(中心设备)连接到服务端并读取被广播的数据.</p><h2 id="基本服务结构"><a href="#基本服务结构" class="headerlink" title="基本服务结构"></a>基本服务结构</h2><p>低功耗蓝牙BLE主要依靠两个协议:ATT(Attribute Protocol)以及GATT(Generic Attribute Protocol).它们是通信层中最重要的协议.</p><h3 id="ATT协议"><a href="#ATT协议" class="headerlink" title="ATT协议"></a>ATT协议</h3><p>基本的ATT协议主要包含三个元素:</p><ul><li>value - 一句被希望广播的信息</li><li>UUID - 一种被GATT使用的属性</li><li>16bit的句柄 - 一个唯一的识别码</li></ul><p>服务端储存这些属性,客户端利用ATT协议来读写这些属性</p><h3 id="GATT配置文件"><a href="#GATT配置文件" class="headerlink" title="GATT配置文件"></a>GATT配置文件</h3><p>GATT定义了不同的UUID编码来识别不同的服务,以下是一个例子:</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/BLE/%E8%8D%89%E5%9B%BE.png"><br>以上这些UUID由<strong>Bluetooth Special Interest Group</strong>官方定义,同样我们可以使用未被定义的UUID来实现我们的私有协议.总的来说,一个设备可以实现多个功能,由不同的UUID解释器来解释.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;h3 id=&quot;原文连接-https-doc-qt-io-qt-5-qtbluetooth-le-overview-html&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="蓝牙" scheme="https://blog.zzshub.cn/tags/%E8%93%9D%E7%89%99/"/>
    
    <category term="Qt" scheme="https://blog.zzshub.cn/tags/Qt/"/>
    
    <category term="BLE" scheme="https://blog.zzshub.cn/tags/BLE/"/>
    
  </entry>
  
  <entry>
    <title>mathjax数学公式编辑工具</title>
    <link href="https://blog.zzshub.cn/2018/05/04/mathjax/"/>
    <id>https://blog.zzshub.cn/2018/05/04/mathjax/</id>
    <published>2018-05-04T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mathjax数学公式编辑工具使用简介"><a href="#mathjax数学公式编辑工具使用简介" class="headerlink" title="mathjax数学公式编辑工具使用简介"></a>mathjax数学公式编辑工具使用简介</h1><blockquote><p>数学在各个学科的许多方面有许多重要的用途。本文主要研究利用数学公式编辑工具<strong>mathjax</strong>快速编辑复杂数学公式。本文主要研究<strong>mathjax</strong>的使用，关于它的安装配置等本文将不做深入讨论。关于<a href="https://www.mathjax.org/">mathjax</a>在<a href="https://hexo.io/">hexo</a>博客系统下的配置可以<a href="https://github.com/hexojs/hexo-math">点击这里</a></p></blockquote><h1 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h1><p>$$ \iiint_v(\sum_{i&#x3D;0}^{\infty}\frac{\partial{(xy_i}+\sqrt[5]{y_i^2})}{\partial{x}})dv   $$</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="公式显示"><a href="#公式显示" class="headerlink" title="公式显示"></a>公式显示</h2><p>公式显示一共有两种方式,一种是行内显示如$\frac{a^2_i}{b}$,而另一种是单独显示,就像上文那个例子那样.在markdown中显示数学公式都需要特定的标识符,行内显示使用单个<code>$</code>来确定显示的内容,例如<code>$ a=b^2 $</code>那么输出效果就是$a&#x3D;b^2$ .独立显示使用<code>$$</code>,例如<code>$$ a=b^2 $$</code><br>$$ a&#x3D;b^2$$</p><p>另外如果公式有多行,可以使用 和 来包含多行内容,例如</p><p>$$<br>\begin{aligned}<br>\dot{x} &amp; &#x3D; \sigma(y-x) \<br>\dot{y} &amp; &#x3D; \rho x - y - xz \<br>\dot{z} &amp; &#x3D; -\beta z + xy<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>\dot{x} &amp; &#x3D; \sigma(y-x) \<br>\dot{y} &amp; &#x3D; \rho x - y - xz \<br>\dot{z} &amp; &#x3D; -\beta z + xy<br>\end{aligned}<br>$$</p><p>另外,如果要使用$符号,可以输入<code>\$</code> </p><h2 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h2><p>在mathjax中使用<code>^</code>表示商标,如<code>b^2</code>表示 $b^2$,用<code>_</code>表示下标,例如<code>a_i</code>表示$a_i$.</p><h2 id="成组"><a href="#成组" class="headerlink" title="成组"></a>成组</h2><p>用<code>&#123;&#125;</code>来标记一组数据,例如<code>b^&#123;21&#125;</code>表示$b^{21}$,而<code>b^21</code>则被解释为$b^21$.普通的大括号可以使用<code>\&#123;</code> <code>\&#125;</code>来表示</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>在mathjax中各个符号都是用转义字符来实现的,例如<code>\partial</code>表示$\partial$ ,<code>\sum</code>表示$\sum$,结合上文所述的上下标可以知道<code>\sum_&#123;i=0&#125;^n</code>表示$\sum_{i&#x3D;0}^n$.一般情况下可用\来作转义，但如果想要表示\本身，需要用<code>\backslash</code>，因为\表示换行.</p><h1 id="常用计算符号"><a href="#常用计算符号" class="headerlink" title="常用计算符号"></a>常用计算符号</h1><blockquote><p>下面列出一些标量计算中常常会使用到的符号</p></blockquote><h3 id="常用字母"><a href="#常用字母" class="headerlink" title="常用字母"></a>常用字母</h3><table><thead><tr><th>符号</th><th>效果</th><th>备注</th></tr></thead><tbody><tr><td>\infty</td><td>$\infty$</td><td></td></tr><tr><td>\pi</td><td>$\pi$</td><td></td></tr><tr><td>\alpha</td><td>$\alpha$</td><td></td></tr><tr><td>\varepsilon</td><td>$\varepsilon$</td><td></td></tr><tr><td>\beta</td><td>$\beta$</td><td></td></tr><tr><td>\gamma</td><td>$\gamma$</td><td></td></tr><tr><td>\theta</td><td>$\theta$</td><td></td></tr><tr><td>\eta</td><td>$\eta$</td><td></td></tr><tr><td>\lambda</td><td>$\lambda$</td><td></td></tr><tr><td>\varphi</td><td>$\varphi$</td><td></td></tr><tr><td>\mu</td><td>$\mu$</td><td></td></tr><tr><td>\nu</td><td>$\nu$</td><td></td></tr><tr><td>\xi</td><td>$\xi$</td><td></td></tr><tr><td>\rho</td><td>$\rho$</td><td></td></tr><tr><td>\sigma</td><td>$\sigma$</td><td></td></tr><tr><td>\Delta</td><td>$\Delta$</td><td></td></tr><tr><td>\Omega</td><td>$\Omega$</td><td></td></tr><tr><td>\Psi</td><td>$\Psi$</td><td></td></tr><tr><td>Sigma</td><td>$\Sigma$</td><td></td></tr></tbody></table><h3 id="基本运算符号"><a href="#基本运算符号" class="headerlink" title="基本运算符号"></a>基本运算符号</h3><table><thead><tr><th>符号</th><th>效果</th><th>备注</th></tr></thead><tbody><tr><td>\ast</td><td>$\ast$</td><td></td></tr><tr><td>\times</td><td>$\times$</td><td></td></tr><tr><td>\div</td><td>$\div$</td><td></td></tr><tr><td>\frac{}{}</td><td>$\frac{a}{b}$</td><td>可以支持复杂多重分式</td></tr><tr><td>\sqrt[n]</td><td>$\sqrt[n]{a}$</td><td></td></tr><tr><td>\vert</td><td>$\vert$</td><td>绝对值符号</td></tr><tr><td>\pm</td><td>$\pm$</td><td></td></tr><tr><td>\mp</td><td>$\mp$</td><td></td></tr><tr><td>\cap</td><td>$\cap$</td><td></td></tr><tr><td>\cup</td><td>$\cup$</td><td></td></tr><tr><td>\leq</td><td>$\leq$</td><td></td></tr><tr><td>\geq</td><td>$\geq$</td><td></td></tr><tr><td>\ll</td><td>$\ll$</td><td></td></tr><tr><td>\gg</td><td>$\gg$</td><td></td></tr><tr><td>\approx</td><td>$\approx$</td><td></td></tr><tr><td>\neq</td><td>$\neq$</td><td></td></tr><tr><td>\ni</td><td>$\ni$</td><td></td></tr><tr><td>\in</td><td>$\in$</td><td></td></tr><tr><td>\lgroup</td><td>$\lgroup$</td><td>大小会变化</td></tr><tr><td>\rgroup</td><td>$\rgroup$</td><td>大小会变化</td></tr><tr><td>\lim{a \to b}</td><td>$$\lim_{a \to b}$$</td><td></td></tr></tbody></table><h3 id="积分和导数"><a href="#积分和导数" class="headerlink" title="积分和导数"></a>积分和导数</h3><table><thead><tr><th>符号</th><th>效果</th><th>备注</th></tr></thead><tbody><tr><td>\sum</td><td>$\sum$</td><td></td></tr><tr><td>\prod</td><td>$\prod$</td><td></td></tr><tr><td>\int</td><td>$\int$</td><td>多重积分就多几个i</td></tr><tr><td>\oint</td><td>$\oint$</td><td></td></tr><tr><td>\partial</td><td>$\partial$</td><td></td></tr></tbody></table><h3 id="向量和几何"><a href="#向量和几何" class="headerlink" title="向量和几何"></a>向量和几何</h3><table><thead><tr><th>符号</th><th>效果</th><th>备注</th></tr></thead><tbody><tr><td>\mathbf{a}</td><td>$\mathbf{a}$</td><td>向量中的加粗字体</td></tr><tr><td>\overrightarrow{abc}</td><td>$\overrightarrow{abc}$</td><td></td></tr><tr><td>\overleftarrow{abc}</td><td>$\overleftarrow{abc}$</td><td></td></tr><tr><td>\overline{abc}</td><td>$\overline{abc}$</td><td></td></tr><tr><td>\underline{abc}</td><td>$\underline{abc}$</td><td></td></tr><tr><td>\nabla</td><td>$\nabla$</td><td></td></tr><tr><td>\angle</td><td>$\angle$</td><td></td></tr><tr><td>\cdot</td><td>$\cdot$</td><td></td></tr><tr><td>\because</td><td>$\because$</td><td></td></tr><tr><td>\therefore</td><td>$\therefore$</td><td></td></tr><tr><td>\dot{}</td><td>$\dot{a}$</td><td>多加一个d就多一个点</td></tr></tbody></table><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>可以用 <code>$$\begin&#123;matrix&#125;…\end&#123;matrix&#125;$$</code> 来表示矩阵。将矩阵元素放在 \begin 和 \end 之间即可。 用 \ 来分割行，用 &amp; 来分割同一行的矩阵元素。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; x &amp; x^2 \\</span><br><span class="line">1 &amp; y &amp; y^2 \\</span><br><span class="line">1 &amp; z &amp; z^2 \\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>\begin{matrix}<br>    1 &amp; x &amp; x^2 \<br>    1 &amp; y &amp; y^2 \<br>    1 &amp; z &amp; z^2 \<br>\end{matrix}<br>$$</p><h3 id="增广矩阵"><a href="#增广矩阵" class="headerlink" title="增广矩阵"></a>增广矩阵</h3><p>用到{array}语句,{cc|c}的作用是在第二列和第三列之间画一条垂直线,例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin &#123;array&#125; &#123;cc|c&#125;</span><br><span class="line">  1&amp;2&amp;3\\</span><br><span class="line">  4&amp;5&amp;6</span><br><span class="line">\end &#123;array&#125;</span><br></pre></td></tr></table></figure><p>$$<br>    \begin {array} {cc|c}<br>      1&amp;2&amp;3\<br>      4&amp;5&amp;6<br>    \end {array}<br>$$</p><h3 id="矩阵符号"><a href="#矩阵符号" class="headerlink" title="矩阵符号"></a>矩阵符号</h3><table><thead><tr><th>符号</th><th>效果</th><th>备注</th></tr></thead><tbody><tr><td>\cdots</td><td>$\cdots$</td><td></td></tr><tr><td>\vdots</td><td>$\vdots$</td><td></td></tr><tr><td>\ddots</td><td>$\ddots$</td><td></td></tr><tr><td>pmatrix</td><td>$$\begin{pmatrix}1 &amp; x &amp; x^2 \1 &amp; y &amp; y^2 \1 &amp; z &amp; z^2 \\end{pmatrix}$$</td><td></td></tr><tr><td>bmatrix</td><td>$$\begin{bmatrix}1 &amp; x &amp; x^2 \1 &amp; y &amp; y^2 \1 &amp; z &amp; z^2 \\end{bmatrix}$$</td><td></td></tr><tr><td>Bmatrix</td><td>$$\begin{Bmatrix}1 &amp; x &amp; x^2 \1 &amp; y &amp; y^2 \1 &amp; z &amp; z^2 \\end{Bmatrix}$$</td><td></td></tr><tr><td>vmatrix</td><td>$$\begin{vmatrix}1 &amp; x &amp; x^2 \1 &amp; y &amp; y^2 \1 &amp; z &amp; z^2 \\end{vmatrix}$$</td><td></td></tr><tr><td>Vmatrix</td><td>$$\begin{Vmatrix}1 &amp; x &amp; x^2 \1 &amp; y &amp; y^2 \1 &amp; z &amp; z^2 \\end{Vmatrix}$$</td><td></td></tr></tbody></table><h1 id="以下是所有支持的符号"><a href="#以下是所有支持的符号" class="headerlink" title="以下是所有支持的符号"></a>以下是所有支持的符号</h1><p>这是PDF版本的<a href="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/mathjax/maths-symbols.pdf.pdf">下载链接</a></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/mathjax/IMG_2987.JPG"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;mathjax数学公式编辑工具使用简介&quot;&gt;&lt;a href=&quot;#mathjax数学公式编辑工具使用简介&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="blog" scheme="https://blog.zzshub.cn/tags/blog/"/>
    
    <category term="mathjax" scheme="https://blog.zzshub.cn/tags/mathjax/"/>
    
    <category term="hexo" scheme="https://blog.zzshub.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>自制摇摇棒</title>
    <link href="https://blog.zzshub.cn/2018/04/08/YaoYyaobangOnSTM32/"/>
    <id>https://blog.zzshub.cn/2018/04/08/YaoYyaobangOnSTM32/</id>
    <published>2018-04-07T16:11:34.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自制摇摇棒开发总结"><a href="#自制摇摇棒开发总结" class="headerlink" title="自制摇摇棒开发总结"></a>自制摇摇棒开发总结</h1><blockquote><p>最近做了一个摇摇棒,也算是一个小制作吧,原理很简单,制作过程也不是很复杂.</p></blockquote><blockquote><p>YaoyaobangOnSTM32硬件及软件<a href="https://github.com/ZzzzzzS/YaoyaobangOnSTM32">资料下载</a></p></blockquote><hr><h1 id="摇摇棒简介"><a href="#摇摇棒简介" class="headerlink" title="摇摇棒简介"></a>摇摇棒简介</h1><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/yaoyaobang/%E8%8D%89%E5%9B%BE2.png"></p><p>摇摇棒就是一个可以摇动然后显示图案的小制作.利用人眼的视觉暂留现象,显示图案.我制作的摇摇棒使用<strong>STM32C8T6</strong>微控制器作为主控,使用内部RC震动器(也可外接晶振),采用16个LED灯作为显示部分,采用ams1117作为电源稳压芯片,也可直接不经过稳压芯片直接驱动.软件方面设计为摇动的频率可变,以任意较快频率(可产生视觉暂留现象的频率)晃动都可以产生图像.采用低功耗设计,自动进入待机模式节省电量.待机时功耗低至60μw.</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/yaoyaobang/%E8%8D%89%E5%9B%BE3.png"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="检测频率"><a href="#检测频率" class="headerlink" title="检测频率"></a>检测频率</h2><p>使用震动开关检测晃动的频率,震动开关就是在震动的时候能产生高低电平.通过systick定时器和外部中断的配合使用可以达到计算晃动频率的目的.以下是两个主要使用的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_SYSTICK_Callback</span><span class="params">()</span><span class="comment">//定时器回掉函数</span></span><br><span class="line">&#123;</span><br><span class="line">yaoyaobangBase.timeCount++;</span><br><span class="line"><span class="keyword">if</span>(yaoyaobangBase.timeCount&gt;=<span class="number">10000</span>)</span><br><span class="line">&#123;</span><br><span class="line">yaoyaobangBase.timeCount=<span class="number">10000</span>;</span><br><span class="line">PowerManagement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(yaoyaobangBase.DelayMS!=<span class="number">0</span>)</span><br><span class="line">yaoyaobangBase.DelayMS--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span> <span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span><span class="comment">//外部中断回掉函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(GPIO_Pin==Vibrate)</span><br><span class="line">  &#123;</span><br><span class="line">    yaoyaobangBase.time=yaoyaobangBase.timeCount;</span><br><span class="line">    yaoyaobangBase.timeCount=<span class="number">0</span>;</span><br><span class="line">    yaoyaobangBase.state=run;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LED显示"><a href="#LED显示" class="headerlink" title="LED显示"></a>LED显示</h2><p>计算出每晃动一次的时间之后就是控制LED灯显示了.以下是我输出图形的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> Image[<span class="number">16</span>*ImageLenth]=</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大概能看出来图形吧.1和0就代表着灯的亮和灭,一共16个灯所以是(16X图像长度).当然啦,像我这样保持图像有点原始,更优化的方案是用bit来保存,显示的时候直接把一个字节写进寄存器省去了按位与或非的过程,既节省时间又节省空间.当然甚至还可以利用DMA+定时器做硬件触发链,完全利用硬件输出图像更能加速和降低功耗.说多了,将计算出的晃动时间除以图像长度就得到了每一帧应该输出的时间了,控制LED输出即可.以下是输出部分.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowImage</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *this)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *base=this;</span><br><span class="line">yaoyaobangBase.moment=yaoyaobangBase.time/ImageLenth;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> i=<span class="number">0</span>;i&lt;ImageLenth;i++)</span><br><span class="line">&#123;</span><br><span class="line">          this=base;</span><br><span class="line">          LEDShow((this+<span class="number">16</span>*i));<span class="comment">//每一帧的输出</span></span><br><span class="line">          yaoyaobangBase.DelayMS=yaoyaobangBase.moment;</span><br><span class="line">          <span class="keyword">while</span>(yaoyaobangBase.DelayMS!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">yaoyaobangBase.state=stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="低功耗"><a href="#低功耗" class="headerlink" title="低功耗"></a>低功耗</h2><p>低功耗是从设计之初就考虑到的问题,就是不想在我设计出来的东西上加关机键,所以设计就没有加开关,用低功耗的待机模式即可.待机功耗最终降到19μA,还是在预期范围内.实现低功耗主要就是进入低功耗模式以及低功耗唤醒两方面了.先说进入待机模式,现在HAL库功能强大,一句<code>HAL_PWR_EnterSTANDBYMode();</code>就可进入待机模式.不过退出待机模式就需要硬件支持了,PA0管脚的跳变可以触发唤醒,所以我的震动开关用的这个脚,不过最后我放弃了唤醒这个功能,改为用复位按键实现唤醒,主要是震动开关不是特别稳定,误触发的情况比较严重.另外,使用内部RC震动器,工作时主频以较低的8MHz工作灯也有助于降低功耗.</p><h1 id="填坑总结"><a href="#填坑总结" class="headerlink" title="填坑总结"></a>填坑总结</h1><h2 id="坑1-JTAG管脚复用问题"><a href="#坑1-JTAG管脚复用问题" class="headerlink" title="坑1:JTAG管脚复用问题"></a>坑1:JTAG管脚复用问题</h2><p>焊接完成芯片以后测试时发现有几个脚连在了一起,挑开后发现始终<strong>GPIOB3</strong>和<strong>GPIOB4</strong>脚不受控制.开始以为是脚还连在一起,换芯片后问题依旧.<strong>最后发现是JTAG管脚复用问题,这两个脚上电默认功能是JTAG,需要先复用成GPIO,之后操作GPIO才有效</strong>,在STM32的HAL库中系统初始化时本来关闭了JTAG的,但是STlink就没法工作,于是我将那一行注释了就造成这样的错误.</p><h2 id="坑2-flash容量选错"><a href="#坑2-flash容量选错" class="headerlink" title="坑2:flash容量选错"></a>坑2:flash容量选错</h2><p>开始建立工程时芯片型号选择错误,导致flash容量时错误的,虽然烧录进去了,但是执行的时候程序跑飞,差点锁死.<strong>CMSIS-DAP使用没有STlink和J-link那么稳定,尤其是解锁或者擦flash的时候</strong>.另外建立工程时一定要<strong>选择正确型号</strong></p><h2 id="坑3-编译优化等级"><a href="#坑3-编译优化等级" class="headerlink" title="坑3:编译优化等级"></a>坑3:编译优化等级</h2><p>采用CubeMX建立出来的工程貌似默认的编译优化等级就是最高级,导致最开始的调试结果始终有问题,单步调试时总感觉很奇怪.<strong>在开发调试阶段一定要注意编译优化等级,不要开优化,到后期优化时在开高</strong>,太高等级有可能无法正常运行的.</p><h2 id="坑4-AMS1117功耗问题"><a href="#坑4-AMS1117功耗问题" class="headerlink" title="坑4:AMS1117功耗问题"></a>坑4:AMS1117功耗问题</h2><p>AMS1117作为线性稳压电源静态功耗其实不低的,根据我的测算,输入电压6v时静态电流5mA.其实也不是很大,不过需要低功耗场景时这个5mA却十分致命,严重影响续航时间(5mA那么1000mAh的电池只能待机8天).为保证待机时间,我在最后阶段去掉了这个芯片,待机电流迅速降低到19μA,理论上1000mAh的电池应该可以续航7年了.</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>遇到了坑,填吧,只能记录下来尽量让下次注意.通过这个小制作也更加了解STM32系列了,尤其是HAL库和低功耗设计.不得不说ST的HAL库确实良心,非常好用,层次清晰,抽象程度恰到好处,没有炫技式写法,帮助文档做得也十分贴心,看得出来ST确实用心做了这个库,不像NXP的MCUXpresso,简直难用到爆炸,为炫技而存在,故意复杂化问题.另外配套的CubeMX工具也很好用,帮助建立工程以及初始化等,的确能让开发者直面问题本身而不是花大量时间建立工程,配置各种初始化等.</p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;自制摇摇棒开发总结&quot;&gt;&lt;a href=&quot;#自制摇摇棒开发总结&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="STM32" scheme="https://blog.zzshub.cn/tags/STM32/"/>
    
    <category term="作品" scheme="https://blog.zzshub.cn/tags/%E4%BD%9C%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>IAR7.8STM32无法下载程序错误解决方法</title>
    <link href="https://blog.zzshub.cn/2018/04/06/Report/"/>
    <id>https://blog.zzshub.cn/2018/04/06/Report/</id>
    <published>2018-04-06T14:00:23.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IAR7-8对STM32f1系列下载程序时出现错误报告"><a href="#IAR7-8对STM32f1系列下载程序时出现错误报告" class="headerlink" title="IAR7.8对STM32f1系列下载程序时出现错误报告"></a>IAR7.8对STM32f1系列下载程序时出现错误报告</h1><h2 id="IAR-The-selected-device-does-not-match-the-target-device"><a href="#IAR-The-selected-device-does-not-match-the-target-device" class="headerlink" title="IAR The selected device does not match the target device"></a>IAR The selected device does not match the target device</h2><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/iar7.8Bug/150950d4yzyykqtqkhuo2o.png"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p><a href="http://supp.iar.com/Updates/?product=EWarm">http://supp.iar.com/Updates/?product=EWarm</a> 下载安装补丁即可</p><h3 id="也可以在本站下载-点击下载"><a href="#也可以在本站下载-点击下载" class="headerlink" title="也可以在本站下载 点击下载"></a>也可以在本站下载 <a href="https://zzshubimage-1253829354.cosbj.myqcloud.com/iar7.8Bug/ewarm-7.80.4.12176-patch.zip">点击下载</a></h3><hr><h1 id="IAR产品补丁发布地址"><a href="#IAR产品补丁发布地址" class="headerlink" title="IAR产品补丁发布地址"></a>IAR产品补丁发布地址</h1><p><a href="http://supp.iar.com/Updates/">http://supp.iar.com/Updates/</a></p><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;IAR7-8对STM32f1系列下载程序时出现错误报告&quot;&gt;&lt;a href=&quot;#IAR7-8对STM32f1系列下载程序时出现错误报告&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="STM32" scheme="https://blog.zzshub.cn/tags/STM32/"/>
    
    <category term="IAR" scheme="https://blog.zzshub.cn/tags/IAR/"/>
    
    <category term="错误报告" scheme="https://blog.zzshub.cn/tags/%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>kinetis KV58 FTM模块食用指南</title>
    <link href="https://blog.zzshub.cn/2018/02/07/FTM/"/>
    <id>https://blog.zzshub.cn/2018/02/07/FTM/</id>
    <published>2018-02-07T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NXP-Kinetis系列-KV58微控制器FTM模块食用指南"><a href="#NXP-Kinetis系列-KV58微控制器FTM模块食用指南" class="headerlink" title="NXP Kinetis系列 KV58微控制器FTM模块食用指南"></a>NXP Kinetis系列 KV58微控制器FTM模块食用指南</h1><blockquote><p>本文主要介绍利用FTM模块输出pwm波和利用FTM模块进行正交解码</p></blockquote><h1 id="FTM模块简介"><a href="#FTM模块简介" class="headerlink" title="FTM模块简介"></a>FTM模块简介</h1><p>FTM模块是一个多功能定时器模块,主要功能有,PWM输出、输入捕捉、输出比较、定时中断、脉冲加减计数、脉冲周期脉宽测量.在KV58中,共有FTM0,FTM1,FTM2,FTM3四个独立的FTM模块.其中FTM0和FTM3有8个通道,可用于电机或舵机的PWM输出,但不具备正交解码功能,也就是对旋转编码器输入的正反向计数功能.而FTM1和FTM2则具备正交解码功能,但是FTM1和FTM2各只有两个通道.FTM模块的时间基准来自一个16位的计数器,该计数器的值可读取,即可作为无符号数对待,也可作为有符号数的补码对待.</p><h1 id="FTM模块与TPM差异"><a href="#FTM模块与TPM差异" class="headerlink" title="FTM模块与TPM差异"></a>FTM模块与TPM差异</h1><p>熟悉恩智浦 Kinetis MCU 的朋友会发现,Kinetis 各个系列都有某种联系或者可以称为一脉相承吧！举个 L 系列的 TPM 与 K 系列的 FTM 例子吧.根据参考手册的叙述,FTM 模块是 TPM 模块改进而来的一种定时器模块,即飞思卡尔在它的 8 位单片机 HCS08 系列上应用多年的定时器模块. FTM 模块在扩展了许多功能,为 TPM 提供了低功耗和向后兼容的特性.这些增强的的功能有：有符号型计数器,硬件增加死区,故障控制输入,增强触发功能,初始化和极性控制.</p><h1 id="FTM模块特性"><a href="#FTM模块特性" class="headerlink" title="FTM模块特性"></a>FTM模块特性</h1><p>挑重点来说大概就是</p><ul><li>PWM输出</li><li>PWM死区补偿</li><li>输入计数</li><li>正交解码</li><li>兼容TPM模块</li></ul><p>等等.以下是官方的解释:</p><blockquote><h3 id="44-2-2-Features"><a href="#44-2-2-Features" class="headerlink" title="44.2.2 Features"></a>44.2.2 Features</h3><p>The FTM features include:</p><ul><li>FTM source clock is selectable. </li><li>The source clock can be the system clock, the fixed frequency clock, or an external clock </li><li>Fixed frequency clock is an additional clock input to allow the selection of an on chip clock source other than the system clock </li><li>Selecting external clock connects FTM clock to a chip level input pin therefore allowing to synchronize the FTM counter with an off chip clock source </li><li>Prescaler divide-by 1, 2, 4, 8, 16, 32, 64, or 128 </li><li>16-bit counter </li><li>It can be a free-running counter or a counter with initial and final value </li><li>The counting can be up or up-down </li><li>Each channel can be configured for input capture, output compare, or edge-aligned PWM mode </li><li>In Input Capture mode: </li><li>The capture can occur on rising edges, falling edges or both edges<br>*An input filter can be selected for some channels </li><li>In Output Compare mode the output signal can be set, cleared, or toggled on match </li><li>All channels can be configured for center-aligned PWM mode</li><li>Each pair of channels can be combined to generate a PWM signal with independent control of both edges of PWM signal </li><li>The FTM channels can operate as pairs with equal outputs, pairs with complementary outputs, or independent channels with independent outputs </li><li>The deadtime insertion is available for each complementary pair </li><li>Generation of match triggers </li><li>Initialization trigger </li><li>Software control of PWM outputs </li><li>Up to 4 fault inputs for global fault control </li><li>The polarity of each channel is configurable </li><li>The generation of an interrupt per channel </li><li>The generation of an interrupt when the counter overflows </li><li>The generation of an interrupt when the fault condition is detected </li><li>Synchronized loading of write buffered FTM registers &gt;* Write protection for critical registers </li><li>Backwards compatible with TPM </li><li>Testing of input captures for a stuck at zero and one conditions </li><li>Dual edge capture for pulse and period width measurement </li><li>Quadrature decoder with input filters, relative position counting, and interrupt on position count or capture of position count on external event</li></ul></blockquote><h1 id="FTM模块构造"><a href="#FTM模块构造" class="headerlink" title="FTM模块构造"></a>FTM模块构造</h1><p><strong>FTM模块简图</strong><br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%89%E5%9B%BE.png"></p><p>由图可以看出,FTM模块的核心是一个16位计数器,所有通道共用唯一一个计数器.传入FTM模块的时钟(可以是内部时钟也可以是外部脉冲)经预分频器分频后传入FTM的16位计数器,再连接至各通道.所以一个FTM模块所有通道输出频率是相同的,并且只能选择一个时钟源,也就是说一个FTM模块不能同时做到正交解码和PWM输出.另外各相邻通道组成一个通道对,由一个控制器来控制.此外还可以发现所有中断共享一个中断号,FTM中断也是先中断再判断中断类型.</p><h1 id="FTM寄存器"><a href="#FTM寄存器" class="headerlink" title="FTM寄存器"></a>FTM寄存器</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> SC;                                <span class="comment">/**&lt; Status And Control, offset: 0x0 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CNT;                               <span class="comment">/**&lt; Counter, offset: 0x4 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> MOD;                               <span class="comment">/**&lt; Modulo, offset: 0x8 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span>                                         <span class="comment">/* offset: 0xC, array step: 0x8 */</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> CnSC;                              <span class="comment">/**&lt; Channel (n) Status And Control, array offset: 0xC, array step: 0x8 */</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> CnV;                               <span class="comment">/**&lt; Channel (n) Value, array offset: 0x10, array step: 0x8 */</span></span><br><span class="line">  &#125; CONTROLS[<span class="number">8</span>];</span><br><span class="line">  __IO <span class="type">uint32_t</span> CNTIN;                             <span class="comment">/**&lt; Counter Initial Value, offset: 0x4C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> STATUS;                            <span class="comment">/**&lt; Capture And Compare Status, offset: 0x50 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> MODE;                              <span class="comment">/**&lt; Features Mode Selection, offset: 0x54 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> SYNC;                              <span class="comment">/**&lt; Synchronization, offset: 0x58 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OUTINIT;                           <span class="comment">/**&lt; Initial State For Channels Output, offset: 0x5C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> OUTMASK;                           <span class="comment">/**&lt; Output Mask, offset: 0x60 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> COMBINE;                           <span class="comment">/**&lt; Function For Linked Channels, offset: 0x64 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> DEADTIME;                          <span class="comment">/**&lt; Deadtime Insertion Control, offset: 0x68 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> EXTTRIG;                           <span class="comment">/**&lt; FTM External Trigger, offset: 0x6C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> POL;                               <span class="comment">/**&lt; Channels Polarity, offset: 0x70 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> FMS;                               <span class="comment">/**&lt; Fault Mode Status, offset: 0x74 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> FILTER;                            <span class="comment">/**&lt; Input Capture Filter Control, offset: 0x78 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> FLTCTRL;                           <span class="comment">/**&lt; Fault Control, offset: 0x7C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> QDCTRL;                            <span class="comment">/**&lt; Quadrature Decoder Control And Status, offset: 0x80 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CONF;                              <span class="comment">/**&lt; Configuration, offset: 0x84 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> FLTPOL;                            <span class="comment">/**&lt; FTM Fault Input Polarity, offset: 0x88 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> SYNCONF;                           <span class="comment">/**&lt; Synchronization Configuration, offset: 0x8C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> INVCTRL;                           <span class="comment">/**&lt; FTM Inverting Control, offset: 0x90 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> SWOCTRL;                           <span class="comment">/**&lt; FTM Software Output Control, offset: 0x94 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PWMLOAD;                           <span class="comment">/**&lt; FTM PWM Load, offset: 0x98 */</span></span><br><span class="line">&#125; FTM_Type;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是FTM1和FTM2的<code>CONTROLS[8]</code>寄存器的后6位是没有的.</strong></p><h1 id="PWM产生"><a href="#PWM产生" class="headerlink" title="PWM产生"></a>PWM产生</h1><h2 id="PWM几种模式"><a href="#PWM几种模式" class="headerlink" title="PWM几种模式"></a>PWM几种模式</h2><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%892%E5%9B%BE.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%893%E5%9B%BE.png"></p><h2 id="PWM寄存器实例"><a href="#PWM寄存器实例" class="headerlink" title="PWM寄存器实例"></a>PWM寄存器实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ftm_pwm_init</span><span class="params">(FTM_Type* ftmn, <span class="type">uint8_t</span> ch, <span class="type">uint32_t</span> freq, <span class="type">uint32_t</span> duty)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> clk_hz ;</span><br><span class="line">  <span class="type">uint16_t</span> mod;</span><br><span class="line">  <span class="type">uint8_t</span>  ps;</span><br><span class="line">  <span class="type">uint16_t</span> cv;</span><br><span class="line">  <span class="keyword">if</span>(ftmn==FTM0)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM0_MASK; <span class="comment">//打开模块时钟</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM1)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM1_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM2)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM2_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM3)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM3_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  clk_hz = CLOCK_GetBusClkFreq();     <span class="comment">// bus频率</span></span><br><span class="line">  mod = (clk_hz &gt;&gt; <span class="number">16</span> ) / freq ;      <span class="comment">// 临时用 mod 缓存一下</span></span><br><span class="line">  ps = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((mod &gt;&gt; ps) &gt;= <span class="number">1</span>)             <span class="comment">// 等 (mod &gt;&gt; ps) &lt; 1 才退出 while 循环 ，即求 PS 的最小值</span></span><br><span class="line">  &#123;</span><br><span class="line">      ps++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(ps &lt;= <span class="number">0x07</span>);                 <span class="comment">// 断言， PS 最大为 0x07 ，超过此值，则 PWM频率设置过低，或 Bus 频率过高</span></span><br><span class="line">  mod = (clk_hz &gt;&gt; ps) / freq;        <span class="comment">// 求 MOD 的值</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(ftmn==FTM0)</span><br><span class="line">  &#123;</span><br><span class="line">    cv = (duty * (mod - <span class="number">0</span> + <span class="number">1</span>)) / FTM0_PRECISON;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM1)</span><br><span class="line">  &#123;</span><br><span class="line">    cv = (duty * (mod - <span class="number">0</span> + <span class="number">1</span>)) / FTM1_PRECISON;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM2)</span><br><span class="line">  &#123;</span><br><span class="line">    cv = (duty * (mod - <span class="number">0</span> + <span class="number">1</span>)) / FTM2_PRECISON;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM3)</span><br><span class="line">  &#123;</span><br><span class="line">    cv = (duty * (mod - <span class="number">0</span> + <span class="number">1</span>)) / FTM3_PRECISON;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;SC |= FTM_SC_PS(ps);  <span class="comment">//设置预分频系数</span></span><br><span class="line">  </span><br><span class="line">  FTM0-&gt;MOD = mod;            <span class="comment">//设置计数上限</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;CONTROLS[ch].CnSC &amp;=~FTM_CnSC_ELSA_MASK;</span><br><span class="line">  ftmn-&gt;CONTROLS[ch].CnSC |= ( FTM_CnSC_MSB_MASK | FTM_CnSC_ELSB_MASK | FTM_CnSC_DMA_MASK); <span class="comment">//选择模式为边沿对齐PWM,具体见上图(配置完这一步PWM波已经开始输出)</span></span><br><span class="line">  ftmn-&gt;CONTROLS[ch].CnV = cv; <span class="comment">//通道占空比寄存器,设置占空比</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;CNTIN = <span class="number">0</span>; <span class="comment">//设置计数下限为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="正交解码"><a href="#正交解码" class="headerlink" title="正交解码"></a>正交解码</h1><p>FTM模块正交解码分为两种模式,分别是AB向模式和正交模式,平时使用较多的是正交模式.</p><p><strong>AB向模式:</strong><br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%89%E5%9B%BE4.png"></p><p><strong>正交模式:</strong><br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/FTM/%E8%8D%89%E5%9B%BE5.png"></p><p>此外,输入通道还有硬件滤波功能,可以减小干扰.正交解码后的脉冲计数值存在CNT寄存器中,读取该寄存器不会自动清除寄存器的值.周期读取该寄存器值并且清空配合编码器就可以计算出转动速度.</p><h2 id="正交解码实例"><a href="#正交解码实例" class="headerlink" title="正交解码实例"></a>正交解码实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ftm_quad_init</span><span class="params">(FTM_Type* ftmn)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(ftmn==FTM0)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM0_MASK; <span class="comment">//打开模块时钟</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM1)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM1_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM2)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM2_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ftmn==FTM3)</span><br><span class="line">  &#123;</span><br><span class="line">    SIM-&gt;SCGC6 |= SIM_SCGC6_FTM3_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;MODE |= FTM_MODE_WPDIS_MASK; <span class="comment">//关闭写保护</span></span><br><span class="line">  ftmn-&gt;MODE |= FTM_MODE_FTMEN_MASK; <span class="comment">//使能FTM功能,不然就只能使用TPM的功能</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;QDCTRL |= FTM_QDCTRL_QUADMODE_MASK; <span class="comment">//选择正交解码模式</span></span><br><span class="line">   </span><br><span class="line">  ftmn-&gt;CNTIN = <span class="number">0</span>; <span class="comment">//设置计数下限为0</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;MOD = FTM_MOD_MOD_MASK; <span class="comment">//设置计数上限为最大值(free running模式)</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;QDCTRL |= FTM_QDCTRL_QUADEN_MASK; <span class="comment">//使能正交解码</span></span><br><span class="line">  </span><br><span class="line">  ftmn-&gt;CNT = <span class="number">0</span>; <span class="comment">//清除计数器中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;NXP-Kinetis系列-KV58微控制器FTM模块食用指南&quot;&gt;&lt;a href=&quot;#NXP-Kinetis系列-KV58微控制器FTM模块食用指南&quot; class=&quot;headerlink&quot; title=&quot;NXP Kinetis系列</summary>
        
      
    
    
    
    
    <category term="ARM" scheme="https://blog.zzshub.cn/tags/ARM/"/>
    
    <category term="kinetis" scheme="https://blog.zzshub.cn/tags/kinetis/"/>
    
    <category term="register" scheme="https://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>kinetis KV58 ADC模块食用指南</title>
    <link href="https://blog.zzshub.cn/2018/02/05/kinetisadc/"/>
    <id>https://blog.zzshub.cn/2018/02/05/kinetisadc/</id>
    <published>2018-02-05T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目前暂时未实现硬件dma触发,目前使用中断软件触发dma搬运,有待进一步改进.</p></blockquote><h1 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* Init board hardware. */</span></span><br><span class="line">  BOARD_InitBootPins();</span><br><span class="line">  BOARD_InitBootClocks();</span><br><span class="line">  BOARD_InitDebugConsole();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  SIM-&gt;SCGC6 |= SIM_SCGC6_ADC0_MASK;</span><br><span class="line">  SIM-&gt;SCGC6 |= SIM_SCGC6_DMAMUX_MASK;</span><br><span class="line">  SIM-&gt;SCGC7 |= SIM_SCGC7_DMA_MASK; </span><br><span class="line">  </span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_SOURCE(kDmaRequestMux0Group1ADC0);</span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_ENBL_MASK;</span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;EEI |= DMA_EEI_EEI0_MASK;<span class="comment">//允许错误中断</span></span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SADDR=(<span class="type">uint32_t</span>)&amp;ADC0-&gt;R[<span class="number">0</span>]; <span class="comment">//设置源地址</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SOFF =<span class="number">0</span>; <span class="comment">//偏移量设置成1,每传输一个字节偏移一个字节</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].ATTR =<span class="number">0</span>; <span class="comment">//每次传输8bit</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].NBYTES_MLNO=<span class="number">1</span>; <span class="comment">//附循环一次</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SLAST=<span class="number">0</span>; <span class="comment">//传输结束后地址不偏移</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DADDR=(<span class="type">uint32_t</span>)&amp;result;<span class="comment">//设置目标地址</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DOFF=<span class="number">0</span>; <span class="comment">//偏移量设置成1,每传输一个字节偏移一个字节</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CITER_ELINKNO = (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">1</span>); <span class="comment">//主循环次数</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DLAST_SGA=<span class="number">0</span>; <span class="comment">//传输结束后不处理</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CSR |= (DMA_CSR_INTMAJOR_MASK); <span class="comment">//主循环后触发中断</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].BITER_ELINKNO = (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">1</span>); <span class="comment">//与CITER值相同</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CSR &amp;= ~DMA_CSR_DREQ_MASK;</span><br><span class="line">  </span><br><span class="line">  NVIC_EnableIRQ(DMA0_DMA16_IRQn); <span class="comment">//允许中断</span></span><br><span class="line">  <span class="comment">//NVIC_EnableIRQ(ADC0_IRQn);</span></span><br><span class="line">  DMA0-&gt;ERQ |= DMA_EARS_EDREQ_0_MASK; <span class="comment">//允许DMA传输</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ADC0-&gt;CFG1 &amp;=~ADC_CFG1_ADLPC_MASK;</span><br><span class="line">  ADC0-&gt;CFG1 |= ADC_CFG1_ADIV(<span class="number">0</span>);</span><br><span class="line">  ADC0-&gt;CFG1 |= ADC_CFG1_ADLSMP_MASK;</span><br><span class="line">  ADC0-&gt;CFG1 |= ADC_CFG1_MODE(<span class="number">0</span>);</span><br><span class="line">  ADC0-&gt;CFG1 |= ADC_CFG1_ADICLK(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  ADC0-&gt;CFG2 |= ADC_CFG2_ADLSTS(<span class="number">0</span>);</span><br><span class="line">  ADC0-&gt;CFG2 |= ADC_CFG2_ADHSC_MASK;</span><br><span class="line">  ADC0-&gt;CFG2 &amp;=~ADC_CFG2_ADACKEN_MASK;</span><br><span class="line">  ADC0-&gt;CFG2 |= ADC_CFG2_MUXSEL(<span class="number">0</span>);</span><br><span class="line">  ADC0-&gt;SC2 |= ADC_SC2_DMAEN_MASK;</span><br><span class="line">  </span><br><span class="line">  ADC0-&gt;SC1[<span class="number">0</span>]  = ADC_SC1_ADCH(<span class="number">0x0</span>);</span><br><span class="line">  <span class="comment">//ADC0-&gt;SC1[0] |= ADC_SC1_AIEN_MASK;</span></span><br><span class="line">  ADC0-&gt;SC1[<span class="number">0</span>] &amp;= ~ADC_SC1_DIFF_MASK;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//while((ADC0-&gt;SC1[0] &amp; ADC_SC1_COCO_MASK) != ADC_SC1_COCO_MASK);</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//result= (uint16_t)ADC0-&gt;R[0];</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(;;) &#123; <span class="comment">/* Infinite loop to avoid leaving the main function */</span></span><br><span class="line">    __asm(<span class="string">&quot;NOP&quot;</span>); <span class="comment">/* something to use as a breakpoint stop while looping */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA0_DMA16_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">gpio_pin_config_t</span> test;</span><br><span class="line">  test.outputLogic=<span class="number">0</span>;</span><br><span class="line">  test.pinDirection=kGPIO_DigitalOutput;</span><br><span class="line">  GPIO_PinInit(GPIOB,<span class="number">17</span>,&amp;test);</span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;INT |= DMA_INT_INT0_MASK;<span class="comment">//清中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC0_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CSR |=DMA_CSR_START_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;目前暂时未实现硬件dma触发,目前使用中断软件触发dma搬运,有待进一步改进.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;程序代码&quot;&gt;&lt;a href=&quot;#程序代码&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="ARM" scheme="https://blog.zzshub.cn/tags/ARM/"/>
    
    <category term="kinetis" scheme="https://blog.zzshub.cn/tags/kinetis/"/>
    
    <category term="register" scheme="https://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>kinetis KV58 HSADC模块食用指南</title>
    <link href="https://blog.zzshub.cn/2018/02/04/HSADC/"/>
    <id>https://blog.zzshub.cn/2018/02/04/HSADC/</id>
    <published>2018-02-04T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间不多,今天这个模块就简单说以下吧.</p></blockquote><h1 id="HSADC模块简单介绍"><a href="#HSADC模块简单介绍" class="headerlink" title="HSADC模块简单介绍"></a>HSADC模块简单介绍</h1><p>kv58有adc模块,也有个人感觉功能更强大的HSADC模块.kv58拥有两个12bit的hsadc模块,最高采集速度可以到5mhz,可以采集140khz~80mhz的信号.有AB通道可以同时采集,也就是说kv58可以做到4通道同时采集.另外还有支持通道乱序扫描可以做到一次触发扫描全部16个通道,相比于adc模块需要不断触发和ping-pong采集来说,hsadc的确做得更加出色.另外,hsadc模块所有通道都支持差分输入,相比于adc只有4个通道(kv58只有两个通道)支持差分输入,配置更加灵活.此外,还有过零中断,超限中断,各种错误中断等等,也可以实现adc的比较功能.</p><h1 id="HSADC模块结构简图"><a href="#HSADC模块结构简图" class="headerlink" title="HSADC模块结构简图"></a>HSADC模块结构简图</h1><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/HSADC/%E8%8D%89%E5%9B%BE.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/HSADC/%E8%8D%89%E5%9B%BE2.png"></p><p>可以看出,整个结构相对于adc来说更加简洁.值得注意的是8~17通道的复用情况,需要配置相关寄存器实现复用.</p><h1 id="HSADC软件触发中断-查询-示例"><a href="#HSADC软件触发中断-查询-示例" class="headerlink" title="HSADC软件触发中断(查询)示例"></a>HSADC软件触发中断(查询)示例</h1><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is template for main module created by MCUXpresso Project Generator. Enjoy!</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;board.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pin_mux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clock_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief Application entry point.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* Init board hardware. */</span></span><br><span class="line">  BOARD_InitBootPins();   <span class="comment">//设置管脚复用功能</span></span><br><span class="line">  BOARD_InitBootClocks(); </span><br><span class="line">  BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add your code here */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create RTOS task */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  SIM-&gt;SCGC5 |= SIM_SCGC5_HSADC0_MASK;  <span class="comment">//打开时钟</span></span><br><span class="line">  NVIC_EnableIRQ(HSADC0_CCA_IRQn);<span class="comment">//运行中断</span></span><br><span class="line">  <span class="comment">//HSADC0-&gt;PWR&amp;=~HSADC_PWR_PDA_MASK;</span></span><br><span class="line">  HSADC0-&gt;PWR=<span class="number">0</span>;<span class="comment">//PWR寄存器全0,AB通道上电,关闭延迟上电功能</span></span><br><span class="line">  HSADC0-&gt;CTRL1&amp;=~HSADC_CTRL1_SMODE_MASK;<span class="comment">//清寄存器</span></span><br><span class="line">  HSADC0-&gt;CTRL1|= HSADC_CTRL1_SMODE(<span class="number">4</span>);<span class="comment">//设置为默认模式</span></span><br><span class="line">  HSADC0-&gt;CTRL1|= HSADC_CTRL1_DMAENA_MASK;<span class="comment">//允许DMA</span></span><br><span class="line">  HSADC0-&gt;CTRL1|= HSADC_CTRL1_EOSIEA_MASK;  <span class="comment">//允许扫描完成中断发生</span></span><br><span class="line">  HSADC0-&gt;CTRL1&amp;=~HSADC_CTRL1_STOPA_MASK;<span class="comment">//关闭停止模式,打开通道</span></span><br><span class="line">  HSADC0-&gt;CTRL2|= HSADC_CTRL2_DIVA(<span class="number">2</span>);<span class="comment">//设置分频,HSRUN模式下频率不能高于80Mhz</span></span><br><span class="line">  </span><br><span class="line">  HSADC0-&gt;SDIS = <span class="number">0xFFFE</span>;<span class="comment">//设置扫描的组,只扫描一组</span></span><br><span class="line">  </span><br><span class="line">  HSADC0-&gt;CTRL3 |= HSADC_CTRL3_ADCRES(<span class="number">3</span>);<span class="comment">//设置精度为12bit</span></span><br><span class="line">  HSADC0-&gt;CTRL3 |= HSADC_CTRL3_DMASRC_MASK; <span class="comment">//DMA触发源</span></span><br><span class="line">  </span><br><span class="line">  HSADC0-&gt;SCINTEN |= <span class="number">1</span>;<span class="comment">//允许中断发生</span></span><br><span class="line">  </span><br><span class="line">  HSADC0-&gt;CTRL1 |= HSADC_CTRL1_STARTA_MASK; <span class="comment">//软件触发扫描</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//查询方式</span></span><br><span class="line">  <span class="comment">//while((HSADC0-&gt;RDY &amp; HSADC_RDY_RDY(0))!= HSADC_RDY_RDY(0));</span></span><br><span class="line">  <span class="comment">//result=HSADC0-&gt;RSLT[0];</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123; <span class="comment">/* Infinite loop to avoid leaving the main function */</span></span><br><span class="line">    <span class="comment">/* something to use as a breakpoint stop while looping */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HSADC0_CCA_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//中断方式</span></span><br><span class="line">  <span class="type">gpio_pin_config_t</span> test; <span class="comment">//开一个灯证明进入了中断</span></span><br><span class="line">  test.outputLogic=<span class="number">0</span>;</span><br><span class="line">  test.pinDirection=kGPIO_DigitalOutput;</span><br><span class="line">  GPIO_PinInit(GPIOB,<span class="number">17</span>,&amp;test);</span><br><span class="line">  result=HSADC0-&gt;RSLT[<span class="number">0</span>];</span><br><span class="line">  HSADC0-&gt;STAT |= HSADC_STAT_EOSIA_MASK ; <span class="comment">//清中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管脚分配"><a href="#管脚分配" class="headerlink" title="管脚分配"></a>管脚分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BOARD_InitPins</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  CLOCK_EnableClock(kCLOCK_PortB);                           <span class="comment">/* Port B Clock Gate Control: Clock enabled */</span></span><br><span class="line">  CLOCK_EnableClock(kCLOCK_PortE);                           <span class="comment">/* Port E Clock Gate Control: Clock enabled */</span></span><br><span class="line"></span><br><span class="line">  PORT_SetPinMux(PORTB, PIN17_IDX, kPORT_MuxAsGpio);         <span class="comment">/* PORTB17 (pin 63) is configured as PTB17 */</span></span><br><span class="line">  PORT_SetPinMux(PORTE, PIN16_IDX, kPORT_PinDisabledOrAnalog); <span class="comment">/* PORTE16 (pin 10) is configured as HSADC0A_CH0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h1>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;时间不多,今天这个模块就简单说以下吧.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;HSADC模块简单介绍&quot;&gt;&lt;a href=&quot;#HSADC模块简单介绍&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="ARM" scheme="https://blog.zzshub.cn/tags/ARM/"/>
    
    <category term="kinetis" scheme="https://blog.zzshub.cn/tags/kinetis/"/>
    
    <category term="register" scheme="https://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>kinetis KV58 DMA模块食用指南</title>
    <link href="https://blog.zzshub.cn/2018/01/30/DMAregister/"/>
    <id>https://blog.zzshub.cn/2018/01/30/DMAregister/</id>
    <published>2018-01-30T06:12:32.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NXP-Kinetis系列-KV58微控制器DMA模块食用指南"><a href="#NXP-Kinetis系列-KV58微控制器DMA模块食用指南" class="headerlink" title="NXP Kinetis系列 KV58微控制器DMA模块食用指南"></a>NXP Kinetis系列 KV58微控制器DMA模块食用指南</h1><blockquote><p>本文主要以KV58为例介绍kinetis系列微控制器的DMA模块的寄存器以及配置方法.</p></blockquote><h1 id="DMA是什么"><a href="#DMA是什么" class="headerlink" title="DMA是什么"></a>DMA是什么</h1><p> DMA全称直接内存访问(Direct Memory Access).是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通,而不需要依赖于 CPU 的大量中断负载.工作过程中不需要CPU干预,也不需要像中断处理方式那样需要保留现场,恢复现场之类的麻烦事,简单理解为一条直接连通外设与RAM的硬件通道,所以DMA技术可以提高系统运行效率（即CPU可以干其他的事去,算是一种简单的并行模式吧）.关于更多DMA的说明这里就不再多说,可以参考参考百度百科的说明<a href="https://baike.baidu.com/item/DMA/2385376?fr=aladdin">https://baike.baidu.com/item/DMA/2385376?fr=aladdin</a></p><h1 id="Kinetis的DMA"><a href="#Kinetis的DMA" class="headerlink" title="Kinetis的DMA"></a>Kinetis的DMA</h1><p>对于kinetis来说,DMA主要分为两大模块</p><ul><li><strong>DMAMUX</strong>    直接内存访问多路复用器(Direct Memory Access Multiplexer)</li><li><strong>eDMA</strong> 直接内存访问控制器(Enhanced Direct Memory Access)</li></ul><p>DMAMUX实质上是一个矩阵开关,负责将DMA的触发源映射到对应的DMA通道中.而eDMA才是真正搬运数据的模块,可以看到,kinetis的DMA前多了个<strong>e</strong>,代表Enhanced增强型.从这里也可以看出kinetis系列DMA的强大和灵活了.eDMA模块下又主要分为了两大部分: TCD传输控制器(Transfer Control Descriptor)用于控制每个通道的传输情况以及DMA引擎(eDMA engine)用于控制整个DMA引擎的状态,如下图所示 (<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 486</a>):</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89%E5%9B%BE.png"></p><p>DMA是如何搬运数据的可以用一下流程图来描述:</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/6374029876143.jpg"></p><p>如图所示,DMA触发源先经过DMAMUX将源分配到不同的DMA通道上,不同的DMA通道根据TCD寄存器的配置来将数据从源地址搬运到目标地址.那么这样来看,配置寄存器主要就分为以下几个步骤:</p><ul><li>打开有关的时钟(DMAMUX,eDMA,其他用到的模块如SPI的时钟)</li><li>配置DMAMUX触发源</li><li>配置eDMA引擎相关寄存器</li><li>配置TCD传输相关寄存器</li><li>打开相关外设的DMA使能</li><li>打开DMA中断等,开始DMA传输</li></ul><h1 id="DMAMUX模块"><a href="#DMAMUX模块" class="headerlink" title="DMAMUX模块"></a>DMAMUX模块</h1><p>前面说到DMAMUX是配置触发源到DMA通道,KV58微控制器有64个触发源,32个DMA通道.64个触发源如下(摘自CMSIS MKV58F24.h):</p><h2 id="DMAMUX触发源"><a href="#DMAMUX触发源" class="headerlink" title="DMAMUX触发源"></a>DMAMUX触发源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">dma_request_source</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    kDmaRequestMux0Disable          = <span class="number">0</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; DMAMUX TriggerDisabled. */</span></span><br><span class="line">    kDmaRequestMux0Reserved1        = <span class="number">1</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; Reserved1 */</span></span><br><span class="line">    kDmaRequestMux0UART0Rx          = <span class="number">2</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; UART0 Receive. */</span></span><br><span class="line">    kDmaRequestMux0UART0Tx          = <span class="number">3</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; UART0 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0UART1Rx          = <span class="number">4</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; UART1 Receive. */</span></span><br><span class="line">    kDmaRequestMux0UART1Tx          = <span class="number">5</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; UART1 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0PWM0WR0          = <span class="number">6</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; PWM0 Write Request 0. */</span></span><br><span class="line">    kDmaRequestMux0PWM0WR1          = <span class="number">7</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; PWM0 Write Request 1. */</span></span><br><span class="line">    kDmaRequestMux0PWM0WR2          = <span class="number">8</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; PWM0 Write Request 2. */</span></span><br><span class="line">    kDmaRequestMux0PWM0WR3          = <span class="number">9</span>|<span class="number">0x100</span>U,    <span class="comment">/**&lt; PWM0 Write Request 3. */</span></span><br><span class="line">    kDmaRequestMux0PWM0CP0          = <span class="number">10</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PWM0 Capture 0. */</span></span><br><span class="line">    kDmaRequestMux0PWM0CP1          = <span class="number">11</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PWM0 Capture 1. */</span></span><br><span class="line">    kDmaRequestMux0PWM0CP2          = <span class="number">12</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PWM0 Capture 2. */</span></span><br><span class="line">    kDmaRequestMux0PWM0CP3          = <span class="number">13</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PWM0 Capture 3. */</span></span><br><span class="line">    kDmaRequestMux0CAN0             = <span class="number">14</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CAN0. */</span></span><br><span class="line">    kDmaRequestMux0CAN1             = <span class="number">15</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CAN1. */</span></span><br><span class="line">    kDmaRequestMux0SPI0Rx           = <span class="number">16</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; SPI0 Receive. */</span></span><br><span class="line">    kDmaRequestMux0SPI0Tx           = <span class="number">17</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; SPI0 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0XBARAOUT0        = <span class="number">18</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; XBARA Output 0. */</span></span><br><span class="line">    kDmaRequestMux0XBARAOUT1        = <span class="number">19</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; XBARA Output 1. */</span></span><br><span class="line">    kDmaRequestMux0XBARAOUT2        = <span class="number">20</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; XBARA Output 2. */</span></span><br><span class="line">    kDmaRequestMux0XBARAOUT3        = <span class="number">21</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; XBARA Output 3. */</span></span><br><span class="line">    kDmaRequestMux0I2C0             = <span class="number">22</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; I2C0. */</span></span><br><span class="line">    kDmaRequestMux0Reserved23       = <span class="number">23</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved23 */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel0     = <span class="number">24</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C0V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel1     = <span class="number">25</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C1V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel2     = <span class="number">26</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C2V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel3     = <span class="number">27</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C3V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel4     = <span class="number">28</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C4V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel5     = <span class="number">29</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C5V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel6     = <span class="number">30</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C6V. */</span></span><br><span class="line">    kDmaRequestMux0FTM0Channel7     = <span class="number">31</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM0 C7V. */</span></span><br><span class="line">    kDmaRequestMux0FTM1Channel0     = <span class="number">32</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM1 C0V. */</span></span><br><span class="line">    kDmaRequestMux0FTM1Channel1     = <span class="number">33</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM1 C1V. */</span></span><br><span class="line">    kDmaRequestMux0CMP3             = <span class="number">34</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CMP3. */</span></span><br><span class="line">    kDmaRequestMux0Reserved35       = <span class="number">35</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved35 */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel0     = <span class="number">36</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C0V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel1     = <span class="number">37</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C1V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel2     = <span class="number">38</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C2V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel3     = <span class="number">39</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C3V. */</span></span><br><span class="line">    kDmaRequestMux0HSADC0A          = <span class="number">40</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; HSADC0. */</span></span><br><span class="line">    kDmaRequestMux0HSADC0B          = <span class="number">41</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; HSADC0. */</span></span><br><span class="line">    kDmaRequestMux0CMP0             = <span class="number">42</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CMP0. */</span></span><br><span class="line">    kDmaRequestMux0CMP1             = <span class="number">43</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CMP1. */</span></span><br><span class="line">    kDmaRequestMux0CMP2             = <span class="number">44</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; CMP2. */</span></span><br><span class="line">    kDmaRequestMux0DAC0             = <span class="number">45</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DAC0. */</span></span><br><span class="line">    kDmaRequestMux0Reserved46       = <span class="number">46</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved46 */</span></span><br><span class="line">    kDmaRequestMux0PDB1             = <span class="number">47</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PDB1. */</span></span><br><span class="line">    kDmaRequestMux0PDB0             = <span class="number">48</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PDB0. */</span></span><br><span class="line">    kDmaRequestMux0PortA            = <span class="number">49</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTA. */</span></span><br><span class="line">    kDmaRequestMux0PortB            = <span class="number">50</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTB. */</span></span><br><span class="line">    kDmaRequestMux0PortC            = <span class="number">51</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTC. */</span></span><br><span class="line">    kDmaRequestMux0PortD            = <span class="number">52</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTD. */</span></span><br><span class="line">    kDmaRequestMux0PortE            = <span class="number">53</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; PTE. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel4     = <span class="number">54</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C4V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel5     = <span class="number">55</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C5V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel6     = <span class="number">56</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C6V. */</span></span><br><span class="line">    kDmaRequestMux0FTM3Channel7     = <span class="number">57</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; FTM3 C7V. */</span></span><br><span class="line">    kDmaRequestMux0Reserved58       = <span class="number">58</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved58 */</span></span><br><span class="line">    kDmaRequestMux0Reserved59       = <span class="number">59</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; Reserved59 */</span></span><br><span class="line">    kDmaRequestMux0AlwaysOn60       = <span class="number">60</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0AlwaysOn61       = <span class="number">61</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0AlwaysOn62       = <span class="number">62</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0AlwaysOn63       = <span class="number">63</span>|<span class="number">0x100</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0Group1Disable    = <span class="number">0</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; DMAMUX TriggerDisabled. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved1  = <span class="number">1</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; Reserved1 */</span></span><br><span class="line">    kDmaRequestMux0Group1UART2Rx    = <span class="number">2</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; UART2 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART2Tx    = <span class="number">3</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; UART2 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART3Rx    = <span class="number">4</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; UART3 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART3Tx    = <span class="number">5</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; UART3 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1WR0    = <span class="number">6</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; PWM1 Write Request 0. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1WR1    = <span class="number">7</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; PWM1 Write Request 1. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1WR2    = <span class="number">8</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; PWM1 Write Request 2. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1WR3    = <span class="number">9</span>|<span class="number">0x200</span>U,    <span class="comment">/**&lt; PWM1 Write Request 3. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1CP0    = <span class="number">10</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; PWM1 Capture 0. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1CP1    = <span class="number">11</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; PWM1 Capture 1. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1CP2    = <span class="number">12</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; PWM1 Capture 2. */</span></span><br><span class="line">    kDmaRequestMux0Group1PWM1CP3    = <span class="number">13</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; PWM1 Capture 3. */</span></span><br><span class="line">    kDmaRequestMux0Group1CAN2       = <span class="number">14</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; CAN2. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved15 = <span class="number">15</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved15 */</span></span><br><span class="line">    kDmaRequestMux0Group1SPI1Rx     = <span class="number">16</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; SPI1 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1SPI1Tx     = <span class="number">17</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; SPI1 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved18 = <span class="number">18</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved18 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved19 = <span class="number">19</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved19 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved20 = <span class="number">20</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved20 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved21 = <span class="number">21</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved21 */</span></span><br><span class="line">    kDmaRequestMux0Group1I2C1       = <span class="number">22</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; I2C1. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved23 = <span class="number">23</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved23 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved24 = <span class="number">24</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved24 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved25 = <span class="number">25</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved25 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved26 = <span class="number">26</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved26 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved27 = <span class="number">27</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved27 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved28 = <span class="number">28</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved28 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved29 = <span class="number">29</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved29 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved30 = <span class="number">30</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved30 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved31 = <span class="number">31</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved31 */</span></span><br><span class="line">    kDmaRequestMux0Group1FTM2Channel0 = <span class="number">32</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; FTM2 C0V. */</span></span><br><span class="line">    kDmaRequestMux0Group1FTM2Channel1 = <span class="number">33</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; FTM2 C1V. */</span></span><br><span class="line">    kDmaRequestMux0Group1SPI2Rx     = <span class="number">34</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; SPI2 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1SPI2Tx     = <span class="number">35</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; SPI2 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1IEEE1588Timer0 = <span class="number">36</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; ENET IEEE 1588 timer 0. */</span></span><br><span class="line">    kDmaRequestMux0Group1IEEE1588Timer1 = <span class="number">37</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; ENET IEEE 1588 timer 1. */</span></span><br><span class="line">    kDmaRequestMux0Group1IEEE1588Timer2 = <span class="number">38</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; ENET IEEE 1588 timer 2. */</span></span><br><span class="line">    kDmaRequestMux0Group1IEEE1588Timer3 = <span class="number">39</span>|<span class="number">0x200</span>U, <span class="comment">/**&lt; ENET IEEE 1588 timer 3. */</span></span><br><span class="line">    kDmaRequestMux0Group1HSADC1A    = <span class="number">40</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; HSADC1. */</span></span><br><span class="line">    kDmaRequestMux0Group1HSADC1B    = <span class="number">41</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; HSADC1. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved42 = <span class="number">42</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved42 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved43 = <span class="number">43</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved43 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved44 = <span class="number">44</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved44 */</span></span><br><span class="line">    kDmaRequestMux0Group1ADC0       = <span class="number">45</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; ADC0. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved46 = <span class="number">46</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved46 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved47 = <span class="number">47</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved47 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved48 = <span class="number">48</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved48 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved49 = <span class="number">49</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved49 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved50 = <span class="number">50</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved50 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved51 = <span class="number">51</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved51 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved52 = <span class="number">52</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved52 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved53 = <span class="number">53</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved53 */</span></span><br><span class="line">    kDmaRequestMux0Group1UART4Rx    = <span class="number">54</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; UART4 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART4Tx    = <span class="number">55</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; UART4 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART5Rx    = <span class="number">56</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; UART5 Receive. */</span></span><br><span class="line">    kDmaRequestMux0Group1UART5Tx    = <span class="number">57</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; UART5 Transmit. */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved58 = <span class="number">58</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved58 */</span></span><br><span class="line">    kDmaRequestMux0Group1Reserved59 = <span class="number">59</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; Reserved59 */</span></span><br><span class="line">    kDmaRequestMux0Group1AlwaysOn60 = <span class="number">60</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0Group1AlwaysOn61 = <span class="number">61</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0Group1AlwaysOn62 = <span class="number">62</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">    kDmaRequestMux0Group1AlwaysOn63 = <span class="number">63</span>|<span class="number">0x200</span>U,   <span class="comment">/**&lt; DMAMUX Always Enabled slot. */</span></span><br><span class="line">&#125; <span class="type">dma_request_source_t</span>;</span><br></pre></td></tr></table></figure><p>我们可以看到,触发源已经涵盖了大部分外设,需要注意的是60~63号触发源,这几个是常开触发源,主要可以用于需要一直触发快速搬运的地方或者是从内存搬运到内存的情况,官方解释如下((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 480</a>)):</p><blockquote><h2 id="25-5-3-Always-enabled-DMA-sources"><a href="#25-5-3-Always-enabled-DMA-sources" class="headerlink" title="25.5.3 Always-enabled DMA sources"></a>25.5.3 Always-enabled DMA sources</h2><p>In addition to the peripherals that can be used as DMA sources, there are four additional DMA sources that are always enabled. Unlike the peripheral DMA sources, where the peripheral controls the flow of data during DMA transfers, the sources that are always enabled provide no such “throttling” of the data transfers. These sources are most useful in the following cases:</p><ul><li>Performing DMA transfers to&#x2F;from GPIO—Moving data from&#x2F;to one or more GPIO pins, either unthrottled (that is, as fast as possible), or periodically (using the DMA triggering capability). </li><li>Performing DMA transfers from memory to memory—Moving data from memory to memory, typically as fast as possible, sometimes with software activation.</li><li>Performing DMA transfers from memory to the external bus, or vice-versa—Similar to memory to memory transfers, this is typically done as quickly as possible.</li><li>Any DMA transfer that requires software activation—Any DMA transfer that should be explicitly started by software.</li></ul></blockquote><h2 id="DMAMUX寄存器"><a href="#DMAMUX寄存器" class="headerlink" title="DMAMUX寄存器"></a>DMAMUX寄存器</h2><p>寄存器定义在MKV58F24.h中定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   -- DMAMUX Peripheral Access Layer</span></span><br><span class="line"><span class="comment">   ---------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup DMAMUX_Peripheral_Access_Layer DMAMUX Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** DMAMUX - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> CHCFG[<span class="number">32</span>];                          <span class="comment">/**&lt; Channel Configuration register, array offset: 0x0, array step: 0x1 */</span></span><br><span class="line">&#125; DMAMUX_Type;</span><br></pre></td></tr></table></figure><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%892%E5%9B%BE.png"></p><p>((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 477</a>))</p><p>可以看到非常的简单,每一个8位寄存器对应着每一个DMA通道.<br>ENBL用于开启相应的复用开关,SOURCE对应着前面枚举的64个DMA触发源.有点特殊的是TRIG,这个可以使用PIT定时器周期性触发DMA,不过只有前4个DMA通道支持该功能,关于详细的部分可以在PIT定时器的相关章节找到.</p><h2 id="DMAMUX配置顺序"><a href="#DMAMUX配置顺序" class="headerlink" title="DMAMUX配置顺序"></a>DMAMUX配置顺序</h2><ul><li>清空寄存器</li><li>选择相关的复用通道配置需要的触发源</li><li>选择是否需要周期触发功能</li><li>打开该复用通道</li></ul><p>以下是官方的解释((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 481</a>)):</p><blockquote><ul><li>Determine with which DMA channel the source will be associated. Note that only the first 4 DMA channels have periodic triggering capability.</li><li>Clear the CHCFG[ENBL] and CHCFG[TRIG] fields of the DMA channel.</li><li>Ensure that the DMA channel is properly configured in the DMA. The DMA channel may be enabled at this point. </li><li>Configure the corresponding timer. </li><li>Select the source to be routed to the DMA channel. Write to the corresponding CHCFG register, ensuring that the CHCFG[ENBL] and CHCFG[TRIG] fields are set.</li></ul></blockquote><h2 id="DMAMUX配置实例"><a href="#DMAMUX配置实例" class="headerlink" title="DMAMUX配置实例"></a>DMAMUX配置实例</h2><p>以下是一个DMAMUX配置的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SIM-&gt;SCGC6 |= SIM_SCGC6_DMAMUX_MASK; <span class="comment">//打开DMAMUX时钟</span></span><br><span class="line">DMAMUX-&gt;CHCFG[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//清空寄存器通道0</span></span><br><span class="line">DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_SOURCE(kDmaRequestMux0AlwaysOn63);<span class="comment">//配置63号源到通道0</span></span><br><span class="line">DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_ENBL_MASK;<span class="comment">//使能通道</span></span><br></pre></td></tr></table></figure><h1 id="eDMA模块"><a href="#eDMA模块" class="headerlink" title="eDMA模块"></a>eDMA模块</h1><p>接下来才是重头戏,eDMA模块.</p><h2 id="eDMA-特性"><a href="#eDMA-特性" class="headerlink" title="eDMA 特性"></a>eDMA 特性</h2><p>下面介绍下Kinetis的eDMA的一些特性，有点多，就挑重点和特色的来说了：</p><ul><li>16个独立可配置的DMA通道，其中前四个通道可配置成周期性触发(需要用到PIT模块).</li><li>52个外设触发slots(这个我担心翻译不好误人子弟了就直接用该单词替代了,用过Qt的人都这是个槽的概念,大家权当触发源来理解吧),10个直通slots,每一个slot可以通过软件编程路由到16个DMA通道中的任意一个(这个通过配置DMAMUX_CONFIGn得到).</li><li>独立可编程的源地址、目标地址和传输宽度(8bit,16bit,32bit,另外支持16byte的缓存),支持外设到RAM,RAM到外设,RAM到RAM之间的传输.<br>*　每一个通道都有一个11个寄存器的TCD（Tranfer control descripter），注意这11个寄存器（包括16位和32位宽度的寄存器）才是我们编写驱动的重点对象．</li><li>固定的优先级模式和时间轮询（round-robin）优先级模式（注意：如果不通过软件设置优先级的话，系统默认为每个通道的优先级等于它的通道号，即0通道的优先级为0，且优先级号越小，其优先级越低）</li><li>每个通道包括了三个中断标志，即DMA半传输完成标志、DMA传输完成标志和DMA传输出错标志，3个标志逻辑或成一个中断请求（所以如果都使能了，那可以通过查询相关标志寄存器来判断当前的中断类型）.</li><li>可软件中断取消DMA传输（通过配置DMA_CR_CX位）.</li></ul><p>以下是官方的解释((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 487</a>)):</p><blockquote><h2 id="26-1-3-Features"><a href="#26-1-3-Features" class="headerlink" title="26.1.3 Features"></a>26.1.3 Features</h2><p>The eDMA is a highly programmable data-transfer engine optimized to minimize any required intervention from the host processor. It is intended for use in applications where the data size to be transferred is statically known and not defined within the transferred data itself. The eDMA module features:</p><ul><li>All data movement via dual-address transfers: read from source, write to destination</li><li>Programmable source and destination addresses and transfer size<br>*Support for enhanced addressing modes</li><li>32-channel implementation that performs complex data transfers with minimal intervention from a host processor<br>*　Internal data buffer, used as temporary storage to support 16- and 32-byte transfers </li><li>Connections to the crossbar switch for bus mastering the data movement </li><li>Transfer control descriptor (TCD) organized to support two-deep, nested transfer operations </li><li>32-byte TCD stored in local memory for each channel </li><li>An inner data transfer loop defined by a minor byte transfer count<br>*An outer data transfer loop defined by a major iteration count </li><li>Channel activation via one of three methods: </li><li>Explicit software initiation </li><li>Initiation via a channel-to-channel linking mechanism for continuous transfers </li><li>Peripheral-paced hardware requests, one per channel </li><li>Fixed-priority and round-robin channel arbitration </li><li>Channel completion reported via programmable interrupt requests </li><li>One interrupt per channel, which can be asserted at completion of major iteration count </li><li>Programmable error terminations per channel and logically summed together to form one error interrupt to the interrupt controller </li><li>Programmable support for scatter&#x2F;gather DMA processing </li><li>Support for complex data structures</li></ul></blockquote><blockquote><p>In the discussion of this module, n is used to reference the channel number.</p></blockquote><h2 id="eDMA-channel分组"><a href="#eDMA-channel分组" class="headerlink" title="eDMA channel分组:"></a>eDMA channel分组:</h2><p>KV58中DMA通道分为两组</p><ul><li>group0 0~15通道</li><li>group1 16~31通道<br>不同通道需要设置成不同的权值,这是非常容易忽略的地方.</li></ul><h2 id="主循环和附循环"><a href="#主循环和附循环" class="headerlink" title="主循环和附循环"></a>主循环和附循环</h2><p>数据的传送分为主循环 （ major loop ） 和副循环 （ minor loop ）. 如何理解这两个概念呢。 我们不妨假设用软件来实现有规律的顺序数据传送，使用 C 语言来实现的话，可以用 for 循 环。好比用两层嵌套的 for 循环来实现。如使用 DMA 做同样的工作，过程是相同的，外层 的循环又称主循环，即 major loop 。内层循环称为副循环，即 minor loop 。 major loop 循环 一次，可能需要 minor loop 循环多次。每个 minor loop 循环都需要 DMA 源发来请求或者通 过软件请求。 每个 minor loop 传送完毕， 对应的 DMA 通道就进入空闲模式， 等待下一次 DMA 请求。当所有 DMA 传送完毕，即置 DONE 标志，并且可以通过设置选择传送完毕是否触发 中断。</p><h2 id="eDMA寄存器介绍"><a href="#eDMA寄存器介绍" class="headerlink" title="eDMA寄存器介绍"></a>eDMA寄存器介绍</h2><p>以下是eDMA模块寄存器表(摘自MKV58F24.h):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   -- DMA Peripheral Access Layer</span></span><br><span class="line"><span class="comment">   ---------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup DMA_Peripheral_Access_Layer DMA Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** DMA - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR;                                <span class="comment">/**&lt; Control Register, offset: 0x0 */</span></span><br><span class="line">  __I  <span class="type">uint32_t</span> ES;                                <span class="comment">/**&lt; Error Status Register, offset: 0x4 */</span></span><br><span class="line">       <span class="type">uint8_t</span> RESERVED_0[<span class="number">4</span>];</span><br><span class="line">  __IO <span class="type">uint32_t</span> ERQ;                               <span class="comment">/**&lt; Enable Request Register, offset: 0xC */</span></span><br><span class="line">       <span class="type">uint8_t</span> RESERVED_1[<span class="number">4</span>];</span><br><span class="line">  __IO <span class="type">uint32_t</span> EEI;                               <span class="comment">/**&lt; Enable Error Interrupt Register, offset: 0x14 */</span></span><br><span class="line">  __O  <span class="type">uint8_t</span> CEEI;                               <span class="comment">/**&lt; Clear Enable Error Interrupt Register, offset: 0x18 */</span></span><br><span class="line">  __O  <span class="type">uint8_t</span> SEEI;                               <span class="comment">/**&lt; Set Enable Error Interrupt Register, offset: 0x19 */</span></span><br><span class="line">  __O  <span class="type">uint8_t</span> CERQ;                               <span class="comment">/**&lt; Clear Enable Request Register, offset: 0x1A */</span></span><br><span class="line">  __O  <span class="type">uint8_t</span> SERQ;                               <span class="comment">/**&lt; Set Enable Request Register, offset: 0x1B */</span></span><br><span class="line">  __O  <span class="type">uint8_t</span> CDNE;                               <span class="comment">/**&lt; Clear DONE Status Bit Register, offset: 0x1C */</span></span><br><span class="line">  __O  <span class="type">uint8_t</span> SSRT;                               <span class="comment">/**&lt; Set START Bit Register, offset: 0x1D */</span></span><br><span class="line">  __O  <span class="type">uint8_t</span> CERR;                               <span class="comment">/**&lt; Clear Error Register, offset: 0x1E */</span></span><br><span class="line">  __O  <span class="type">uint8_t</span> CINT;                               <span class="comment">/**&lt; Clear Interrupt Request Register, offset: 0x1F */</span></span><br><span class="line">       <span class="type">uint8_t</span> RESERVED_2[<span class="number">4</span>];</span><br><span class="line">  __IO <span class="type">uint32_t</span> INT;                               <span class="comment">/**&lt; Interrupt Request Register, offset: 0x24 */</span></span><br><span class="line">       <span class="type">uint8_t</span> RESERVED_3[<span class="number">4</span>];</span><br><span class="line">  __IO <span class="type">uint32_t</span> ERR;                               <span class="comment">/**&lt; Error Register, offset: 0x2C */</span></span><br><span class="line">       <span class="type">uint8_t</span> RESERVED_4[<span class="number">4</span>];</span><br><span class="line">  __I  <span class="type">uint32_t</span> HRS;                               <span class="comment">/**&lt; Hardware Request Status Register, offset: 0x34 */</span></span><br><span class="line">       <span class="type">uint8_t</span> RESERVED_5[<span class="number">12</span>];</span><br><span class="line">  __IO <span class="type">uint32_t</span> EARS;                              <span class="comment">/**&lt; Enable Asynchronous Request in Stop Register, offset: 0x44 */</span></span><br><span class="line">       <span class="type">uint8_t</span> RESERVED_6[<span class="number">184</span>];</span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI3;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x100 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI2;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x101 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI1;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x102 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI0;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x103 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI7;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x104 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI6;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x105 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI5;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x106 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI4;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x107 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI11;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x108 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI10;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x109 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI9;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10A */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI8;                            <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10B */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI15;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10C */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI14;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10D */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI13;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10E */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI12;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x10F */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI19;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x110 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI18;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x111 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI17;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x112 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI16;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x113 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI23;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x114 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI22;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x115 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI21;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x116 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI20;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x117 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI27;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x118 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI26;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x119 */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI25;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11A */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI24;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11B */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI31;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11C */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI30;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11D */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI29;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11E */</span></span><br><span class="line">  __IO <span class="type">uint8_t</span> DCHPRI28;                           <span class="comment">/**&lt; Channel n Priority Register, offset: 0x11F */</span></span><br><span class="line">       <span class="type">uint8_t</span> RESERVED_7[<span class="number">3808</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span>                                         <span class="comment">/* offset: 0x1000, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> SADDR;                             <span class="comment">/**&lt; TCD Source Address, array offset: 0x1000, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="type">uint16_t</span> SOFF;                              <span class="comment">/**&lt; TCD Signed Source Address Offset, array offset: 0x1004, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="type">uint16_t</span> ATTR;                              <span class="comment">/**&lt; TCD Transfer Attributes, array offset: 0x1006, array step: 0x20 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>                                          <span class="comment">/* offset: 0x1008, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="type">uint32_t</span> NBYTES_MLNO;                       <span class="comment">/**&lt; TCD Minor Byte Count (Minor Loop Mapping Disabled), array offset: 0x1008, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="type">uint32_t</span> NBYTES_MLOFFNO;                    <span class="comment">/**&lt; TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled), array offset: 0x1008, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="type">uint32_t</span> NBYTES_MLOFFYES;                   <span class="comment">/**&lt; TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled), array offset: 0x1008, array step: 0x20 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    __IO <span class="type">uint32_t</span> SLAST;                             <span class="comment">/**&lt; TCD Last Source Address Adjustment, array offset: 0x100C, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> DADDR;                             <span class="comment">/**&lt; TCD Destination Address, array offset: 0x1010, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="type">uint16_t</span> DOFF;                              <span class="comment">/**&lt; TCD Signed Destination Address Offset, array offset: 0x1014, array step: 0x20 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>                                          <span class="comment">/* offset: 0x1016, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="type">uint16_t</span> CITER_ELINKNO;                     <span class="comment">/**&lt; TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled), array offset: 0x1016, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="type">uint16_t</span> CITER_ELINKYES;                    <span class="comment">/**&lt; TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled), array offset: 0x1016, array step: 0x20 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    __IO <span class="type">uint32_t</span> DLAST_SGA;                         <span class="comment">/**&lt; TCD Last Destination Address Adjustment/Scatter Gather Address, array offset: 0x1018, array step: 0x20 */</span></span><br><span class="line">    __IO <span class="type">uint16_t</span> CSR;                               <span class="comment">/**&lt; TCD Control and Status, array offset: 0x101C, array step: 0x20 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>                                          <span class="comment">/* offset: 0x101E, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="type">uint16_t</span> BITER_ELINKNO;                     <span class="comment">/**&lt; TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled), array offset: 0x101E, array step: 0x20 */</span></span><br><span class="line">      __IO <span class="type">uint16_t</span> BITER_ELINKYES;                    <span class="comment">/**&lt; TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled), array offset: 0x101E, array step: 0x20 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; TCD[<span class="number">32</span>];</span><br><span class="line">&#125; DMA_Type;</span><br></pre></td></tr></table></figure><h3 id="首先介绍非常重要的TCD传输控制块寄存器"><a href="#首先介绍非常重要的TCD传输控制块寄存器" class="headerlink" title="首先介绍非常重要的TCD传输控制块寄存器"></a>首先介绍非常重要的TCD传输控制块寄存器</h3><p>以下是TCD控制块的寄存器分布((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 489</a>)):</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89%E5%9B%BE2.png"></p><h4 id="TCD-Source-Address-DMA-TCDn-SADDR"><a href="#TCD-Source-Address-DMA-TCDn-SADDR" class="headerlink" title="TCD Source Address (DMA_TCDn_SADDR)"></a>TCD Source Address (DMA_TCDn_SADDR)</h4><p>存放需要搬运的数据的源地址</p><h4 id="TCD-Signed-Source-Address-Offset-DMA-TCDn-SOFF"><a href="#TCD-Signed-Source-Address-Offset-DMA-TCDn-SOFF" class="headerlink" title="TCD Signed Source Address Offset (DMA_TCDn_SOFF)"></a>TCD Signed Source Address Offset (DMA_TCDn_SOFF)</h4><p>源地址传输一个数据之后的偏移量<br>(Sign-extended offset applied to the current source address to form the next-state value as each source read is completed.)</p><h4 id="TCD-Transfer-Attributes-DMA-TCDn-ATTR"><a href="#TCD-Transfer-Attributes-DMA-TCDn-ATTR" class="headerlink" title="TCD Transfer Attributes (DMA_TCDn_ATTR)"></a>TCD Transfer Attributes (DMA_TCDn_ATTR)</h4><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%8922%E5%9B%BE.png"></p><p>主要说其中的SSIZE和DSIZE,分别表示每一次传输的源数据宽度和目的数据宽度<br>其中000表示8bit, 001表示16bit, 010表示32bit.</p><h4 id="TCD-Minor-Byte-Count-Minor-Loop-Mapping-Disabled-DMA-TCDn-NBYTES-MLNO"><a href="#TCD-Minor-Byte-Count-Minor-Loop-Mapping-Disabled-DMA-TCDn-NBYTES-MLNO" class="headerlink" title="TCD Minor Byte Count (Minor Loop Mapping Disabled) (DMA_TCDn_NBYTES_MLNO)"></a>TCD Minor Byte Count (Minor Loop Mapping Disabled) (DMA_TCDn_NBYTES_MLNO)</h4><p>仅介绍这一种情况,即附循环映射被禁止的情况,寄存器的值表示一次附循环搬移的数据大小,如果为0则表示搬运4GB.</p><h4 id="TCD-Last-Source-Address-Adjustment-DMA-TCDn-SLAST"><a href="#TCD-Last-Source-Address-Adjustment-DMA-TCDn-SLAST" class="headerlink" title="TCD Last Source Address Adjustment (DMA_TCDn_SLAST)"></a>TCD Last Source Address Adjustment (DMA_TCDn_SLAST)</h4><p>该寄存器控制当主循环结束后源地址的偏移情况,寄存器值可为正或负,0表示不偏移.</p><h4 id="TCD-Destination-Address-DMA-TCDn-DADDR"><a href="#TCD-Destination-Address-DMA-TCDn-DADDR" class="headerlink" title="TCD Destination Address (DMA_TCDn_DADDR)"></a>TCD Destination Address (DMA_TCDn_DADDR)</h4><p>储存目标地址</p><h4 id="TCD-Signed-Destination-Address-Offset-DMA-TCDn-DOFF"><a href="#TCD-Signed-Destination-Address-Offset-DMA-TCDn-DOFF" class="headerlink" title="TCD Signed Destination Address Offset (DMA_TCDn_DOFF)"></a>TCD Signed Destination Address Offset (DMA_TCDn_DOFF)</h4><p>目标地址传输一个数据之后的偏移量</p><h4 id="TCD-Current-Minor-Loop-Link-Major-Loop-Count-Channel-Linking-Disabled-DMA-TCDn-CITER-ELINKNO"><a href="#TCD-Current-Minor-Loop-Link-Major-Loop-Count-Channel-Linking-Disabled-DMA-TCDn-CITER-ELINKNO" class="headerlink" title="TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (DMA_TCDn_CITER_ELINKNO)"></a>TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (DMA_TCDn_CITER_ELINKNO)</h4><p>仅介绍这一种情况,也就是通道之间的联系被禁止的情况.该寄存器用于表示主循环的次数.</p><h4 id="TCD-Beginning-Minor-Loop-Link-Major-Loop-Count-Channel-Linking-Disabled-DMA-TCDn-BITER-ELINKNO"><a href="#TCD-Beginning-Minor-Loop-Link-Major-Loop-Count-Channel-Linking-Disabled-DMA-TCDn-BITER-ELINKNO" class="headerlink" title="TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (DMA_TCDn_BITER_ELINKNO)"></a>TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (DMA_TCDn_BITER_ELINKNO)</h4><p>仅介绍这一种情况,该寄存器应与<code>CITER</code>寄存器配置成相同的值</p><h4 id="TCD-Last-Destination-Address-Adjustment-Scatter-Gather-Address-DMA-TCDn-DLASTSGA"><a href="#TCD-Last-Destination-Address-Adjustment-Scatter-Gather-Address-DMA-TCDn-DLASTSGA" class="headerlink" title="TCD Last Destination Address Adjustment&#x2F;Scatter Gather Address (DMA_TCDn_DLASTSGA)"></a>TCD Last Destination Address Adjustment&#x2F;Scatter Gather Address (DMA_TCDn_DLASTSGA)</h4><p>该寄存器控制当主循环结束后目标地址的偏移情况,寄存器值可为正或负,0表示不偏移.</p><h4 id="TCD-Control-and-Status-DMA-TCDn-CSR"><a href="#TCD-Control-and-Status-DMA-TCDn-CSR" class="headerlink" title="TCD Control and Status (DMA_TCDn_CSR)"></a>TCD Control and Status (DMA_TCDn_CSR)</h4><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89%E5%9B%BE4.png"></p><p>INTMAJOR: 允许中断<br>START:软件触发传输</p><h2 id="eDMA引擎寄存器"><a href="#eDMA引擎寄存器" class="headerlink" title="eDMA引擎寄存器"></a>eDMA引擎寄存器</h2><h4 id="Control-Register-DMA-CR"><a href="#Control-Register-DMA-CR" class="headerlink" title="Control Register (DMA_CR)"></a>Control Register (DMA_CR)</h4><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89111%E5%9B%BE.png"></p><p>最需要注意的就是<code>GRP1PRI</code>和<code>GRP0PRI</code>需要设置成不同的权值</p><h4 id="Error-Status-Register-DMA-ES"><a href="#Error-Status-Register-DMA-ES" class="headerlink" title="Error Status Register (DMA_ES)"></a>Error Status Register (DMA_ES)</h4><p>各种错误标志位寄存器</p><h4 id="Enable-Request-Register-DMA-ERQ"><a href="#Enable-Request-Register-DMA-ERQ" class="headerlink" title="Enable Request Register (DMA_ERQ)"></a>Enable Request Register (DMA_ERQ)</h4><p>允许传输寄存器</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%891234%E5%9B%BE.png"></p><h4 id="Channel-n-Priority-Register-DMA-DCHPRIn"><a href="#Channel-n-Priority-Register-DMA-DCHPRIn" class="headerlink" title="Channel n Priority Register (DMA_DCHPRIn)"></a>Channel n Priority Register (DMA_DCHPRIn)</h4><p>优先级分组寄存器,0是最低优先级.</p><h1 id="DMA模块初始化过程"><a href="#DMA模块初始化过程" class="headerlink" title="DMA模块初始化过程"></a>DMA模块初始化过程</h1><ul><li>配置CR寄存器</li><li>配置通道优先级</li><li>配置TCD传输控制块</li><li>使能传输控制</li><li>配置外设允许DMA触发或者配置软件触发</li></ul><p>以下是官方解释((<a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">摘自<strong>KV5x Sub-Family Reference Manual</strong> Page 575</a>)):</p><blockquote><h3 id="To-initialize-the-eDMA"><a href="#To-initialize-the-eDMA" class="headerlink" title="To initialize the eDMA:"></a>To initialize the eDMA:</h3><ul><li>Write to the CR if a configuration other than the default is desired. </li><li>Write the channel priority levels to the DCHPRIn registers if a configuration other than the default is desired. </li><li>Enable error interrupts in the EEI register if so desired.</li><li>Write the 32-byte TCD for each channel that may request service.</li><li>Enable any hardware service requests via the ERQ register.</li><li>Request channel service via.</li></ul></blockquote><h1 id="DMA从内存到内存传输实例"><a href="#DMA从内存到内存传输实例" class="headerlink" title="DMA从内存到内存传输实例"></a>DMA从内存到内存传输实例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* Init board hardware. */</span></span><br><span class="line">  BOARD_InitBootPins();</span><br><span class="line">  BOARD_InitBootClocks();</span><br><span class="line">  BOARD_InitDebugConsole();</span><br><span class="line"></span><br><span class="line">  SIM-&gt;SCGC7 |= SIM_SCGC7_DMA_MASK;   <span class="comment">//打开DMA时钟</span></span><br><span class="line">  SIM-&gt;SCGC6 |= SIM_SCGC6_DMAMUX_MASK;<span class="comment">//打开DMAMUX时钟</span></span><br><span class="line"></span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//清寄存器</span></span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_SOURCE(kDmaRequestMux0AlwaysOn63);<span class="comment">//配置通道0的源为63号源</span></span><br><span class="line">  DMAMUX-&gt;CHCFG[<span class="number">0</span>] |= DMAMUX_CHCFG_ENBL_MASK;/使能通道</span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;CR=<span class="number">0</span>;<span class="comment">//清寄存器</span></span><br><span class="line">  DMA0-&gt;CR |= DMA_CR_GRP0PRI_MASK;<span class="comment">//设置group0的优先级为1</span></span><br><span class="line">  DMA0-&gt;EEI |= DMA_EEI_EEI0_MASK;<span class="comment">//允许错误中断</span></span><br><span class="line">  DMA0-&gt;INT |= DMA_INT_INT0_MASK;<span class="comment">//清中断标志位</span></span><br><span class="line">  </span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SADDR=(<span class="type">uint32_t</span>)sendtext; <span class="comment">//设置源地址</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SOFF=<span class="number">1</span>; <span class="comment">//偏移量设置成1,每传输一个字节偏移一个字节</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].ATTR =<span class="number">0</span>; <span class="comment">//每次传输8bit</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].NBYTES_MLNO=<span class="number">1</span>; <span class="comment">//附循环一次</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].SLAST=<span class="number">0</span>; <span class="comment">//传输结束后地址不偏移</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DADDR=(<span class="type">uint32_t</span>)receivetext;<span class="comment">//设置目标地址</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DOFF=<span class="number">1</span>; /偏移量设置成<span class="number">1</span>,每传输一个字节偏移一个字节</span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CITER_ELINKNO = (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="keyword">sizeof</span>(sendtext)<span class="number">-1</span>); <span class="comment">//主循环次数</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].DLAST_SGA=<span class="number">0</span>; <span class="comment">//传输结束后不处理</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].CSR |= (DMA_CSR_INTMAJOR_MASK); <span class="comment">//主循环后触发中断</span></span><br><span class="line">  DMA0-&gt;TCD[<span class="number">0</span>].BITER_ELINKNO = (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="keyword">sizeof</span>(sendtext)<span class="number">-1</span>); <span class="comment">//与CITER值相同</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  NVIC_EnableIRQ(DMA0_DMA16_IRQn); <span class="comment">//允许中断</span></span><br><span class="line">  DMA0-&gt;ERQ |= DMA_EARS_EDREQ_0_MASK; <span class="comment">//允许DMA传输</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际效果:</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%89456%E5%9B%BE.png"></p><p>传输前receivetext为空</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E5%AF%84%E5%AD%98%E5%99%A8%E9%A3%9F%E7%94%A8/DMA/%E8%8D%8912344%E5%9B%BE.png"></p><p>传输后receivetext值和sendtext相同</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;NXP-Kinetis系列-KV58微控制器DMA模块食用指南&quot;&gt;&lt;a href=&quot;#NXP-Kinetis系列-KV58微控制器DMA模块食用指南&quot; class=&quot;headerlink&quot; title=&quot;NXP Kinetis系列</summary>
        
      
    
    
    
    
    <category term="ARM" scheme="https://blog.zzshub.cn/tags/ARM/"/>
    
    <category term="kinetis" scheme="https://blog.zzshub.cn/tags/kinetis/"/>
    
    <category term="register" scheme="https://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>ARM寄存器食用感受</title>
    <link href="https://blog.zzshub.cn/2018/01/22/KinetisRegistar/"/>
    <id>https://blog.zzshub.cn/2018/01/22/KinetisRegistar/</id>
    <published>2018-01-22T15:41:34.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARM寄存器食用感受"><a href="#ARM寄存器食用感受" class="headerlink" title="ARM寄存器食用感受"></a>ARM寄存器食用感受</h1><blockquote><p>最近研究NXP新推出的<strong>kinetis KV58</strong>微控制器,用的是NXP官方推出的MCUXpresso的SDK,研究后发现并没有想象的好用,故决定还是手撸寄存器好了.</p></blockquote><h1 id="MKV58F24-h"><a href="#MKV58F24-h" class="headerlink" title="MKV58F24.h"></a>MKV58F24.h</h1><p>首先需要关注这个头文件,该头文件中包含了KV58微控制器所有寄存器地址,是最重要的头文件.下面以<strong>GPIO</strong>为例,介绍一下撸寄存器的方法.操作每个模块主要可以分为3部分.</p><ul><li>地址定义</li><li>寄存器结构体定义</li><li>操作掩码宏定义</li></ul><p>此外,手册中还定义了其他内容,如中断向量表,DMA触发源表,编译器设置,版本信息等等.</p><h2 id="地址定义"><a href="#地址定义" class="headerlink" title="地址定义"></a>地址定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @&#125;</span></span><br><span class="line"><span class="comment"> */</span> <span class="comment">/* end of group GPIO_Register_Masks */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO - Peripheral instance base addresses */</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOA base address */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BASE                               (0x400FF000u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOA base pointer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA                                    ((GPIO_Type *)GPIOA_BASE)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOB base address */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE                               (0x400FF040u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOB base pointer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB                                    ((GPIO_Type *)GPIOB_BASE)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOC base address */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_BASE                               (0x400FF080u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOC base pointer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC                                    ((GPIO_Type *)GPIOC_BASE)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOD base address */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_BASE                               (0x400FF0C0u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOD base pointer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD                                    ((GPIO_Type *)GPIOD_BASE)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOE base address */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_BASE                               (0x400FF100u)</span></span><br><span class="line"><span class="comment">/** Peripheral GPIOE base pointer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE                                    ((GPIO_Type *)GPIOE_BASE)</span></span><br><span class="line"><span class="comment">/** Array initializer of GPIO peripheral base addresses */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_BASE_ADDRS                          &#123; GPIOA_BASE, GPIOB_BASE, GPIOC_BASE, GPIOD_BASE, GPIOE_BASE &#125;</span></span><br><span class="line"><span class="comment">/** Array initializer of GPIO peripheral base pointers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_BASE_PTRS                           &#123; GPIOA, GPIOB, GPIOC, GPIOD, GPIOE &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @&#125;</span></span><br><span class="line"><span class="comment"> */</span> <span class="comment">/* end of group GPIO_Peripheral_Access_Layer */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 可以看出,文件中定义了各gpio寄存器的首地址<code>GPIOx_BASE</code>,定义了指向首地址的指针<code>GPIOx</code>.使用宏定义的方式可以显著减少代码量,采用首地址加偏移量的方式就可以访问各个寄存器了.</p><hr><h2 id="寄存器结构体"><a href="#寄存器结构体" class="headerlink" title="寄存器结构体"></a>寄存器结构体</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup GPIO_Peripheral_Access_Layer GPIO Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** GPIO - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PDOR;                              <span class="comment">/**&lt; Port Data Output Register, offset: 0x0 */</span></span><br><span class="line">  __O  <span class="type">uint32_t</span> PSOR;                              <span class="comment">/**&lt; Port Set Output Register, offset: 0x4 */</span></span><br><span class="line">  __O  <span class="type">uint32_t</span> PCOR;                              <span class="comment">/**&lt; Port Clear Output Register, offset: 0x8 */</span></span><br><span class="line">  __O  <span class="type">uint32_t</span> PTOR;                              <span class="comment">/**&lt; Port Toggle Output Register, offset: 0xC */</span></span><br><span class="line">  __I  <span class="type">uint32_t</span> PDIR;                              <span class="comment">/**&lt; Port Data Input Register, offset: 0x10 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PDDR;                              <span class="comment">/**&lt; Port Data Direction Register, offset: 0x14 */</span></span><br><span class="line">&#125; GPIO_Type;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就是gpio类型的结构体,gpio类型的指针可以访问寄存器,以首地址加偏移量的方式就可以访问整个寄存器中任意位置.值得注意的是其中的<code>__IO</code>和<code>__o</code>,它们意义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IO definitions (access restrictions to peripheral registers) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span>   __I     volatile             <span class="comment">/*!&lt; defines &#x27;read only&#x27; permissions                 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span>   __I     volatile const       <span class="comment">/*!&lt; defines &#x27;read only&#x27; permissions                 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     __O     volatile             <span class="comment">/*!&lt; defines &#x27;write only&#x27; permissions                */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     __IO    volatile             <span class="comment">/*!&lt; defines &#x27;read / write&#x27; permissions              */</span> </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="操作掩码宏定义"><a href="#操作掩码宏定义" class="headerlink" title="操作掩码宏定义"></a>操作掩码宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">* ----------------------------------------------------------------------------</span><br><span class="line">   -- GPIO Register Masks</span><br><span class="line">   ---------------------------------------------------------------------------- */</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup GPIO_Register_Masks GPIO Register Masks</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PDOR - Port Data Output Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PDOR_PDO_MASK                       (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PDOR_PDO_SHIFT                      (0U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PDOR_PDO(x)                         (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PDOR_PDO_SHIFT)) &amp; GPIO_PDOR_PDO_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PSOR - Port Set Output Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PSOR_PTSO_MASK                      (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PSOR_PTSO_SHIFT                     (0U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PSOR_PTSO(x)                        (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PSOR_PTSO_SHIFT)) &amp; GPIO_PSOR_PTSO_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PCOR - Port Clear Output Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PCOR_PTCO_MASK                      (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PCOR_PTCO_SHIFT                     (0U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PCOR_PTCO(x)                        (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PCOR_PTCO_SHIFT)) &amp; GPIO_PCOR_PTCO_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PTOR - Port Toggle Output Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PTOR_PTTO_MASK                      (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PTOR_PTTO_SHIFT                     (0U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PTOR_PTTO(x)                        (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PTOR_PTTO_SHIFT)) &amp; GPIO_PTOR_PTTO_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PDIR - Port Data Input Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PDIR_PDI_MASK                       (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PDIR_PDI_SHIFT                      (0U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PDIR_PDI(x)                         (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PDIR_PDI_SHIFT)) &amp; GPIO_PDIR_PDI_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @name PDDR - Port Data Direction Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PDDR_PDD_MASK                       (0xFFFFFFFFU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PDDR_PDD_SHIFT                      (0U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PDDR_PDD(x)                         (((uint32_t)(((uint32_t)(x)) &lt;&lt; GPIO_PDDR_PDD_SHIFT)) &amp; GPIO_PDDR_PDD_MASK)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @&#125;</span></span><br><span class="line"><span class="comment"> */</span> <span class="comment">/* end of group GPIO_Register_Masks */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 这部分主要定义了各种掩码和偏移量,方便操作寄存器,减少代码书写量.</p><h1 id="MASK-SHIFT-X-是什么"><a href="#MASK-SHIFT-X-是什么" class="headerlink" title="MASK SHIFT (X)是什么"></a>MASK SHIFT (X)是什么</h1><p> 开始看寄存器最不理解的就是掩码宏定义这一部分,不过各种掩码操作熟练以后确实能够很高效的操作寄存器.</p><h2 id="MASK"><a href="#MASK" class="headerlink" title="MASK"></a>MASK</h2><p> mask本意为遮挡,观察后发现掩码用于给某一寄存器赋1或0.<br> 比如将SPI当中的MTFE寄存器赋值1,只需要:<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SPI_MCR_REG(SPIN[spin]) = ( <span class="number">0</span> | SPI_MCR_HALT_MASK);        <span class="comment">//停止SPI传输</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>如果需要将寄存器赋值0,只需要:</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SPI_MCR_REG(SPIN[spin]) = ( <span class="number">0</span> &amp; ~SPI_MCR_HALT_MASK);        <span class="comment">//开始SPI传输</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p> 注意shift当中的值都是用十进制表示的,在这里,shift表示偏移量,就是寄存器相对首地址偏移的位置.</p><h2 id="x"><a href="#x" class="headerlink" title="(x)"></a>(x)</h2><p> 配合shift和mask,操作寄存器就变得简单了,这里(x)的意思就是将这个位置0或1,写法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//置1</span></span><br><span class="line"> SPI_MCR_REG(SPIN[spin]) =  (<span class="number">0</span>|  SPI_MCR_PCSIS(pcs));</span><br><span class="line"></span><br><span class="line"><span class="comment">//置0</span></span><br><span class="line"> SPI_MCR_REG(SPIN[spin]) =  (<span class="number">0</span> &amp;  ~SPI_MCR_PCSIS(pcs));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SPI_PCS0 = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    SPI_PCS1 = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    SPI_PCS2 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    SPI_PCS3 = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    SPI_PCS4 = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    SPI_PCS5 = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">&#125; SPI_PCSn_e;</span><br></pre></td></tr></table></figure><h1 id="KV5x-Sub-Family-Reference-Manual"><a href="#KV5x-Sub-Family-Reference-Manual" class="headerlink" title="KV5x Sub-Family Reference Manual"></a>KV5x Sub-Family Reference Manual</h1><p><a href="https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf">https://www.nxp.com/docs/en/reference-manual/KV5XP144M240RM.pdf</a></p><h1 id="KV5x-Data-Sheet"><a href="#KV5x-Data-Sheet" class="headerlink" title="KV5x Data Sheet"></a>KV5x Data Sheet</h1><p><a href="https://www.nxp.com/docs/en/data-sheet/KV5XP144M240.pdf">https://www.nxp.com/docs/en/data-sheet/KV5XP144M240.pdf</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;ARM寄存器食用感受&quot;&gt;&lt;a href=&quot;#ARM寄存器食用感受&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="ARM" scheme="https://blog.zzshub.cn/tags/ARM/"/>
    
    <category term="kinetis" scheme="https://blog.zzshub.cn/tags/kinetis/"/>
    
    <category term="register" scheme="https://blog.zzshub.cn/tags/register/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙接收端帮助文档</title>
    <link href="https://blog.zzshub.cn/2017/11/28/BlueToothClient/"/>
    <id>https://blog.zzshub.cn/2017/11/28/BlueToothClient/</id>
    <published>2017-11-28T15:48:00.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新生杯智能车大赛蓝牙接收端帮助文档"><a href="#新生杯智能车大赛蓝牙接收端帮助文档" class="headerlink" title="新生杯智能车大赛蓝牙接收端帮助文档"></a>新生杯智能车大赛蓝牙接收端帮助文档</h1><hr><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p>这个蓝牙接收端于蓝牙上位机配套使用,使用当蓝牙上位机发出指令后,接收程序能够分析上位机发送的信号,并且执行相关的函数</p></blockquote><h1 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h1><p>串口接收数据-&gt;将数据加入数据缓冲区-&gt;在while中一直判断缓冲区中的数据-&gt;如果有相关的指令-&gt;执行相关数据处理函数</p><h1 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h1><p>使用蓝牙接收端程序需要手动在工程中添加<code>SerialPortImformation.c</code> 和 <code>SerialPortImformation.h</code> 之后再<code>include &quot;SerialPortImformation.h&quot;</code></br>另外,因为需要使用串口,所以也需要添加串口USART相关的头文件</p><h1 id="关于-SerialPortImformation-h"><a href="#关于-SerialPortImformation-h" class="headerlink" title="关于 SerialPortImformation.h"></a>关于 SerialPortImformation.h</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> GoSpeed;</span><br><span class="line"><span class="type">int</span> GoSpeedOld;</span><br><span class="line"><span class="type">int</span> TurnSpeed;</span><br><span class="line"><span class="type">int</span> TurnSpeedOld;</span><br><span class="line"><span class="type">uint8_t</span> OtherInfo;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> serialPortQueueBuffer[BUFFERSIZE+<span class="number">5</span>];</span><br><span class="line">&#125; serialPortInfo;</span><br></pre></td></tr></table></figure><p>这个结构体用于判断上位机发送过来的数据,serialPortQueueBuffer是一个用来暂时储存发来的数据的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFERSIZE 20</span></span><br></pre></td></tr></table></figure><p>这个用来调节数据缓冲区的大小,一般不需要修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addSerialPortDate</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data,serialPortInfo *this)</span></span><br></pre></td></tr></table></figure><p>将数据添加进缓冲区,第一个参数是需要添加的数据,第二个参数是需要添加到的结构体的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serialPortexec(serialPortInfo *serialPortInfo)</span><br></pre></td></tr></table></figure><p>这个是判断信息的函数,参数是serialPortInfo结构体的地址</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>任何外设使用以前都需要初始化,串口也一样.所以使用之前一定要初始化串口,串口如何初始化我就不再赘述了,不熟悉的同学可以查看我们之前的例程和教程.或者看我新写的这个例程也可以.</br>另一部分就是这个判断串口指令的初始化,这个由于不是外设,只需要创建一个全局变量就好了</p><p><code>serialPortInfo blueToothInfo;</code></p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>以前已经讲过,串口接收到数据之后就会进入串口中断函数.我们这时只需要将串口接收到的数据传输给蓝牙判断的结构体中就好了,以下是串口中断的部分代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">uint8_t</span> ucTemp;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USARTx,USART_IT_RXNE)!=RESET)</span><br><span class="line">&#123;</span><br><span class="line">ucTemp = USART_ReceiveData(USARTx);</span><br><span class="line">addSerialPortDate(ucTemp,&amp;blueToothInfo);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这一句<code>addSerialPortDate(ucTemp,&amp;blueToothInfo);</code>就是将接收到的数据传输给蓝牙结构体的</p><p>使用的另一个部分就是判断接收到的数据,这个只需要使用<code>serialPortexec(serialPortInfo *serialPortInfo);</code>函数即可.由于需要一直判断,所以需要在while里面一直执行这个函数,以下是部分代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">serialPortexec(&amp;blueToothInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个部分就是执行操作了,因为大家对上位机上不同的按键执行的操作不同,所以就需要大家自己编写函数了.比如想让功能键1被按下时执行的任务,那么只需要写一个函数名为<code>void function1ButtonClickedEvent()</code>,那么当功能键一被按下时就会执行这个函数里面的内容.同理,当上位机上面速度设定发生改变的时候就会执行<code>speedchangeEvent(int xSpeed,int ySpeed)</code>这个函数里面的内容.以下是一些函数</p><table><thead><tr><th>事件</th><th>执行的函数</th><th>备注</th></tr></thead><tbody><tr><td>功能键1被按下</td><td>function1ButtonClickedEvent(void)</td><td></td></tr><tr><td>功能键2被按下</td><td>function2ButtonClickedEvent(void)</td><td></td></tr><tr><td>功能键3被按下</td><td>function3ButtonClickedEvent(void)</td><td></td></tr><tr><td>功能键4被按下</td><td>function4ButtonClickedEvent(void)</td><td></td></tr><tr><td>停车键被按下</td><td>stopButtonClickedEvent(void)</td><td></td></tr><tr><td>设定速度发生改变</td><td>speedchangeEvent(int xSpeed,int ySpeed)</td><td>传进来的参数xSpeed和ySpeed就是改变之后的速度</td></tr></tbody></table><p>有兴趣想知道这个是怎么实现的可以看我的另一篇文章<a href="/2017/11/28/ARMweak/index.html">ARMWeak指令</a></p><h1 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h1><ul><li>例程144行的函数<code>int fputc(int ch, FILE *f)</code>不要删去,否则printf函数将无法使用</li><li>关于”执行的函数”如果不写的话也没有关系,就会执行我默认的函数,不过这样就无法实现你们想要的功能了</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;新生杯智能车大赛蓝牙接收端帮助文档&quot;&gt;&lt;a href=&quot;#新生杯智能车大赛蓝牙接收端帮助文档&quot; class=&quot;headerlink&quot; title=&quot;新生杯智能车大赛蓝牙接收端帮助文档&quot;&gt;&lt;/a&gt;新生杯智能车大赛蓝牙接收端帮助文档&lt;/h1&gt;&lt;hr&gt;
&lt;h1</summary>
        
      
    
    
    
    
    <category term="718创新实验室" scheme="https://blog.zzshub.cn/tags/718%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    <category term="ARM" scheme="https://blog.zzshub.cn/tags/ARM/"/>
    
    <category term="STM32" scheme="https://blog.zzshub.cn/tags/STM32/"/>
    
    <category term="蓝牙" scheme="https://blog.zzshub.cn/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>ARM weak指令巧用</title>
    <link href="https://blog.zzshub.cn/2017/11/28/ARMweak/"/>
    <id>https://blog.zzshub.cn/2017/11/28/ARMweak/</id>
    <published>2017-11-28T15:38:00.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用weak指令实现只声明不定义函数直接调用不出错"><a href="#利用weak指令实现只声明不定义函数直接调用不出错" class="headerlink" title="利用weak指令实现只声明不定义函数直接调用不出错"></a>利用weak指令实现只声明不定义函数直接调用不出错</h1><blockquote><p>近来为新生编写一个蓝牙助手的下位机,采用了类似于面向事件的编程方法吧,蓝牙消息来了就会触发事件函数,把那些复杂的判断都封装起来了,也是方便使用吧.</br>但是有一个问题,事件函数是他们自己写,自己定义,我只是预先声明了,也调用了,但是没有定义.这样很明显是编译过不了的,而C语言又没有类似于C++虚函数一样的东西.利用ARM有的编译指令weak可以实现这个功能.</p></blockquote><p>我的想法是如果使用者没有自己写事件函数,那么就执行我的报错函数,用串口输出报错信息,如果他们写了事件函数,那么就执行他们的事件函数.</p><p>而weak指令的定义为: <strong>__weak函数用于定义变量或者函数，常见于定义函数，在MDK ARM链接时优先链接定义为非weak的函数或变量，如果找不到则再链接weak函数。</strong> 正好符合我的要求.</p><p>以下是代码: </p><p>这是报错函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="type">void</span> <span class="title function_">function1ButtonClickedEvent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;function1ButtonClicked\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;if you see this, it means you DO NOT add your own function\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;for more information,please look at https:///blog.zzshub.cn//\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是用户需要写的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function1ButtonClickedEvent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是函数的调用(部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">function1ButtonClickedEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">function2ButtonClickedEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">function3ButtonClickedEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">function4ButtonClickedEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(serialPortQueueBuffer[i+<span class="number">1</span>]==<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">stopButtonClickedEvent();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><hr><p>EOF</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;利用weak指令实现只声明不定义函数直接调用不出错&quot;&gt;&lt;a href=&quot;#利用weak指令实现只声明不定义函数直接调用不出错&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="ARM" scheme="https://blog.zzshub.cn/tags/ARM/"/>
    
    <category term="STM32" scheme="https://blog.zzshub.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>openwrt简单玩一玩</title>
    <link href="https://blog.zzshub.cn/2017/11/28/openwrt/"/>
    <id>https://blog.zzshub.cn/2017/11/28/openwrt/</id>
    <published>2017-11-28T05:31:50.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>紧接着上一次试玩hiwifiOS系统,最后发现实在是不过瘾,限制太多,尤其是软件安装方面的限制,然后资料又少,受不了了,就还是刷成了正宗的OpenWrt系统.</p></blockquote><h1 id="OpenWrt版本简介"><a href="#OpenWrt版本简介" class="headerlink" title="OpenWrt版本简介"></a>OpenWrt版本简介</h1><p>刷OpenWrt之前先简单说明一下OpenWrt的版本问题吧.<strong>OpenWrt</strong>到目前为止已经有了很多个版本,目前最新的是<strong>15.05 Chaos Calmer</strong> 版本,也就是很多人口中说的CC版.另外,常见的还有<strong>Barrier Breaker 14.07</strong>也就是BB版,还有更古老一点的<strong>Attitude Adjustment 12.09</strong>也就是AA版,这些就是系统版本的区别,就跟windows7和Windows8这样的区别类似.另外,OpenWrt作为嵌入式操作系统,支持众多处理器,不同处理器架构也有不同版本.而为了在安装的时候就把常见的驱动安装进去,每个安装包都附带了驱动,所以导致不同的处理器有不同的版本.比如我这个就是使用的mt7620处理器的15.05 CC版本.而之前的hiwifiOS则是使用mt7620处理器的14.04BB版上修改而成的.</br>除此之外,还有很多论坛上常说的<strong>openwrt PandoraBox</strong>就是一个有人做出来的为中国用户优化过的版本,没用过那个,就不多说了.</p><blockquote><p>关于hiwifi如何刷OpenWrt,这个网上资料已经很多了,就不多说了,可以看看这个资料 <a href="https://www.jianshu.com/p/196a43b79c24">https://www.jianshu.com/p/196a43b79c24</a></p></blockquote><h1 id="OpenWrt从外部设备启动"><a href="#OpenWrt从外部设备启动" class="headerlink" title="OpenWrt从外部设备启动"></a>OpenWrt从外部设备启动</h1><blockquote><p>主要参考这篇博客 <a href="https://www.cnblogs.com/double-win/p/3841801.html">https://www.cnblogs.com/double-win/p/3841801.html</a></p></blockquote><p>整个前面的操作和博客里面讲的一样,不过由于我这个版本里面已经集成了那些驱动,就没有再下载了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/root        　　　　　　 #在/tmp目录下创建一个临时目录，用于放置系统镜像</span><br><span class="line">mount /dev/sda1 /mnt　　　　　　　　#将/dev/sda1 挂载到/mnt目录下</span><br><span class="line">mount -o bind / /tmp/root　　　　　#将根目录&quot;/&quot;制作镜像，并将其挂载到“/tmp/root”下</span><br><span class="line">cp /tmp/root/* /mnt -a　　　　　　　#将/tmp/root/ 目录下的所有内容复制到/mnt下，相当于将/mnt/root下的所有内容复制到/dev/sda1下</span><br><span class="line">umount /tmp/root    　　　　　　　　#解除挂载 /tmp/root</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这一步开始就和博客上面说的不一样了.按照博客的说法,始终无法启动,或者好不容易勉强启动起来了,就到处出问题,网络驱动工作不正常等等.</br><br>之后仔细研究了一下,发现按照之前的做法,我是直接将sd卡设置成为openwrt的根目录点,其实这样是错误的.OpenWrt采用了一种叫做<strong>Overlay</strong>透明挂载的技术.大概意思就是先把磁盘中的一个恢复分区挂载到根目录下,然后使用透明挂载技术将我们认为的根目录挂载到根目录的位置,再将之前的恢复分区挂载到&#x2F;rom目录下,这样就是overlay透明挂载.这样做有很大的好处,按下出厂设置键之后就直接删掉当前的根目录,就会露出恢复分区的目录,这样就可以很容易的实现系统出厂设置.而恢复分区是使用的只读文件系统,无法更改,所以出厂设置也一定能够恢复回来.</p><blockquote><p>有关openwrt的挂载可以看看这个 <a href="https://www.leiphone.com/news/201406/diy-a-smart-router-topic-openwrt.html">https://www.leiphone.com/news/201406/diy-a-smart-router-topic-openwrt.html</a></p></blockquote><p>了解到这个透明挂载技术之后思路就清楚了.之前的挂载少了透明挂载这一层,就出问题了.设置一下就好.好在luci也给我们提供了图形化的设置工具,不需要命令行.接下来看图!</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/%E8%8D%89%E5%9B%BE.png"></p><p>选择到<strong>系统-&gt;挂载点</strong>这一栏就会看到这样的画面,可以看到此时overlay那一层是14.29GB,大约是sd卡的大小.<strong>这就是设置成功的标志之一</strong></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/%E8%8D%89%E5%9B%BE2.png"></p><p>选择下面的添加挂载点,就会进入上面的界面,之后添加sd卡的位置.<strong>然后关键的一步</strong>:<strong>设置挂载点为外部overlay而不是根目录</strong>保存后重启一下路由器.好了,就设置好了.</p><p>其实看上去很简单的一步,自己研究的过程却复杂,不过成功之后也有一点小小的激动.就是这样小激动和漫长钻研过程中不断学习吧</p><h1 id="OpenWrt控制串口"><a href="#OpenWrt控制串口" class="headerlink" title="OpenWrt控制串口"></a>OpenWrt控制串口</h1><blockquote><p>熟悉嵌入式方面的人都知道串口是一个非常重要的设备。所以我也是最先研究这个串口设备，只要串口通信设置好了，那么利用串口和其他微控制器通信，再加上OpenWrt的远程通信的能力，那么就可以做到远程控制一大票东西了。废话不多说，直接开始串口的调试！</p></blockquote><h2 id="焊接串口"><a href="#焊接串口" class="headerlink" title="焊接串口"></a>焊接串口</h2><p>上次的拆机发现hiwifi 1S中是留有串口的焊盘的，只不过没有焊接而已(说实话一直觉得hiwifi挺良心的)。卸下烦人的三角形螺丝，拔出主板，焊接串口线，上电，测试正常，完成！</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/04F747091AEF90654CD185EBF962CB9D.png"></p><p>可以看到，中间有四个焊接的排针。</p><h2 id="串口配置"><a href="#串口配置" class="headerlink" title="串口配置"></a>串口配置</h2><p>在linux上，一切都是文件，串口等外部设备也是一样的。读和写串口在linux上其实就是读和写一个文件。和读写普通文件唯一有点区别的就是需要配置一下串口的波特率。</p><p>第一步首先安装串口的驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opkg update  //更新软件列表</span><br><span class="line">opkg install coreutils-stty //安装stty</span><br></pre></td></tr></table></figure><p>安装完成之后设置波特率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty -F /dev/ttyS0 raw speed 115200  //设置ttyS0串口的波特率为115200</span><br></pre></td></tr></table></figure><p>其中，<code>/dev/ttyS0</code>就是串口设备的名字，这个可以在开机的时候查看启动的信息查看到。 </br>其实，这句话也可以不需要，因为串口开机默认是使用115200波特率的。</p><h2 id="串口读写"><a href="#串口读写" class="headerlink" title="串口读写"></a>串口读写</h2><p>其实串口读写非常简单，就是前面所说的文件的读写</p><h4 id="写串口："><a href="#写串口：" class="headerlink" title="写串口："></a>写串口：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello&quot; &gt; /dev/ttyS0  //向串口输出字符&quot;hello&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读串口："><a href="#读串口：" class="headerlink" title="读串口："></a>读串口：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/ttyS0  //读取串口 </span><br></pre></td></tr></table></figure><h2 id="利用C语言程序实现串口读写"><a href="#利用C语言程序实现串口读写" class="headerlink" title="利用C语言程序实现串口读写"></a>利用C语言程序实现串口读写</h2><p>对于读写文件来说，分为几个步骤：</p><ul><li>打开文件</li><li>获取文件编号(感觉类似于文件指针)</li><li>读文件或者写文件</li></ul><p>对于打开文件使用open函数<br><code>int open( const char * pathname, int flags);</code></p><p>读文件使用read函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    </span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;  </span><br><span class="line"><span class="comment">//返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0</span></span><br></pre></td></tr></table></figure><p>写文件使用write函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> filedes, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功则返回写入的字节数，若出错则返回-1</span></span><br><span class="line"><span class="comment">// filedes：文件描述符</span></span><br><span class="line"><span class="comment">// buf:待写入数据缓存区</span></span><br><span class="line"><span class="comment">// nbytes:要写入的字节数</span></span><br></pre></td></tr></table></figure><h4 id="最后，以下是整个测试程序"><a href="#最后，以下是整个测试程序" class="headerlink" title="最后，以下是整个测试程序"></a>最后，以下是整个测试程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> receivebuff[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="type">int</span> file=open(<span class="string">&quot;/dev/ttyS0&quot;</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(file==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open Failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line">flag=read(file,&amp;receivebuff,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(flag!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">write(file,&amp;receivebuff,flag);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/psb.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/openwrt%E8%AF%95%E7%8E%A9/psb.png"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;紧接着上一次试玩hiwifiOS系统,最后发现实在是不过瘾,限制太多,尤其是软件安装方面的限制,然后资料又少,受不了了,就还是刷成了正宗的OpenWrt系统.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;OpenWrt版本简介&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="Linux" scheme="https://blog.zzshub.cn/tags/Linux/"/>
    
    <category term="mips" scheme="https://blog.zzshub.cn/tags/mips/"/>
    
    <category term="OpenWrt" scheme="https://blog.zzshub.cn/tags/OpenWrt/"/>
    
  </entry>
  
  <entry>
    <title>hiwifi的正确打开方式</title>
    <link href="https://blog.zzshub.cn/2017/11/21/hiwifiRightWay/"/>
    <id>https://blog.zzshub.cn/2017/11/21/hiwifiRightWay/</id>
    <published>2017-11-21T15:41:34.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hiwifi-OS的正确打开方式"><a href="#hiwifi-OS的正确打开方式" class="headerlink" title="hiwifi OS的正确打开方式"></a>hiwifi OS的正确打开方式</h1><hr><blockquote><p>近来频繁需要下载大文件,可是无奈,校园网速度感人.想着能不能把我的路由器改造成一个下载器来下载呢.于是,就开始了我的折腾之路</br>其实这个路由器高中就买了,当时作为家里的主力路由器,一直想折腾,不过也常常搞得网络不稳定,被家里人”投诉”了几次之后,也没有继续研究了.直到后来换了100M宽带,这个只有802.11n协议的路由器带不动了,退休下来,我才有机会仔细的研究一下</p></blockquote><h1 id="hiwifi是什么"><a href="#hiwifi是什么" class="headerlink" title="hiwifi是什么"></a>hiwifi是什么</h1><p>以下是<a href="https://baike.baidu.com/item/HiWiFi/8633008?fr=aladdin">百度百科</a>的介绍:</p><blockquote><p>HiWiFi是北京极科极客科技有限公司推出的一款基于国外开源代码OpenWrt的无线路由系列，全称是“极路由 HiWiFi”，简称“小极”“HiWiFi”。</p></blockquote><p>我手上的这块是hiWiFi 1S-HC5661,极路由官方的第二款产品.采用联发科的MT7620A处理器,这个处理器基于mips架构,560MHz主频,不过正是因为是mips架构的原因,应用程序非常少,交叉编译环境搭建也没那么顺利(相比Qt安卓的交叉编译环境还是要好弄很多).128M的ddr2内存,16M闪存,外置16GB SD卡.</br>软件方面,我目前使用的hiWiFi OS系统,不过看情况吧,可能以后还是要刷成原版OpenWrt.hiWiFi系统是一个基于OpenWrt深度定制而成的系统,而OpenWrt又是一个非常常见的嵌入式Linux系统,类似于小米的MiUI和安卓原生系统以及Linux之间的关系.</p><h1 id="硬件-USB-hiWiFi-1s拆机"><a href="#硬件-USB-hiWiFi-1s拆机" class="headerlink" title="硬件+&#x3D;USB  hiWiFi 1s拆机"></a>硬件+&#x3D;USB  hiWiFi 1s拆机</h1><p>不得不说,hiwifi 1s的外观设计的真是好看,全金属机身,阳极氧化工艺外壳.暗黑色的喷漆外壳上银色的化学侵蚀logo,配上亮色的倒切角工艺.与早些年间只是白色塑料外壳的路由器形成鲜明对比,简单的放在桌面上,也是不错的装饰品吧.另外,使用通用的5V2A-MicroUSB接口,也不用担心供电的问题.</br> 不过,这些都不是今天讨论的重点.其实很久以来就想拆开这个小家伙一探究竟了,只可以一直没有去到专用的三角螺丝刀,这个想法也一直搁置了下来.终于,忍不住了,没有专用螺丝刀,那就大力出奇迹吧.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/14193441483612.jpg"></p><p>一直都有所了解,hiwifi 1S是留有USB接口的,只不过没有印出来,拆开之后发现果不其然,只见USB焊盘,不见USB接口.另外,还发现了留有串口接口应该刷机变砖之后可以用这个刷回来,和没有焊接的802.11ac模块焊盘.不得不说,成品的电路板确实比自己设计的要成熟,各种滤波电容保护,还有各种拓展.</br>正题开始,改造USB!</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/0e655ca7d933c8951f7a5601d21373f082020001.jpg"></p><p>通过观察PCB板上面的走线可以发现,USB的D+和D-其实是连接上了的,只不过USB的VCC和GND没有连接上,那么把电供上就可以使用了.短接如图红圈位置即可.什么?滤波电容?不存在的.根据我的猜测,红圈左边的6脚芯片应该是电源管理芯片,控制USB的供电,当然我也是不会添加的.哼,就不加,三极管都别想让我加.焊接好USB母口之后就是暴力的过程–在外壳上打一个洞,把USB口露出来.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/IMG_2096.JPG"></p><p>无奈手工不行,在机械专业的同学的远程指导下还是搞得这么丑.其实网上还有其他的不打洞,用线引出USB线的方法.有用百兆以太网剩下的4根线的,有用天线的缝隙的等等.不过我深知,线没过几天就会被我扯断,没有采用这个方法.</p><p>好,到这里,硬件改造就完成了,上电!工作正常,U盘挂载正常,连接正常.其实一路上也没有那么顺利,刚焊接好的时候路由器一上电就一直复位,把我吓坏了,以为又双叒叕短路了.重新焊接,无果,后来才发现是供电不足,没有使用5V2A的电源导致的.果断换电源,完成!</p><h1 id="正式进入新世界–root-ssh"><a href="#正式进入新世界–root-ssh" class="headerlink" title="正式进入新世界–root&amp;ssh"></a>正式进入新世界–root&amp;ssh</h1><p>相信了解过Linux或者玩过安卓的人都知道root权限吧.hiWiFi上面获取root权限非常简单,去后台直接获取就好了.不过注意了,保修可就失去了,hiWiFi保修三年还是很良心的啦.</br>获取之后就配置ssh,注意官方给的端口号是1022,不过也有可能就是默认的22,这个时候官方已经默认帮你安装了ssh的server了,直接连接就好.Windows10 1709版本的话可以试试微软最新推出的Ubuntu On Windows(这玩意在后面会仔细讲一下),用这个连接ssh挺方便的,不然的话下载Putty也可以.</p><blockquote><p>在Ubuntu On Windows输入 ssh -p 1022 <a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#x38;&#46;&#49;&#57;&#57;&#x2e;&#49;">&#114;&#x6f;&#111;&#116;&#x40;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#x38;&#46;&#49;&#57;&#57;&#x2e;&#49;</a></p></blockquote><p>输入密码(就是后台管理密码)后出现以下界面就算是权限获取成功而且ssh服务已经打开了</p><p> <img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE.png"></p><p> 哎,不愧是改的openwrt,连登陆界面都这么像.</p><p> 另外文件传输的话可以使用WinSCP,连接登录就好了,注意文件协议需要选择SCP.当然,也可以安装vsftp,用ftp传输文件也是可以的.</p><p> <img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE2.png"></p><h1 id="个人网盘-远程下载器"><a href="#个人网盘-远程下载器" class="headerlink" title="个人网盘+远程下载器"></a>个人网盘+远程下载器</h1><p> 说到底,最开始研究这个路由器的初衷就是当个下载器用嘛.在以前,路由器上面有个迅雷的插件,可以利用迅雷的服务下载,无奈,迅雷关闭了这个服务.不过还好,Linux上不是还有个叫wget的命令行下载工具吗,利用它不就好了.直接cd到需要下载的目录下,wget+网址名就好了.不过等等,我的16G的SD卡呢? 执行命令 <code> fdisk -l</code> 读取出SD卡了,只不过没有自动挂载 <code> mount /dev/mmcblk0 /mnt</code>好的这下就把名称为mmcblk0的SD卡挂到根目录下的mnt文件夹上了,下载吧!不过很遗憾,路由器上的wget被阉割过了,支持的下载协议很少.凑合着下载吧,以后再找个好的.</br>不过停一下,我退出了ssh怎么下载就暂停了?再连接上,执行<code>top</code>,果然wget被杀进程了,保持后台下载,怎么办,linux上面有一个叫做<code>nohup</code>的命令,可是路由器上面没有啊.仔细寻找资料,发现只需要在命令的最后面加一个&amp;就好了,非常方便,再次退出,果然下载还在继续.</br><br> 下载之后怎么把东西移动到电脑上呢?一个很直接的办法,把SD卡拆下来插到电脑上就好了,不过放弃吧,文件系统不支持呢.路由器上使用的是ext4文件系统,这种文件无法被windows识别. 在局域网内部,可以采用smb协议传输文件,smb协议是微软推出的一种在局域网内部传输文件的协议,因为是在局域网内部,也不能加密传输.hiWiFi默认也是开启了smb服务的,在此电脑输入smb:&#x2F;&#x2F;192.168.199.1即可.好了,到目前为止,可以在局域网下访问的下载器就做好了.</br><br> 文不对题啊,说好的远程呢?一步一步来,先看看学校的网络大环境,今年学校大修改,增加了1000M出口带宽(鼓掌!)之后,校网由以前的静态IP,客户端认证+MAC地址绑定变成了,动态IP+MAC地址绑定或者802.1x认证,同时无线校园网全校覆盖(衷心的感谢学校网络中心的努力,并同时希望网路中心能尽快修好实验室的网).这样看来,我只需要把路由器的MAC地址注册到我的名下,路由器就可以联网了.路由器设置成无线中继模式,连接到学校的wifi就好了.不过动态ip也带来了问题,我的ip一直在变啊,最开始以为变化的不是很快,然而我想错了,几乎半天就要变一次ip.看来有必要上ddns服务了,ddns服务是什么,首先了解dns服务,就是一个能够把域名解析成ip地址的玩意,那么ddns是什么,ddns可不是ddos,差一个字母,可完全不是一个东西,Dynamic DNS,动态dns,能够解析一直在变动的ip地址,也就是说我开启了ddns,不管IP地址怎么变化,我访问我的域名,总能获取到正确的ip地址.hiWiFi的ddns也是一个插件的事,利用不知道是谁提供的ddns服务(感谢那个不知道名字的陌生人,谢谢),分配给我了一个域名<code>zzscloud.jios.org.</code>什么玩意,这个域名好丑.免费的果然还是不靠谱,我可是由.cn的域名的男人,才不要你这玩意,做CNAME跳转吧.CNAME跳转就是由一个域名跳转到另一个域名的服务.以下是在腾讯云上做CNAME跳转</p><p> <img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE3.png"></p><p> 好了,ip变化的问题就解决了,以为就可以远程访问了?错,看之前访问的192.x.x.x,这都是路由器的内网ip啊,可是远程只有路由器的公网ip,也就是学校分配的IP地址,这样做个端口映射即可,将学校的ip映射成内网的ip就可访问了.看这里:</p><p> <img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE4.png"></p><p> 图形就是好,不过到后面就慢慢是命令了</p><p> 涉及到远程连接,不能加密的smb服务就不是那么安全了,换到更安全,更普遍使用的ftp服务势在必行.hiwifi上面安装ftp同样也非常简单,安装vsftpd插件即可.</p><p> 好了,这么一来,远程访问的问题终于弄好了,现在可以全校范围内访问路由器了.同学叫你分享文件,终于有了一种快(装)速(逼)的方式了哈哈.另外,远程ssh连接,远程管理路由器后台,甚至以后的远程挂摄像头,都需要这个作为基础.</p><ul><li><a href="https://hiwifi.zzshub.cn/">https://hiwifi.zzshub.cn/</a></li><li><a href="ftp://hiwifi.zzshub.cn/">ftp://hiwifi.zzshub.cn/</a></li></ul><p>这是我的远程连接的地址,我怎么可能会把密码说出来呢.</p><p> 可是出校门了还能访问吗,因为学校分配的ip相对来说也是内网ip.实现全球能访问两个办法.1.让学校给我做端口映射,不可能.2.那就只好我自己做内网穿透咯.不过目前还没这方面的需要,以前做过效果也不是很好,留给以后去折腾吧.</p><h1 id="插件-插件-插件"><a href="#插件-插件-插件" class="headerlink" title="插件,插件,插件!"></a>插件,插件,插件!</h1><p> hiwifi最初主打的功能就是智能路由器,能安装各种插件,比如番茄助手啥的.hiWiFi安装插件的方式可谓是简单的非常,复杂的也有点复杂.最简单的,直接去官方网页版插件市场安装就好了,不过插件数量很少限制也比较多,这部分跳过.</br>另一种安装方式当然就是用包管理器了.</p><blockquote><p><a href="https://openwrt.io/docs/opkg/">https://openwrt.io/docs/opkg/</a> 这部分主要参考的这篇文档提供的内容</p></blockquote><p> hiwifiOS基于openwrt,而在openwrt上面有一个很好用的包管理器叫<code>opkg</code>类似于Ubuntu上面的<code>apt-get</code></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>opkg install [软件名]</td><td>安装软件</td></tr><tr><td>opkg update</td><td>更新软件源</td></tr><tr><td>opkg list</td><td>查看可以安装的软件</td></tr><tr><td>opkg list-installed</td><td>查看已安装的软件</td></tr><tr><td>opkg remove [软件名]</td><td>卸载软件</td></tr></tbody></table><p> 另外还有<code>opkg -help</code>可以查看命令帮助,帮助写得比较详细了.</p><p> 用ssh连接 <code>ssh -p 1022 root@hiwifi.zzshub.cn </code><br> 然后执行<code> opkg list</code>查看可以安装的软件.不过很遗憾,能够安装的很少.不科学啊,openwrt上软件可是很多的.全都怪hiwifi的软件源把插件都屏蔽掉了,那么我们换个openwrt的源不就好了.</br>查阅资料发现,opkg源文件存放在<code> /etc/opkg.conf</code>中,cd 到这个地方,打开vi编辑器<code>vi opkg.conf</code>如图所示添加几个源就好了</p><p> <img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE45.png"></p><p> 顺便提一嘴,这个版本的vi真是好用,可以识别方向键和退格键等,不用频繁的进出编辑模式了,舒服.</p><p> 更新软件源<code>opkg update</code>再用<code>opkg list</code>发现可以安装的软件确实变多了好多.那么,慢慢下载这些插件吧.</p><h1 id="自己动手-编写代码–hiwifiOS交叉编译环境的搭建"><a href="#自己动手-编写代码–hiwifiOS交叉编译环境的搭建" class="headerlink" title="自己动手,编写代码–hiwifiOS交叉编译环境的搭建"></a>自己动手,编写代码–hiwifiOS交叉编译环境的搭建</h1><p>根据网上主流的做法,配置OpenWrt需要在Linux环境下进行.不过我想直接在Windows下直接进行这个环境的搭建.当然了,也是借助一些模拟Linux的环境进行搭建.</br>首先介绍一个软件 <code>bash on Ubuntu on Windows</code> 听这个软件名字这么长就知道这个很厉害了吧.这是微软爸爸最新弄出来的软件,正式版只能在最新的Windows 10 1709版本运行.这是一个Ubuntu运行环境,相当于在Windows上面运行了一个Ubuntu命令行版本的虚拟机,不过呢,这个环境底层又是直接调用的Windows系统级API,运行速度会比单纯的虚拟机快上很多,而且文件共享也更方便.</p><h3 id="安装bash-on-windows"><a href="#安装bash-on-windows" class="headerlink" title="安装bash on windows"></a>安装bash on windows</h3><p>安装过程非常简单,在Windows的程序和功能中选择<code>启动或关闭Windows功能</code> 然后勾选<code>Linux子系统</code>,重启之后再去应用商店下载Ubuntu即可.</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE11.png"></p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE12.png"></p><blockquote><p>打开PowerShell或者CMD,输入Ubuntu,这个运行环境就搭建完成了.</p></blockquote><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE13.png"></p><p>之后的操作和在真正的Ubuntu下操作终端就完全一样了,唯一需要注意的是和Windows文件交换的问题.整个Windows的文件都被挂载到 &#x2F;mnt 文件夹下了,于是可以通过这个 &#x2F;mnt文件夹方便的实现文件的交换.另外,系统默认使用root账户登录,权限高,在虚拟环境下又不会对Windows产生伤害,美滋滋.</p><h3 id="bash-on-Windows的完善"><a href="#bash-on-Windows的完善" class="headerlink" title="bash on Windows的完善"></a>bash on Windows的完善</h3><p>其实这一部分没什么好说的,一句话总结,操作和Linux下完全一样.</br><br>比如换成国内的软件源 使用命令<code>vi /etc/apt/sources.list</code>保存源的文件,替换成国内的源即可.比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br><span class="line">EOF </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><br><span class="line"># newer versions of the distribution.</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic main restricted</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic main restricted</span><br><span class="line"></span><br><span class="line">## Major bug fix updates produced after the final release of the</span><br><span class="line">## distribution.</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates main restricted</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-updates main restricted</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team. Also, please note that software in universe WILL NOT receive any</span><br><span class="line">## review or updates from the Ubuntu security team.</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic universe</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic universe</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates universe</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-updates universe</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu</span><br><span class="line">## team, and may not be under a free licence. Please satisfy yourself as to</span><br><span class="line">## your rights to cne the software. Also, please note that software in</span><br><span class="line">## multiverse WILL NOT receive any review or updates from the Ubuntu</span><br><span class="line">## security team.</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic multiverse</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-updates multiverse</span><br><span class="line"></span><br><span class="line">## N.B. software from this repository may not have been tested as</span><br><span class="line">## extensively as that contained in the main release, although it includes</span><br><span class="line">## newer versions of some applications which may provide cneful features.</span><br><span class="line">## Also, please note that software in backports WILL NOT receive any review</span><br><span class="line">## or updates from the Ubuntu security team.</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">## Uncomment the following two lines to add software from Canonical&#x27;s</span><br><span class="line">## &#x27;partner&#x27; repository.</span><br><span class="line">## This software is not part of Ubuntu, but is offered by Canonical and the</span><br><span class="line">## respective vendors as a service to Ubuntu cners.</span><br><span class="line"># deb http://archive.canonical.com/ubuntu bionic partner</span><br><span class="line"># deb-src http://archive.canonical.com/ubuntu bionic partner</span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu bionic-security main restricted</span><br><span class="line">deb-src http://security.ubuntu.com/ubuntu bionic-security main restricted</span><br><span class="line">deb http://security.ubuntu.com/ubuntu bionic-security universe</span><br><span class="line">deb-src http://security.ubuntu.com/ubuntu bionic-security universe</span><br><span class="line">deb http://security.ubuntu.com/ubuntu bionic-security multiverse</span><br></pre></td></tr></table></figure><p>之后再 <code> apt-get update</code> 更新软件源就好了</p><p>顺便安装一些常用的软件</p><ul><li>apt-get install gcc  安装gcc C语言编译器</li><li>apt-get install g++  安装g++ C++编译器</li></ul><p>其他我就不列举了,重点说一下安装Java.安装java有两种方式,可以使用apt-get安装,这种方式不用自己配置环境变量.另外也可以去Oracle官网下载java的安装包手动配置环境变量进行安装.这里就说第一种安装方式吧.</br></p><ul><li><code>add-apt-repository ppa:webupd8team/java</code> 添加java的源</li><li><code>apt-get update</code> 更新软件源</li><li><code>apt-get install oracle-java9-installer</code> 安装Java安装包</li></ul><p>经过这三步之后,java安装包就会自动安装java了,等一会就好.值得注意的是,我们这里安装的是最新的java9,安装其他版本只需要把9改成其他数字就好了</p><h3 id="安装SDK-交叉编译工具链正式开始搭建"><a href="#安装SDK-交叉编译工具链正式开始搭建" class="headerlink" title="安装SDK,交叉编译工具链正式开始搭建"></a>安装SDK,交叉编译工具链正式开始搭建</h3><blockquote><p>此部分内容主要参考hiWiFi的官方文档 <a href="http://code.hiwifi.com/docs/sdk_usage">code.hiwifi.com</a></p></blockquote><p>说句实话,OpenWrt工具链的搭建,网上资料真的是少之又少.感觉基本上就只有官方的帮助文档和几篇博文能看.另外,官方的帮助文档我只能用<strong>简洁</strong>二字来形容.只有十几页内容介绍完了编译环境搭建到刷机到全部的api接口……</p><p>根据官方的说法,先下载SDK包,直接说吧 hiwifiOS应该下载这一个<a href="http://sdk.ikcd.net/mtmips-sdk.tar.bz2">mtmips</a> 使用前面讲的wget命令下载到电脑上就好了.下载完成后解压,<code>tar -xjvf [文件名]</code> 到目前为止,sdk已经下载完成了.其实吧,在Windows上也可以完全用浏览器下载下载下来,然后用图形化的解压缩工具解压缩.</p><p>继续阅读官方SDK 需要安装一些工具库,按照官方说的来就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install subversion git build-essential libncurses5-dev zlib1g-dev gawk unzip gettext libssl-dev intltool openjdk-6-jre-headless optipng</span><br><span class="line"></span><br><span class="line">ln -sf bash /bin/sh</span><br></pre></td></tr></table></figure><p>这个时候可能会弹出来说啥java6安装不上啥的.没关系,反正就是jre(java runtime environment)嘛,我们之前不就已经安装了java吗.</p><p>好了,如果没有出错的话,到目前位置,交叉编译环境就已经搭建好了.</p><h1 id="Hi-WiFi-第一个在路由器上运行的程序"><a href="#Hi-WiFi-第一个在路由器上运行的程序" class="headerlink" title="Hi~ WiFi! 第一个在路由器上运行的程序"></a>Hi~ WiFi! 第一个在路由器上运行的程序</h1><h3 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h3><p>上节说到交叉编译环境搭建.来来来,这节就该说说编译程序了.按照hiwifi的说明,有两种编译方法,我们这里使用脚本编译的方法.</br>cd 到sdk的根目录输入<code>./scripts/cross-compile.sh ./</code>启动这个编译脚本,cd到packge目录下你的要编译的文件的文件夹下执行<code>make</code>指令就好了.之后可以执行<code>file [编译出的文件名]</code>查看是不是mips架构的可执行文件,如果是的话那么祝贺,编译成功了!</p><h3 id="编写第一个程序"><a href="#编写第一个程序" class="headerlink" title="编写第一个程序"></a>编写第一个程序</h3><p>等等,漏了什么重要的东西,编译啥啊,啥都还没有呢…….可以在Windows下写好一个c语言程序,再编写一个makefile,再放到sdk的packge文件夹下就好了,比如这样:</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE111.png"></p><p>makefile的作用就是制定编译的顺序,以下是一个简单的makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main : hello.c</span><br><span class="line">    gcc hello.c -o main</span><br></pre></td></tr></table></figure><h3 id="编译遇到的错误"><a href="#编译遇到的错误" class="headerlink" title="编译遇到的错误"></a>编译遇到的错误</h3><p>编写完成之后就执行刚才的操作,那么一切顺利的话就编译完成了.当然,事情也不会有那么顺利,有时候会编译报错,提醒你这没安装那没安装的.比如我第一次配置环境的时候就一直提醒我git没安装,可是我真的安装了的啊,后来发现是中文路径搞的鬼,SDK一定要放到一个全部是英文的路径下面,不然,可能就会像我一样出现一些奇奇怪怪的问题.</p><h3 id="将程序传输到路由器上"><a href="#将程序传输到路由器上" class="headerlink" title="将程序传输到路由器上"></a>将程序传输到路由器上</h3><p>好了,到目前为止就只剩下最后一个操作了,把文件传到路由器上去.用WinSCP传输文件就好了.看图!</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE112.png"></p><p>左边是电脑上的文件,右边是路由器上的文件,直接拖拽过去就上传成功了.<br></br>接下来,ssh连接路由器,执行.啊?无法执行?哦哦,忘了添加执行权限了,输入命令,添加就好 <code>chmod 777 [文件名]</code> 777就是添加可执行权限的代号<br>.最后执行! 运行正常,完美!上图!</p><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/hiwifi%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/%E8%8D%89%E5%9B%BE113.png"></p><p>终于成功了,激动!</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;hiwifi-OS的正确打开方式&quot;&gt;&lt;a href=&quot;#hiwifi-OS的正确打开方式&quot; class=&quot;headerlink&quot; title=&quot;hiwifi OS的正确打开方式&quot;&gt;&lt;/a&gt;hiwifi</summary>
        
      
    
    
    
    
    <category term="Linux" scheme="https://blog.zzshub.cn/tags/Linux/"/>
    
    <category term="mips" scheme="https://blog.zzshub.cn/tags/mips/"/>
    
    <category term="OpenWrt" scheme="https://blog.zzshub.cn/tags/OpenWrt/"/>
    
  </entry>
  
  <entry>
    <title>uper2018使用说明</title>
    <link href="https://blog.zzshub.cn/2017/11/13/uper2018use/"/>
    <id>https://blog.zzshub.cn/2017/11/13/uper2018use/</id>
    <published>2017-11-13T07:25:06.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="718蓝牙助手使用说明"><a href="#718蓝牙助手使用说明" class="headerlink" title="718蓝牙助手使用说明"></a>718蓝牙助手使用说明</h1><hr><blockquote><p>这篇文章主要介绍串口通信,用蓝牙实现串口通信,以及蓝牙助手的使用说明.</p></blockquote><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>蓝牙串口基于串口通信,普通串口使用有线传输,而蓝牙串口只是用蓝牙代替了有线,来传输信号而已.单片机发送的串口信号发送到<a href="https://baike.baidu.com/item/%E8%93%9D%E7%89%99%E4%B8%B2%E5%8F%A3/1415870?fr=aladdin">蓝牙串口模块</a>上,然后蓝牙串口模块经过一些处理,将串口信号转化为蓝牙的传输信号使用蓝牙传输协议发送到手机上,手机上面的蓝牙,再将信号解析出来.虽然中间传输不是使用的串口传输的,但是利用蓝牙串口模块我们发送和接收却是使用的串口通信,所以我们可以忽略中间具体的传输过程.也就是说掌握了串口通信也就基本能够掌握蓝牙串口的使用了.</p><h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><p>直接进入正题,什么是串口通信. 这一段是来自<a href="https://baike.baidu.com/item/%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/3775296?fr=aladdin">百度百科</a>的说明: 串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。</br>同时我们之前提供的<a href="/2017/10/30/STM32%E5%9F%B9%E8%AE%AD/">STM32资料</a>中也有关于串口通信的说明<br>参见说明文档中的<em>stm32f10x系列usart模块</em><br></br>这里我们也再简单说明一下什么是串口通信.串口通信听名字就是串起来通信,就是将数据按照一定时间顺序,先后发送出去.与之相对应的当然还有并行通信,就是将一组(比如8bit)数据一次性发送出去.另外,通信当然包括发送和接收,所以串口通信有两条线,一条负责发送信息,我们称之为<strong>TXD</strong>(Transmit Data),另一条负责接收信息,我们称之为<strong>RXD</strong>(Receive Data).我们发送的信号无非就是高电平和低电平(1和0),提到电平,就必须知道是相对于谁的电平,所以串口通信中还需要一根线将传输的两个对象的参考电平保持一致,所以我们需要第三根地线<strong>GND</strong>(Ground).另外如果使用蓝牙串口,那么我们还需要为蓝牙模块提供电能,所以我们还需要电源<strong>VCC</strong>(Volt Current Condenser).<br></br>这样我们就清楚了,一共需要<strong>VCC,GND,TXD,RXD</strong>四根线连接单片机和蓝牙串口模块.</br><br>之后就是单片机串口使用的问题了,建议大家看看我们的例程和帮助文档,上面说明的比较详细.</p><hr><h1 id="HC-05-HC-06蓝牙串口模块的使用"><a href="#HC-05-HC-06蓝牙串口模块的使用" class="headerlink" title="HC-05&#x2F;HC-06蓝牙串口模块的使用"></a>HC-05&#x2F;HC-06蓝牙串口模块的使用</h1><blockquote><p>首先给大家推荐一个非常详细的资料,<a href="https://www.arduino.cn/forum.php?mod=viewthread&tid=2961&highlight=%E8%93%9D%E7%89%99">https://www.arduino.cn/forum.php?mod=viewthread&tid=2961&highlight=%E8%93%9D%E7%89%99</a> </p></blockquote><p>好,我假设你已经看了上面的资料,那么我再补充总结几句:</p><ul><li>蓝牙串口模块分为两种模式: <strong>AT模式</strong>和<strong>传输模式</strong>,AT模式用于设置蓝牙串口,传输模式用于传输数据.</li><li>蓝牙设置和单片机上的串口设置类似,需要设置波特率,停止位,校验位等. <strong>注意:</strong> 因为是用串口和单片机通信,所以波特率等要和单片机上面设置的参数一致.另外,还要设置蓝牙的名称,密码,工作模式等.<strong>注意:</strong> 因为是手机主动连接到蓝牙模块,蓝牙模块是被链接的对象,所以工作模式要设置成从机模式. </li><li>蓝牙进入AT模式可以长按模块上的按键来进入,如果你购买的模块上没有按键,就只能使用资料里面说的用跳线的方式来进入了.</li><li>蓝牙配置注意一定要使用38400的波特率才行,另外,资料里面提供的那个配置蓝牙的工具非常好用,虽然我们提供的718蓝牙助手Windows版也能够配置,但还是建议大家用资料里提供的工具配置,用那个工具配置成功的概率更高.</li></ul><hr><h1 id="蓝牙串口控制原理"><a href="#蓝牙串口控制原理" class="headerlink" title="蓝牙串口控制原理"></a>蓝牙串口控制原理</h1><p>正如大家所熟知的,串口通信其实传输的就是<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2/1017763?fr=aladdin">字符串</a>,但是我们需要传输给单片机的是控制命令.所以我们需要自己定义一些特殊的字符串,当单片机检测收到这些特定的字符串之后,就会执行相关的操作.就像定义C语言里面的关键字一样.比如在我们的<em>718蓝牙助手</em>当中,我们定义 X30 这个字符串的意思就是小车前进的速度为最大速度的30%,在比如 Y56 这个字符串的意思就是转向速度为56, FSTOP 这个字符串的意思就是紧急停车等等.当然我们蓝牙助手也只是会向单片机发送这么一个字符串而已,这些命令实现的功能也仅仅是我们建议的功能,最后到底怎么执行这些功能,也是需要在单片机上面自己定义的.</br><br>以下是<em>718蓝牙助手</em>能够发送的命令:</p><table><thead><tr><th>按钮</th><th>发送的命令</th><th>备注</th></tr></thead><tbody><tr><td>功能一</td><td>F1</td><td></td></tr><tr><td>功能二</td><td>F2</td><td></td></tr><tr><td>功能三</td><td>F3</td><td></td></tr><tr><td>功能四</td><td>F4</td><td></td></tr><tr><td>紧急停车</td><td>X0Y0FSTOP</td><td>发送X0,Y0和FSTOP</td></tr><tr><td>控制杆</td><td>X[number1]Y[Number2]</td><td>number就是代表直线速度和转向速度</td></tr><tr><td>重力控制</td><td>X[number1]Y[number2]</td><td>number就是代表直线速度和转向速度</td></tr></tbody></table><p><strong>特别说明:X后面的number就是显示出来的前进速度,范围是-99<del>99,Y后面的number就是显示出来的转向速度,范围是-99</del>99.</strong></p><hr><h1 id="软件界面简单介绍"><a href="#软件界面简单介绍" class="headerlink" title="软件界面简单介绍"></a>软件界面简单介绍</h1><h3 id="操作界面"><a href="#操作界面" class="headerlink" title="操作界面"></a>操作界面</h3><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/uper2018use/caozuo.png" alt="操作界面"></p><ul><li>小方块是一个操作杆(略丑,一定会改进的,捂脸),操作小车前后左右移动</li><li>重力控制(移动版):可以通过前后转动手机控制小车</li><li>自动跟踪(桌面版):鼠标移动到操作杆上,不需要按下按键,就能移动操作杆</li><li>桌面版本可以通过键盘上q w e r 这四个按键控制功能1,2,3,4</li></ul><h3 id="串口连接界面-桌面版"><a href="#串口连接界面-桌面版" class="headerlink" title="串口连接界面(桌面版)"></a>串口连接界面(桌面版)</h3><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/uper2018use/desktop.png" alt="连接桌面版"></p><ul><li>扫描端口后设置好波特率和端口好连接就可以了</li><li>支持USB转串口线或者蓝牙连接,使用USB连接时可以到设备管理器中查看具体的端口号,只用蓝牙连接,要首先在系统中配对蓝牙,并且查看蓝牙的端口号</li><li>可以在下面的对话框中发送和接收串口的数据.</li></ul><h3 id="串口连接界面-移动版"><a href="#串口连接界面-移动版" class="headerlink" title="串口连接界面(移动版)"></a>串口连接界面(移动版)</h3><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/uper2018use/mobile.png" alt="连接移动版"></p><ul><li>扫描蓝牙名称后连接即可,不需要配置波特率等</li><li>请确保蓝牙首先已经在系统中配对过了,未配对的蓝牙能搜索到,但是有可能连接不上.</li><li>部分安卓手机可能不支持蓝牙2.0的模块,所以有可能搜索不到HC-05&#x2F;HC-06蓝牙模块,所以可能需要蓝牙4.0的模块</li><li>部分安卓手机权限审核可能比较严格,一定要给够蓝牙的权限,不然也有可能连接不上.</li><li>可以在下面的对话框中发送和接收串口的数据.</li></ul><hr><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>好吧其实也没有啥好说的了,有问题可以在我们的<strong>718科创交流群</strong>当中讨论,也可以在下面的评论框中评论.我们的App也会在后续不断的更新.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;718蓝牙助手使用说明&quot;&gt;&lt;a href=&quot;#718蓝牙助手使用说明&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="作品" scheme="https://blog.zzshub.cn/categories/%E4%BD%9C%E5%93%81/"/>
    
    
    <category term="718创新实验室" scheme="https://blog.zzshub.cn/tags/718%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    <category term="作品" scheme="https://blog.zzshub.cn/tags/%E4%BD%9C%E5%93%81/"/>
    
    <category term="Qt" scheme="https://blog.zzshub.cn/tags/Qt/"/>
    
    <category term="安卓" scheme="https://blog.zzshub.cn/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>2017实验室经历总结</title>
    <link href="https://blog.zzshub.cn/2017/11/03/2017Conclusion/"/>
    <id>https://blog.zzshub.cn/2017/11/03/2017Conclusion/</id>
    <published>2017-11-03T15:38:00.000Z</published>
    <updated>2024-07-02T05:07:11.679Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1491163&auto=1&height=66"></iframe><p>正式看之前还是放一个音乐吧,全文6000多字,废话又多,怕你们睡着了</p><hr><h1 id="2017年总结"><a href="#2017年总结" class="headerlink" title="2017年总结"></a>2017年总结</h1><h2 id="周子顺"><a href="#周子顺" class="headerlink" title="周子顺"></a>周子顺</h2><hr><blockquote><p>时间很快，转眼间在718实验室也呆了一年了。在这一年里也经历了很多，也有很多话想对下一年的人说。这个总结我想分为几个方面。首先我想谈一谈我这一年的经历，其次我再想谈一谈刚来实验室的一些感受，然后我想再谈一谈关于参加 NXP 智能车赛和全国大学生电子设计竞赛等其他比赛的一些感想，我还想谈一谈在实验室的日常和实验室之外的一些事情，最后我还想谈一谈实验室的发展。 </p></blockquote><h3 id="一年经历"><a href="#一年经历" class="headerlink" title="一年经历"></a>一年经历</h3><ol start="2"><li>首先说我的经历吧。我从小就对电子技术比较感兴趣，从小就喜欢拆卸研究各种电器，喜欢研究电脑的操作系统等。上大学前就自己修过手机屏幕和主板，制作过简单的红外遥控器，研究过Unity3D 做过游戏，学习过C++(面向过程的C++,相当于 C语言加上一些简单的 STL 算法库)，搞过算法竞赛，也略微自学过 Java，研究过路由器搭建小型服务器等。还记得当时刚入学班助就向我推荐了一个“718 创新交流群“，我怀着试一试的心态加入了这个群，开启了我这大学的科创生活。之后就是参加了实验室的纳新提前批，提前批也就是3道程序题，由于之前的 C++基础，我相对容易的完成了 3 道题,不过也是付出了很多，记得那个国庆假期，我就出去玩了2天，剩下的5天全部在寝室里解题，最晚一次是编程到凌晨两点。进入实验室后就开始学习 51 单片机，一个多星期写了一个电子钟。之后就开始开始准备校园智能车赛，我们采用的是KL26单片机和摄像头循迹方案，效果比单纯的用光电对管循迹效果要好很多，难度也涨了很多，记得当时的情况是一星期勉强入门ARM的单片机，之后结合例程和成品电驱板，花了一个周末的时间勉强让车动了起来。后来的一个多星期主要是在调参数。最后参赛，因为场地光线原因，遗憾没能拿到第一。记得那段时间提到做车就很激动，一点点的看着车从不能跑到能跑，过不了直角弯到稳定过直角弯，从经常时不时断言到后来稳定的运行，做小黄车一路上有激动也有遇到很多困难。经常是晚上接近 11 点了才回寝室，晚自习也是经常上一半就跑出去。小黄车结束后，实验室有了正式的第一批纳新。之后寒假就开始组队制作智能车，我和公续荣，董书航一组，参加的电磁节能组。说实话这是个今年新加入的组别，我们确实遇到了不少坑。我在队伍里面负责是是软件部分，原先的计划我软件,公续荣机械和电路，董书航电源，当然后来也发生了一些变化我后面会提到。二月份寒假，我基本写完了程序的完整框架，还学习了Qt图形编程。三月份时间安排不周，直到三月中旬才把电路板设计出来开始调试，三月份主要就是在调试电路板，调试程序等，之外还进一步学习了Qt，学习了Git代码版本控制工具，也初步了解了一些单片机的底层。四月份工作就很枯燥，就是调车，其实也没怎么调，基本就陷入了一个循环，运放出问题，修运放，之后电感出问题，修电感，然后运放又出问题……基本就是整个系统到处出问题，车基本不能跑，而我们节能组最重要的电源部分还没有开始做。四月份在调车之余用Qt 写了智能车校赛的光电计时系统。进入五月，五月初校赛，车还是跑的很烂，电源还是用的很普通的芯片，没有经过优化。校赛结果非常糟糕，6次发车全部失败。智能车就暂时告一段落，之后参加了校电赛，帆板控制系统，我设计了一个蓝牙控制的上位机，再加上公续荣设计的舵机控制距离，效果非常好，获得一等奖。记忆很深的是电赛最后那天晚上的死亡冲锋，一夜没睡，电赛大部分的东西都是那个周末做出来的，很累，也很有成就感。进入7月，车还是不能跑.7月22号比赛,离比赛还有20天,其他组都上两米了,摄像头都在想办法稳定在 3 米了,我们还不能跑,你们能想象我当时的心里压力吗.说实话那段时间我真的非常想放弃,而且看得出来,我们的一位队员可能已经放弃了.不过在学长的帮助下我们重新设计了电路,直到 7 月 17 号左右我们才开始快速的调车.我和老公(误)(公续荣)实验室连续通宵 5天,5 天没回寝室,等我回去发现人都少了两个.每天吃饭,睡觉,调车,就这三件事情,真的就是非常努力的调车,不过最后还好调到两米多了.记得那段时间印象最深的就是每天晚上两点我都会和老公一起去 3 楼的饮水机那里接开水泡方便面吃,休整一下,然后继续调车.那段时间我过得很累,不过内心却很满足,7 月份我瘦了 10 斤.之后去青岛比赛,比赛成绩并不是很理想,主要也是因为初始的方向选择的就有问题,就是在一条错误的道路上越走越远,所以今年想做节能组的一定要慎重,也一定要和我们多沟通,我们去年掉过的坑希望你们不会再掉进去.之后就是做电赛,没错,电赛就是在暑假,所以暑假想回去的同学我就先给你们说一下你们基本没有暑假了.我去年只回去了5天时间.电赛又是跟老公和刘健建学长在一起的8天8夜,又是8天没回寝室,又是每天晚上去3楼泡方便面……还发生了一件趣事,8天里每次都是刘健建的外卖最先到,之后是我的,最后是老公的,8 天,24 炖饭,每次都这样.然后电赛比赛,初赛很优秀,复赛失利,没能去西安的最终国赛.大概就是这样吧,没想到一年过得这么快,经历了这么多,现在想起来还有点感动吧,感谢那些和我一起奋斗的朋友们!</li></ol><h3 id="关于刚到实验室"><a href="#关于刚到实验室" class="headerlink" title="关于刚到实验室"></a>关于刚到实验室</h3><ol start="3"><li>有关刚来实验室的感受，其实我觉得首先还是要再问自己一次是不是真的喜欢科创，是不是真的愿意为科创付出心血。718实验室和很多其他学校的实验室不一样，平常没有老师或者其他人天天盯着你要求你完成什么任务，一切全靠兴趣和自觉，加入实验室也很累，有可能你要牺牲掉周末，牺牲掉你的睡眠，甚至牺牲掉你的学习时间。所以我觉得既然选择了科创，选择了加入实验室，就要努力为实验室付出。其次，我觉得要学会提问，向你身边的学长或者同学提问题，学长都是在实验室呆过一年的人，有技术上的难题总会有学长能解决，也许就是可能就是一句话，比你自己研究几天都更有效果。同时我也相信，实验室的所有学长学姐都是愿意帮助你们的。</li></ol><h3 id="关于智能车比赛"><a href="#关于智能车比赛" class="headerlink" title="关于智能车比赛"></a>关于智能车比赛</h3><ol start="4"><li>之后我说一说关于做智能车方面的事情吧,做智能车的直观感受就是累,真的累,不管是身体上的累,还有心理上的累.这也是有些学长大二不太愿意做智能车的原因吧,不过我还是希望大一进来的队员都要参加这个比赛.一方面 718 实验室是智能车实验室,做智能车这个事情确实还是需要有人来传承的,从另一个方面来说,做一辆智能车确实很锻炼人的,智能车作为一个实际的工程项目,做一年智能车不仅能学到技术上的知识,更能学到的是处理实际工程问题的方法,做工程和做理论研究很不一样,什么不确定的情况都有可能发生,看看每年比赛有多少队伍翻车了就知道了,其实还能锻炼你的心态,锻炼团队协作能力等等.做智能车也仅仅是后期调参数比较累,前期准备写程序,画电路板等等还是很有意思也能学到很多东西的. 以下是我的一些建议:</li></ol><ul><li><p>首先是队员一定要选好,真的队员太重要了,跟一个和你合作不好的队员合作,真的还不如没<br>有人合作,这是我今年的教训,希望来年学弟们一定要选择好队员.队员技术都是次要的,最主<br>要的还是看这个人是不是想和你做一样的组别,这个人是不是有十足的科创精神,是不是真心<br>的想做科创,别做到一半队员放弃了. </p></li><li><p>队员的任务分工一开始就要做好,最开始就要敲定每个人大概要做什么,别像我们去年那样,<br>一个寒假过去了都以为有人在学画板子,结果到头来根本就没有人画板子,分工不一定要很细<br>致,因为也不可能什么情况都考虑到,但是大体的分工一定要有,谁写程序,谁画板子等等.</p></li><li><p>理想<br>的结果是两个人写程序,一个人做硬件,另外如果你们想做节能组的话就两个人做硬件和机械,<br>另一个人做软件. </p></li><li><p>队员之间多沟通,尤其是在寒假的时候,一定要经常沟通,你们可以经常内部组织小会,当然我<br>们也会经常性的来督促你们.<br>如果沟通交流好的话,那么任务分工一定是清晰的,时间制定也一定是清晰的.</p></li><li><p>说下时间制定,<br>一定尽量把时间向前提,尽早的完成更多的工作.</p></li><li><p><strong>寒假非常重要</strong>,学软件的一定要在开学前把<br>大体的框架搭建出来,做硬件的要在开学之前把你们的第一板电路发出去,你们开学后就开始<br>软硬件的组合,最好的情况就是两周之内就能让车跑起来,前期工作做的好的话最坏一个月也<br>能跑起来.</p></li><li><p>一定要尽早的让车跑起来,跑起来才能发现问题,改进算法,一般都是软件等硬件的,<br>像我去年就是等了一个多月的硬件. </p></li><li><p>我去年是做软件的,就多讲一些软件方面的事情.关于用软件库的问题,不知道你们明年用什<br>么库什么单片机,我们去年用的k60单片机,山外的库,我建议如果有能力就上KV58等更高级<br>一点的单片机然后使用相对更复杂但是更正轨一点的官方库,并且使用 CMSIS 的算法库,这<br>样要求可能有点高,但是对后续学习有极大的帮助,能少走许多弯路.</p></li><li><p>做软件的别一上来就想<br>着什么高级算法,先就用最普通的PID,最普通的巡线算法,高级算法都是后期的事情,智能车也<br>不是一个非常复杂的系统,你会发现最后还是一些相对简单的算法更有效(相对简单),直到你<br> 简单的算法调的差不多了也遇到瓶颈了,可以再加一些更高级的算法.主要也是这么多年了我<br>们实验室也没有能够对智能车建立一个数学模型,多数时候也是靠经验来调. </p></li><li><p>关于做车,硬件非常重要,机械更重要,千万不要以为车跑的不好就把锅推到软件身上,错了,硬<br>件决定了这个车的极限速度,软件只是说能不能达到这个极限速度.尤其是想做节能组的同学,<br>出问题基本都是电路和机械的问题,别把什么都往软件上推,就这么说吧,去年我们3到7月把<br>车调到了1m&#x2F;s的垃圾速度,7月中旬换了电源方案,5天调上2m&#x2F;s,我甚至有信心调到2.5m&#x2F;s. </p></li><li><p>做车别想着什么都要自己干,学会信任队友,别人干过的东西就不要再去干一遍了,多花时间<br>在研究新的东西上面.</p></li><li><p>做车也别太过于拼命了,还是注意下你们的身体,你们的学习成绩等等. </p></li><li><p>做软件的一定要学会利用工具,比如我在这里强烈推荐的 Git 分布式代码管理系统,能有效的<br>对代码进行版本控制,版本控制是很重要的,经常是调着调着车就不能跑了,你代码的版本就<br>要回退回去,另外 Git 还可以用来多人协同编程等等.</p></li><li><p>学会查找资源,现在互联网上的资源已经<br>是很多的了,没事多去各种技术社区看看,比如 CSDN,不一定要和车有关的技术,什么都可以<br>了解了解吧.</p></li><li><p>平时都了解单片机底层的一些知识,了解了解寄存器的操作,不知道怎么操作就<br>可从单片机是如何启动的开始看起,看着是汇编,看着看着就会了.</p></li><li><p>想全方面发展的去看看单<br>片机之外的东西,学学电脑上的编程,学学操作系统啥的都是可以的.</p></li></ul><h3 id="关于其他比赛"><a href="#关于其他比赛" class="headerlink" title="关于其他比赛"></a>关于其他比赛</h3><ol start="5"><li>关于做车我大概也就想暂时说这么多吧,进入实验室了,大家以后交流的机会还有很多,关于<br>做其他比赛以及比赛场上的相关注意事项,我想通过电赛这个比赛为例简单说一下吧,以下是<br>我以前在知乎上的一个回答: <blockquote><p>链接：<a href="https://www.zhihu.com/question/30453295/answer/216494491">https://www.zhihu.com/question/30453295/answer/216494491</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>泻药～<br> 刚参加完17年电赛，做的B题，板球控制系统，我负责的是软件部分目前省赛初赛结束，<br>我们组得分99分。感觉还行，就看几天之后的复试吧。<br>怎么说呢，全国电赛确实很难，我觉得最大的难点还是要求4天3夜就要做出来。不像NXP<br>智能车赛，电赛就要求前期必须要有很多的积累。<br>比如，熟悉各种外设，摄像头怎么调分辨率，怎么调阈值，蓝牙怎么配置，陀螺仪怎么卡尔<br>曼滤波，OLED怎么刷图，闪烁了怎么办，触摸屏怎么adc采集等等，熟悉参数整定的方法，<br>PID怎么调，什么时候该加入其他控制算法，是机械的问题还是参数的问题等等，知道如何<br>快速的解决问题，比如我们做到最后一天，摄像头突然图像撕裂了，网上也找不到解决方法，<br>就想到可能是中断嵌套了，修改了中断优先级立刻就好了那天晚上如果没有快速的解决问题，<br>那我们也就只能弃赛了，还要有耐得住通宵的身体，我们组在实验室呆了八天（电赛前就在<br>准备）每天睡4.5个小时，连通8天还是有很多人受不了的。<br>再说些其他感受吧。<br>1.人员配置很重要，队员间最好有一定默契，最坏也别有矛盾，队内先分裂了，那只有完蛋。<br>其次控制题机械真的很重要，也难怪有人说这是电子类机械设计大赛。我认为最理想的情况<br>就是有一个会3D打印，会切割，会雕刻，能快速设计出稳定的机械的人。一个一天能写几<br>千行代码，熟悉至少一块单片机和各种外设，能快速 debug 的软件很强的人，还有能一个<br>精通模电数电，能快速搭一个电路出来，熟悉焊接技术的模电强人。这样的话，软件硬件机<br>械都有就很强。<br>2.时间分配很重要，敲定一个题就不能中途换题。我们组的分配是这样的：第一天上午三人<br>共同决定做的题目，设计好大体的思路，下午和晚上负责软件的人搭建完大体的软件框架，<br>另外两个人搭建大体的机械和电路框架，焊接调试了以前设计的一块 PCB 印刷电路板。第<br>二天上午，我在对各种传感器进行调试，另外两人分别在安装传感器和组装机械，前一天3D<br>打印的各种器件也基本打印完毕，他们在安装。下午就基本组装完成了，勉强能开始调试，<br> 当然遇到了很多的坑，发现很多不合理的地方，比如摄像头晃动严重，舵机供电不稳，舵机<br>舵盘太长，容易产生虚位，软件还是有一堆 bug，甚至我们还遇到 jlink 掉固件了。经过一<br>夜的努力，第三天上午我们开始调参数了，我和一个队友在调参数，另一个队友在进一步的<br>完善机械，3D打印确实很不错，就是很耗时间，有一个连接件我们打印了15个小时才打印<br>完。调参数也是遇到很多坑，最开始我们想的是用普通的PID控制，效果就还可以了，勉强<br>球不会掉下去，后来我们又尝试了模糊PID，变论域 PID，bangbang控制等等，最后越调<br>越烂，最后还是硬调普通的PID解决了问题。第四天，大概就是在搞附加功能，我们想的是<br>用之前我写的一个蓝牙调试助手来控制球的位置，用触摸屏控制小球位置，用自制遥控器控<br>制小球位置不过最后遥控器调了两个小时确实没调出来就放弃了，搞机械的队友继续搞附加<br>部分的机械，另一个队友继续调参数，我在调试附加功能，结果到晚上又出现之前提到的那<br>个问题，不过还好，最后顺利封箱了。<br>3.赛前的积累和准备很重要，这个积累不仅是个人的知识经验的积累，也是整个参赛实验室<br>整体的积累，这样就算一个人遇到了问题暂时解决不了，但实验室里总有人能解决。一般赛<br>前几天都会有很多猜题的人，可以多去论坛或者多加几个电赛群看看。赛前的前几天，我记<br>得我在调试熟悉各种外设，摄像头，陀螺仪，加速度传感器，OLED，触摸屏等，特别是触<br>摸屏，完全是临时学习的，电阻触摸屏没什么人用了，所以卖的也很少，网购怕来不及，跑<br>遍了半个市才找到几块，网上也只有原理没有现成的程序，我也就只能一边拿示波器了解原<br>理，一边自己写库，一个 xy 轴坐标互相影响导致定位不准的问题卡了我好久，最后发现是<br>一个gpio的电平配置出了问题。另外一个队友设计了一块PCB印刷电路板，发加急在赛前<br>发回来了。电赛前一个星期基本上实验室就是24小时有人的状态了。<br>4.比赛前运输设备和现场调试很重要，今年这个板球系统尺寸都很大，很多队伍都选择拆了<br>到现场组装，其实非常不好，很多都出问题了，比赛前螺丝掉了的，舵机舵盘被撞烂了的，<br>摄像头歪了的，舵机中值变了的….很多问题，我们也是那天比赛下暴雨，板子被雨淋了，有<br>点变形再加上之前标定的失误，最后那个绕圈的功能失败，不幸扣了一分。现场调试千万心<br> 态别炸，遇到再严重的问题心态都别炸。赛前做好重要元件的备份，比如单片机，摄像头排<br>线等，想好可能遇到的问题，我应该怎么做。遇到答辩老师别紧张，一般他们不会故意为难<br>你的。</p></blockquote></li></ol><p> 以上就是我知乎上的回答. </p><h3 id="大一之后"><a href="#大一之后" class="headerlink" title="大一之后"></a>大一之后</h3><ol start="6"><li>说了这么多,最后再谈一谈实验室的发展和个人的发展吧.大二上也是个技术积累的关键<br>时期,大二上没有比赛,能更多的做自己想做的事情,也是拉开差距的时候,怎样让自己更有效<br>的学到东西?同时没有比赛,实验室成员之间的交流变少后怎样把大家团结在一起?众所周知,<br>实验室今年变化很大,尤其是纳新方面,怎么样才能在联合纳新的情况下收到更好的人?没有<br>提前批了怎么样才能吸引到技术很强的人?怎么样处理好和其他实验室的关系还有和科创中<br>心的关系?这些都是问题,不仅你们要面对,我们也要面对.到你们这一届实验室有可能要搬迁<br>了,会有更大的地盘,怎么利用好这些地盘,需不需要扩大实验室的规模,扩大以后人员在质量<br>会不会下降?随着时间的发展,智能车比赛也开始走下坡路了,如果有那么一天,智能车真的不<br>行了,我们实验室有应该如何转型?等等一系列问题都需要我们去思考.</li></ol><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><ol start="7"><li>说了这么多,也感谢你们有耐心听我这么啰嗦的说这么多吧,说了这么多,最后怎么做还<br>是看你们个人了.实验室是你们的,也是我们的,但最终是你们的.努力学习和生活吧,比较美好<br>的大学时光也是如此的短暂,我也希望你们日后回忆大学生活,有一个叫718的实验室,有一群<br>热爱科创的人令你们留念.</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86</summary>
        
      
    
    
    
    
    <category term="718创新实验室" scheme="https://blog.zzshub.cn/tags/718%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    <category term="个人总结" scheme="https://blog.zzshub.cn/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>STM32培训</title>
    <link href="https://blog.zzshub.cn/2017/10/30/STM32Course/"/>
    <id>https://blog.zzshub.cn/2017/10/30/STM32Course/</id>
    <published>2017-10-30T15:41:34.000Z</published>
    <updated>2024-07-02T05:07:11.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STM32从入门到精通"><a href="#STM32从入门到精通" class="headerlink" title="STM32从入门到精通"></a>STM32从入门到精通</h1><blockquote><p>Hi~ 哈工大威海718联创培训营的小伙伴们你们好,这是我们进行<strong>stm32</strong>单片机培训的相关资料,包括完整的<strong>示例程序,帮助文档,课件,</strong> 以及单片机的 <strong>硬件资料,原理图</strong> 等等.我们还将在大家学习的过程中不断地更新资料.</p></blockquote><h1 id="版本更新说明"><a href="#版本更新说明" class="headerlink" title="版本更新说明"></a>版本更新说明</h1><hr><ul><li>2017年10月15日 更新例程下载选项,以后无需手动选择下载器为STLink</li><li>2017年10月21日 修正了一个可能导致编译失败的问题,出现”core_cm3.o No such file”的小伙伴们可以更新试试</li><li>2017年10月22日 修正了SYSTICK定时器延时不正确的问题</li></ul><h1 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h1><hr><ul><li>下载地址:<a href="https://github.com/ZzzzzzS/STM32Learning/releases"><strong>https://codeload.github.com/ZzzzzzS/STM32Learing/zip/master</strong></a></li><li>备用下载地址:<a href="https://github.com/ZzzzzzS/STM32Learing"><strong>https://github.com/ZzzzzzS/STM32Learing</strong></a><blockquote><p>一般来说直接下载即可,若下载失败可点击备用下载地址,手动选择下载zip包,如图所示  <img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/STM32%E5%9F%B9%E8%AE%AD/c5Iw4.png" alt="下载失败"></p></blockquote></li></ul><h1 id="资料说明"><a href="#资料说明" class="headerlink" title="资料说明"></a>资料说明</h1><hr><table><thead><tr><th>文件夹名</th><th>说明</th></tr></thead><tbody><tr><td>原理图</td><td>硬件资料,说明电路连接情况</td></tr><tr><td>例程</td><td>各个外设示例程序</td></tr><tr><td>课程资料</td><td>上课ppt等资料</td></tr><tr><td>开始前的准备</td><td>软件安装等资料</td></tr><tr><td>帮助文档</td><td>由718创新实验室编写的例程和外设说明</td></tr><tr><td>ST官方资料</td><td>由ST意法半导体提供的相关说明</td></tr></tbody></table><blockquote><p>其他文件与stm32学习无关,有兴趣可自行研究</p></blockquote><h1 id="stm32开发板简介"><a href="#stm32开发板简介" class="headerlink" title="stm32开发板简介"></a>stm32开发板简介</h1><hr><p> <img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/STM32%E5%9F%B9%E8%AE%AD/c5hOU.png" alt="单片机图片"></p><p>由718创新实验室设计制作的<strong>stm32f103vet6</strong>开发板采用ST意法半导体生产的基于ARM cortex-M3内核的 stm32f103vet6作为主控芯片,另外附加有陀螺仪,加速度传感器,键盘,数码管等多种常用外设.</p><h3 id="以下是外设列表"><a href="#以下是外设列表" class="headerlink" title="以下是外设列表"></a>以下是外设列表</h3><table><thead><tr><th>名称&amp;型号</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>stm32f103vet6</td><td>主控芯片</td><td></td></tr><tr><td>温度传感器</td><td>较精确采集温度</td><td>集成在mpu6050内部</td></tr><tr><td>加速度传感器</td><td>感应加速度</td><td>集成在mpu6050内部</td></tr><tr><td>陀螺仪</td><td>感应旋转角速度</td><td>集成在mpu6050内部</td></tr><tr><td>单色LED灯</td><td></td><td>6个</td></tr><tr><td>全彩LED灯</td><td></td><td>1个</td></tr><tr><td>光电数码管</td><td>可以显示数字或其他信息</td><td>最多支持八位显示</td></tr><tr><td>蜂鸣器</td><td>产生声音信号</td><td></td></tr><tr><td>光敏电阻</td><td>感应光照强度</td><td></td></tr><tr><td>热敏电阻</td><td>粗略感知环境温度</td><td></td></tr><tr><td>独立按键</td><td>普通按钮</td><td>2个</td></tr><tr><td>矩阵键盘</td><td>利用特殊的编码方式实现的普通按钮</td><td>共16个按键</td></tr><tr><td>RTC晶振</td><td>可用于制作电子钟</td><td></td></tr></tbody></table><h1 id="例程说明"><a href="#例程说明" class="headerlink" title="例程说明"></a>例程说明</h1><hr><blockquote><p>这是建议的例程研究顺序</p></blockquote><ul><li>空白工程:方便大家建立工程使用</li><li>点亮一个小灯</li><li>闪烁一个小灯</li><li><a href="https://v.youku.com/v_show/id_XNDQxNTIxMzI=.html">流水灯闪烁</a></li><li>独立按键操作</li><li>矩阵键盘操作</li><li><a href="https://baike.baidu.com/item/%E6%95%B0%E7%A0%81%E7%AE%A1/9903965?fr=aladdin">数码管</a>显示(静态)</li><li><a href="https://baike.baidu.com/item/%E6%95%B0%E7%A0%81%E7%AE%A1/9903965?fr=aladdin">数码管</a>显示(动态)</li><li>TIM定时器中断</li><li>TIM定时器<a href="https://baike.baidu.com/item/PWM%E4%BF%A1%E5%8F%B7/10621898?fr=aladdin">PWM</a>波</li><li>TIM定时器脉冲计数</li><li>USART<a href="https://blog.csdn.net/huwei2003/article/details/36418471">串口</a>发送接收(查询)</li><li>USART<a href="https://blog.csdn.net/huwei2003/article/details/36418471">串口</a>发送接收(中断)</li><li>I2C<a href="https://baike.baidu.com/item/%E9%99%80%E8%9E%BA%E4%BB%AA/84317?fr=aladdin">陀螺仪</a>读写(模拟)</li><li>SPI <a href="https://baike.baidu.com/item/OLED/1328114?fr=aladdin">OLED</a>显示</li><li><a href="https://baike.baidu.com/item/ADC/6529867">ADC</a>模拟量转数字量采集</li><li><a href="https://www.eepw.com.cn/article/273706.htm">RTC</a>实时时钟计时</li></ul><hr><h4 id="POWERED-BY-718-INNOVATION-LAB"><a href="#POWERED-BY-718-INNOVATION-LAB" class="headerlink" title="POWERED BY 718 INNOVATION LAB"></a>POWERED BY <strong>718</strong> INNOVATION LAB</h4><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/STM32%E5%9F%B9%E8%AE%AD/c55mF.png" alt="logo"></p><hr>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;STM32从入门到精通&quot;&gt;&lt;a href=&quot;#STM32从入门到精通&quot; class=&quot;headerlink&quot; title=&quot;STM32从入门到精通&quot;&gt;&lt;/a&gt;STM32从入门到精通&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Hi~</summary>
        
      
    
    
    
    
    <category term="718创新实验室" scheme="https://blog.zzshub.cn/tags/718%E5%88%9B%E6%96%B0%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    <category term="ARM" scheme="https://blog.zzshub.cn/tags/ARM/"/>
    
    <category term="STM32" scheme="https://blog.zzshub.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>diansai2017上位机</title>
    <link href="https://blog.zzshub.cn/2017/10/29/diansai2017Uper/"/>
    <id>https://blog.zzshub.cn/2017/10/29/diansai2017Uper/</id>
    <published>2017-10-29T05:31:50.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电赛上位机"><a href="#电赛上位机" class="headerlink" title="电赛上位机"></a>电赛上位机</h1><h2 id="2017全国大学生电子设计竞赛板球控制系统上位机"><a href="#2017全国大学生电子设计竞赛板球控制系统上位机" class="headerlink" title="2017全国大学生电子设计竞赛板球控制系统上位机"></a>2017全国大学生电子设计竞赛板球控制系统上位机</h2><hr><blockquote><p>这是一个安卓版的蓝牙上位机,使用Qt on Android开发,原计划进入全国电赛总决赛时使用,可惜实力不够,没能进入全国总决赛.之后此上位机继续开发,供相关科技创新展示时控制板球系统使用.</p></blockquote><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/ZzzzzzS/diansai2017Uper">https://github.com/ZzzzzzS/diansai2017Uper</a></p><h1 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h1><ul><li>蓝牙SPP协议连接HC-05等蓝牙串口模块</li><li>蓝牙串口调试接收数据</li><li>按键控制板球上球的移动</li><li>手势控制球移动</li></ul><p><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E7%94%B5%E8%B5%9B%E4%B8%8A%E4%BD%8D%E6%9C%BA/0060lm7Tly1fkyep92vhcj30u01hc0yc.jpg" alt="调试界面"><br>调试界面<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E7%94%B5%E8%B5%9B%E4%B8%8A%E4%BD%8D%E6%9C%BA/0060lm7Tly1fkyepbkoosj30u01hc7bx.jpg" alt="手势控制"><br>手势控制<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E7%94%B5%E8%B5%9B%E4%B8%8A%E4%BD%8D%E6%9C%BA/0060lm7Tly1fkyepb2gqwj30u01hcdlc.jpg" alt="按键控制"></p><h1 id="开发经历"><a href="#开发经历" class="headerlink" title="开发经历"></a>开发经历</h1><ol><li>利用上位机控制板球这个想法是在做电赛的初期就有了,在板球的控制程序里面一直保留有串口控制的相关代码,在最初的省电赛时我们组就展示了蓝牙控制板球,不过那时采用的是网上找的上位机控制软件.省赛结束就开始用Qt安卓开发上位机,准备在国电赛的时候能够使用自己开发的上位机.<br>2.开发过程中遇到的第一个难点是串口数据的读取.原本认为安卓蓝牙和Windows平台上的一样,蓝牙连接后就会自动生成一个虚拟串口,使用QSerialport类即可读取.后来发现不是这样的,必须使用Qt的蓝牙类读取,蓝牙类配置蓝牙为SPP串口模式,配置好UUID等,通过蓝牙的socket类实现数据的读写,与Windows差别较大,Windows的Qt还没有QBluetooth类,不知道为什么.<br>3.第二个难点是在不同界面下蓝牙状态的确定.解决方法是每次生成一个页或者销毁一个页时都会向构造函数或者析构函数传入蓝牙的相关信息,有点类似于安卓的页面上下文切换.<br>4.另外在设计”神奇控制”模式时,研究了陀螺仪值的读取,发现非常简单,只需一句话即可读取.与单片机上陀螺仪读取的复杂形成鲜明对比.<br>5.有点遗憾的是这个上位机的界面设计太简陋了,以后有时间一定会优化界面布局.<br>6.由于ios系统限制,ios蓝牙无法使用普通蓝牙协议读取未经过MFi认证的蓝牙设备,读取未经认证的设备只能通过BLE低功耗蓝牙协议,也就是说基于蓝牙2.0的hc-05蓝牙模块无法被ios设备搜索到(经过实验确实检测不到),计划下一步换装cc2541蓝牙模块后开发ios版本的蓝牙上位机.</li></ol><h1 id="蓝牙连接以及读取过程简介"><a href="#蓝牙连接以及读取过程简介" class="headerlink" title="蓝牙连接以及读取过程简介"></a>蓝牙连接以及读取过程简介</h1><blockquote><p>首先感谢<a href="https://www.cnblogs.com/sigma0/p/5769527.html">Qt on Android 蓝牙开发 </a>这篇博客的作者,他的博客让我学到很多.Qt安卓搞蓝牙串口的相关资料确实太少了,官方帮助文档也写得不够详细.</p></blockquote><h3 id="Qt蓝牙支持的平台"><a href="#Qt蓝牙支持的平台" class="headerlink" title="Qt蓝牙支持的平台"></a>Qt蓝牙支持的平台</h3><p>查阅<a href="https://doc.qt.io/qt-5/qtbluetooth-index.html">Qt官方帮助文档</a>可知,Qt蓝牙和BLE蓝牙支持如下平台<br><img src="https://zzshubimage-1253829354.cos.ap-beijing.myqcloud.com/%E7%94%B5%E8%B5%9B%E4%B8%8A%E4%BD%8D%E6%9C%BA/0060lm7Tly1fkyfnvyvonj30v507l3zw.jpg" alt="支持的蓝牙平台"></p><h3 id="蓝牙基本组成"><a href="#蓝牙基本组成" class="headerlink" title="蓝牙基本组成"></a>蓝牙基本组成</h3><p>Qt蓝牙主要有以下3个类</p><ul><li>QBluetoothDeviceDiscoveryAgent 负责蓝牙的查找</li><li>QBluetoothLocalDevice 负责蓝牙设备开关状态以及工作模式</li><li>QBluetoothSocket 负责蓝牙的数据传输</li></ul><p>使用前需要在pro中添加<br><code>QT += bluetooth </code><br>添加头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtBluetooth&gt; </span><br><span class="line">#include &lt;QBluetoothAddress&gt;</span><br><span class="line">#include &lt;QBluetoothDeviceDiscoveryAgent&gt;</span><br><span class="line">#include &lt;QBluetoothLocalDevice&gt;</span><br><span class="line">#include &lt;QBluetoothSocket&gt; </span><br></pre></td></tr></table></figure><h3 id="蓝牙的初始化"><a href="#蓝牙的初始化" class="headerlink" title="蓝牙的初始化"></a>蓝牙的初始化</h3><p>蓝牙初始化主要就是要配置好<a href="https://blog.csdn.net/zf_c_cqupt/article/details/52177723">UUID</a>如果需要蓝牙串口的话使用我这个uuid即可,直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BlueTooth::<span class="built_in">BlueTooth</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ServiceUuid=<span class="built_in">QLatin1String</span>(<span class="string">&quot;00001101-0000-1000-8000-00805F9B34FB&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;LocalDevice=<span class="keyword">new</span> <span class="built_in">QBluetoothLocalDevice</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;DiscoverAgent=<span class="keyword">new</span> <span class="built_in">QBluetoothDeviceDiscoveryAgent</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;Socket=<span class="keyword">new</span> <span class="built_in">QBluetoothSocket</span>(QBluetoothServiceInfo::RfcommProtocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蓝牙打开与关闭"><a href="#蓝牙打开与关闭" class="headerlink" title="蓝牙打开与关闭"></a>蓝牙打开与关闭</h3><p>蓝牙打开与关闭很简单,需要注意的是部分安卓手机权限审核非常严格,可能还是需要在系统里面手动打开关闭蓝牙.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlueTooth::Power</span><span class="params">(<span class="type">bool</span> Power)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Power==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;LocalDevice-&gt;<span class="built_in">powerOn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Power==<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;LocalDevice-&gt;<span class="built_in">setHostMode</span>(QBluetoothLocalDevice::HostPoweredOff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>值得注意的是蓝牙关闭并不是写PowerOff</strong></p><h3 id="蓝牙的查找"><a href="#蓝牙的查找" class="headerlink" title="蓝牙的查找"></a>蓝牙的查找</h3><p>蓝牙查找只需要使用QBluetoothDeviceDiscoveryAgent类查找即可,查找后会自动发送信号,这样我们只需要写一个找到信号的槽函数,在槽函数里保存蓝牙的名称,<strong>UUID</strong>等等.一定要保存<strong>UUID</strong>我们知道蓝牙连接是使用UUID来连接的,后面连接时还需要用到所以一定要保存下来.由于不清楚找到的蓝牙设备个数,我使用一个向量来保存所有找到的蓝牙信息.由于涉及到信号槽的操作,需要仔细的分析信号槽的连接情况,不然可能导致信号槽不触发或者重复触发的情况.</p><h5 id="扫描设置函数"><a href="#扫描设置函数" class="headerlink" title="扫描设置函数"></a>扫描设置函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlueTooth::scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;LocalDevice-&gt;<span class="built_in">hostMode</span>()==QBluetoothLocalDevice::HostPoweredOff)</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="literal">NULL</span>,<span class="string">&quot;蓝牙未打开&quot;</span>,<span class="string">&quot;请打开蓝牙后重试&quot;</span>,QMessageBox::Ok);</span><br><span class="line">    &#125;</span><br><span class="line">    QObject::<span class="built_in">disconnect</span>(<span class="keyword">this</span>-&gt;DiscoverAgent,<span class="built_in">SIGNAL</span>(<span class="built_in">deviceDiscovered</span>(QBluetoothDeviceInfo)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">Discoverd</span>(QBluetoothDeviceInfo)));</span><br><span class="line">    <span class="keyword">this</span>-&gt;DeviceInfo.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;DiscoverAgent-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;DiscoverAgent-&gt;<span class="built_in">start</span>();</span><br><span class="line">    QObject::<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;DiscoverAgent,<span class="built_in">SIGNAL</span>(<span class="built_in">deviceDiscovered</span>(QBluetoothDeviceInfo)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">Discoverd</span>(QBluetoothDeviceInfo)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扫描到的槽函数"><a href="#扫描到的槽函数" class="headerlink" title="扫描到的槽函数"></a>扫描到的槽函数</h5><p>为了实现在不同的界面上显示蓝牙连接情况,我又自己设计了一下信号槽</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlueTooth::Discoverd</span><span class="params">(<span class="type">const</span> QBluetoothDeviceInfo &amp;info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;DeviceInfo.<span class="built_in">append</span>(info);</span><br><span class="line">    QBluetoothDeviceInfo send=info;</span><br><span class="line">    <span class="function">emit <span class="title">DisCoverdSignal</span><span class="params">(send)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConfigWindow::DisCoveredSlot</span><span class="params">(QBluetoothDeviceInfo InfoBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;BluetoothBox-&gt;<span class="built_in">addItem</span>(InfoBase.<span class="built_in">name</span>().<span class="built_in">toUtf8</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蓝牙的连接和断开"><a href="#蓝牙的连接和断开" class="headerlink" title="蓝牙的连接和断开"></a>蓝牙的连接和断开</h3><p>蓝牙的连接和断开操作类似.扫描完成后就进入连接操作,连接使用QBluetoothSocket类即可.与扫描类似,连接完成后可以设置在连接完成后发送信号,在槽函数中显示相应的提示信息.蓝牙也可以连接错误时发送错误信号,进入错误槽函数等.同样,由于涉及信号槽,需要仔细处理连接问题.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蓝牙连接函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlueTooth::BlueToothConnect</span><span class="params">(QBluetoothDeviceInfo Base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QObject::<span class="built_in">disconnect</span>(<span class="keyword">this</span>-&gt;Socket,<span class="built_in">SIGNAL</span>(<span class="built_in">connected</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">Connected</span>()));</span><br><span class="line">    <span class="keyword">this</span>-&gt;Socket-&gt;<span class="built_in">connectToService</span>(Base.<span class="built_in">address</span>(),<span class="built_in">QBluetoothUuid</span>(<span class="keyword">this</span>-&gt;ServiceUuid));</span><br><span class="line">    QObject::<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;Socket,<span class="built_in">SIGNAL</span>(<span class="built_in">connected</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">Connected</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连接完成槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlueTooth::Connected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit <span class="keyword">this</span>-&gt;<span class="built_in">ConnectOK</span>(<span class="literal">true</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="literal">NULL</span>,<span class="string">&quot;连接&quot;</span>,<span class="string">&quot;已连接成功!&quot;</span>,QMessageBox::Ok);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlueTooth::BlueToothDisConnect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QObject::<span class="built_in">disconnect</span>(<span class="keyword">this</span>-&gt;Socket,<span class="built_in">SIGNAL</span>(<span class="built_in">disconnected</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">Disconnected</span>()));</span><br><span class="line">    <span class="keyword">this</span>-&gt;Socket-&gt;<span class="built_in">disconnectFromService</span>();</span><br><span class="line">    QObject::<span class="built_in">connect</span>(<span class="keyword">this</span>-&gt;Socket,<span class="built_in">SIGNAL</span>(<span class="built_in">disconnected</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">Disconnected</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开成功槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlueTooth::Disconnected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit <span class="keyword">this</span>-&gt;<span class="built_in">DisConnetOK</span>(<span class="literal">true</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="literal">NULL</span>,<span class="string">&quot;断开&quot;</span>,<span class="string">&quot;已断开成功!&quot;</span>,QMessageBox::Ok);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蓝牙的传输"><a href="#蓝牙的传输" class="headerlink" title="蓝牙的传输"></a>蓝牙的传输</h3><p>到了这么久才到了正题,蓝牙的传输,蓝牙的传输主要借助于QBluetoothSocket类,和串口的传输很类似.这里主要分为传入和传出来讲</p><h4 id="传出"><a href="#传出" class="headerlink" title="传出"></a>传出</h4><p>传出操作比较简单,直接写<code>Socket-&gt;write(data.toUtf8());</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlueTooth::SafeWrite</span><span class="params">(QString data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Socket-&gt;<span class="built_in">state</span>()==QBluetoothSocket::ConnectedState)</span><br><span class="line">    &#123;</span><br><span class="line">        Socket-&gt;<span class="built_in">write</span>(data.<span class="built_in">toUtf8</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Socket-&gt;<span class="built_in">state</span>()==QBluetoothSocket::UnconnectedState)</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="literal">NULL</span>,<span class="string">&quot;蓝牙未连接&quot;</span>,<span class="string">&quot;请连接蓝牙或检查是否被其他程序占用&quot;</span>,QMessageBox::Ok);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="literal">NULL</span>,<span class="string">&quot;错误&quot;</span>,<span class="string">&quot;请检查蓝牙是否打开&quot;</span>,QMessageBox::Ok);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我设计的一个安全读写函数,可以在蓝牙未连接的时候报错</p><h4 id="传入"><a href="#传入" class="headerlink" title="传入"></a>传入</h4><p>蓝牙的传入就要相对复杂一些,和串口一样需要使用到信号槽实现,有点类似于单片机当中的UART中断<br>首先是初始化信号槽<code> QObject::connect(this-&gt;PortBase-&gt;Socket,SIGNAL(readyRead()),this,SLOT(ReceiveSlot()));</code><br>其次是槽函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConfigWindow::ReceiveSlot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;HEXBox-&gt;<span class="built_in">isChecked</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QByteArray buf=<span class="keyword">this</span>-&gt;PortBase-&gt;Socket-&gt;<span class="built_in">read</span>(<span class="number">1</span>);</span><br><span class="line">        QString str=<span class="string">&quot; &quot;</span>+buf.<span class="built_in">toHex</span>();</span><br><span class="line">        ui-&gt;ReceiveAera-&gt;<span class="built_in">insertPlainText</span>(str);</span><br><span class="line">        buf.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!ui-&gt;HEXBox-&gt;<span class="built_in">isChecked</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QByteArray buf;</span><br><span class="line">        buf =<span class="keyword">this</span>-&gt;PortBase-&gt;Socket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">        QString str=<span class="string">&quot;下位机:&quot;</span>+buf;</span><br><span class="line">        QString test=buf;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;test.<span class="built_in">toInt</span>();</span><br><span class="line">        ui-&gt;ReceiveAera-&gt;<span class="built_in">append</span>(str);</span><br><span class="line">        buf.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蓝牙部分大概就说这么多,其实这也只涉及Qt蓝牙操作当中的冰山一角,还有很多的部分值得我们去研究.</p><hr><h1 id="Qt安卓读取加速度计简介"><a href="#Qt安卓读取加速度计简介" class="headerlink" title="Qt安卓读取加速度计简介"></a>Qt安卓读取加速度计简介</h1><p>说起读取加速度计,那么一定要提到Qt的传感器类了.Qt的传感器类为我们提供了访问手机传感器的功能.读取传感器以前都需要在pro文件里面添加<br><code>QT       += sensors</code></p><h3 id="陀螺仪读取"><a href="#陀螺仪读取" class="headerlink" title="陀螺仪读取"></a>陀螺仪读取</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>由于我们是读取陀螺仪,那么就需要使用QAccelerometer类<br>需要包含头文件<code>#include &lt;QtSensors/QAccelerometer&gt;</code><br>同理,如果我们读取陀螺仪,那么就需要使用QGyroscope类,包含 <code>#include &lt;QGyroscope&gt;</code><br>我初始化时设置成定时器周期读取加速度计的值,所以在初始化的过程中也用到了QTimer类,以下是代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;AcceSensor.<span class="built_in">start</span>();<span class="comment">//初始化传感器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;AcceScanTimer.<span class="built_in">start</span>(<span class="number">10</span>);<span class="comment">//初始化定时器</span></span><br><span class="line">QObject::<span class="built_in">connect</span>(&amp;AcceScanTimer,<span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">AcceScan</span>()));</span><br></pre></td></tr></table></figure><h3 id="读取值"><a href="#读取值" class="headerlink" title="读取值"></a>读取值</h3><p>读取值非常简单,一句话即可搞定,以下是读取代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取传感器的值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x=AcceSensor.<span class="built_in">reading</span>()-&gt;<span class="built_in">x</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;y=AcceSensor.<span class="built_in">reading</span>()-&gt;<span class="built_in">y</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;z=AcceSensor.<span class="built_in">reading</span>()-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></table></figure><p>需要注意,读取回来的类型实际上就是double类型,不要被Qt的typedef所迷惑</p><p><strong>到这里整个加速度计的使用就完了</strong>相比单片机又要配置i2c,又要配置陀螺仪寄存器,读取回来还要自己计算角度,自己滤波,安卓上面确实简单了太多. </p><hr><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>其实写到这里我已经不想再写下去了,但是谁叫我强迫症突然发作呢</strong><br>虽然遗憾没能拿到国电赛一等奖,没能在总决赛上使用这个上位机.学习编写安卓上位机的整个过程却学习到了很多知识.毕竟学习知识的过程才是最重要的.我下一步计划开发ios版蓝牙上位机,研究cc2541蓝牙模块配合上位机使用.同时也计划开发一个功能更复杂,界面更精美,可以在线调试多种参数的上位机供18年智能汽车竞赛调试使用.</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;电赛上位机&quot;&gt;&lt;a href=&quot;#电赛上位机&quot; class=&quot;headerlink&quot; title=&quot;电赛上位机&quot;&gt;&lt;/a&gt;电赛上位机&lt;/h1&gt;&lt;h2 id=&quot;2017全国大学生电子设计竞赛板球控制系统上位机&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="作品" scheme="https://blog.zzshub.cn/tags/%E4%BD%9C%E5%93%81/"/>
    
    <category term="Qt" scheme="https://blog.zzshub.cn/tags/Qt/"/>
    
    <category term="2017电赛" scheme="https://blog.zzshub.cn/tags/2017%E7%94%B5%E8%B5%9B/"/>
    
    <category term="安卓" scheme="https://blog.zzshub.cn/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>关于博客</title>
    <link href="https://blog.zzshub.cn/2017/10/27/first_blog/"/>
    <id>https://blog.zzshub.cn/2017/10/27/first_blog/</id>
    <published>2017-10-26T16:50:44.000Z</published>
    <updated>2024-07-02T05:07:11.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刚刚终于建立了站点"><a href="#刚刚终于建立了站点" class="headerlink" title="刚刚终于建立了站点"></a>刚刚终于建立了站点</h1><hr><blockquote><p>刚刚终于基本建立了这个博客。博客是采用hexo框架托管在github page上面的.首先 <del>感谢<a href="https://github.com/Mrminfive">Mrminfive</a>无私贡献的<a href="https://github.com/Mrminfive/hexo-theme-skapp">skapp</a></del> 感谢<a href="https://demo.jerryc.me/">jerryc127</a>无私贡献的<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a>主题模板。</p></blockquote><hr><h2 id="建站更新"><a href="#建站更新" class="headerlink" title="建站更新"></a>建站更新</h2><ul><li>2023年7月1日</li></ul><p>更新博客主题到<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly 4.9</a></p><ul><li>2020年12月27日</li></ul><p>将博客自动化构建工具切换为<a href="https://docs.github.com/en/free-pro-team@latest/actions">Github Action</a></p><ul><li>2020年7月26日</li></ul><p>修改博客主题到<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></p><ul><li>2018年11月7日</li></ul><p>构建出完整的编译工具链,在iPad Pro上更新博客</p><ul><li>2018年5月2日</li></ul><p>添加数学公式支持</p><ul><li>2018年4月25日</li></ul><p>修复了搜索栏layout不正常的错误，修复了部分评论无法初始化的错误，清除了混乱的评论</p><ul><li>2018年4月13日</li></ul><p>使用TravisCI持续集成自动化部署博客</p><ul><li>2018年3月20日</li></ul><p>博客崩溃，重新创建博客</p><ul><li>2017年11月17日</li></ul><p>重新优化博客访问速度</p><ul><li>2017年11月3日</li></ul><p>为博客添加了分享功能,博客采用<a href="https://www.mob.com/">ShareSDK</a>实现分享功能</p><ul><li>2017年10月31日</li></ul><p>为博客添加了视频支持,底部有视频测试,添加了网易云音乐播放连接,底部有播放的连接</p><ul><li>2017年10月31日</li></ul><p>为博客添加了加密功能,部分博客需要输入密码才能查看</p><ul><li>2017年10月30日</li></ul><p>为博客系统添加了<a href="https://gitalk.github.io/">gitalk</a>评论系统,可以通过登陆github账号实现对我的博客的评论</p><ul><li>2017年10月30日</li></ul><p>为博客添加了站内搜索,百度统计,文章阅读数统计,将网站背景指向必应美图等</p><h2 id="第一个个人站点"><a href="#第一个个人站点" class="headerlink" title="第一个个人站点"></a>第一个个人站点</h2><p>这是我成功放到网上的个人站点，同时这也是我第一篇博客。从小学起，我一直都有一个建立一个个人站点的愿望。小学4年级开始研究微软的<a href="https://baike.baidu.com/item/Frontpage/2137423?fr=aladdin">frontpage</a>。只不过那时止步于88元一年的服务器费用，停止了研究。时间过得很快，很快就到了高中，那时家里换了路由器，我也有机会在新的路由器操作系统<a href="https://www.hiwifi.com/">hiwifiOS</a>玩一些东西，其实也就是纯粹的瞎折腾，那时候因为乱搞路由导致经常网络不稳定被家里人说过，不过也就是在那个时候，我才大概搞懂了网络的一些东西，利用hiwifiOS提供的插件，做了个上网欢迎页出来，也利用smb+DDNS服务搭建过个人网盘。真正开始系统的学习计算机方面的技术已经是大学的事了，上个月开发给新生培训用的<strong>STM32</strong>单片机的示例程序的时候才发现有一个叫github page的东西，顺藤摸瓜，找到了jekyll，学习了几天jekyll发现这个东西看起来太费劲了，进一步搜索，便找到了简单易学hexo，建立了这个很久以来都想建立的博客，也算是实现了儿时的一个愿望吧。</p><h2 id="构建博客的经历"><a href="#构建博客的经历" class="headerlink" title="构建博客的经历"></a>构建博客的经历</h2><ul><li>写STM32示例程序的过程中发现github page</li><li>初步了解github page 用自带的模板搭建了一个网页<a href="https://zzzzzzs.github.io/STM32Learning/">718创联 STM32培训</a></li><li>进一步研究发现了jekyll</li><li>发现了hexo</li><li>用初始主题搭建了博客本地运行正常</li><li>找到了这个主题</li><li>Windows系统对某组件兼容异常</li><li>转到Mac平台，发布博客</li></ul><hr><h1 id="音乐测试"><a href="#音乐测试" class="headerlink" title="音乐测试"></a>音乐测试</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=5264843&auto=0&height=66"></iframe><p>$ \iint_s $</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;刚刚终于建立了站点&quot;&gt;&lt;a href=&quot;#刚刚终于建立了站点&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="blog" scheme="https://blog.zzshub.cn/tags/blog/"/>
    
  </entry>
  
</feed>
